/*
 Navicat Premium Data Transfer

 Source Server         : localhost_27017
 Source Server Type    : MongoDB
 Source Server Version : 50008
 Source Host           : localhost:27017
 Source Schema         : blog

 Target Server Type    : MongoDB
 Target Server Version : 50008
 File Encoding         : 65001

 Date: 13/05/2022 11:21:17
*/


// ----------------------------
// Collection structure for articledatedata
// ----------------------------
db.getCollection("articledatedata").drop();
db.createCollection("articledatedata");

// ----------------------------
// Documents of articledatedata
// ----------------------------
db.getCollection("articledatedata").insert([ {
    _id: ObjectId("627a6048a9803a69c3d6c820"),
    date: ISODate("2022-05-09T16:00:00.000Z"),
    hit: NumberLong("10"),
    visitor: NumberLong("7"),
    _class: "com.wyj.blog.pojo.ArticleDateData"
} ]);
db.getCollection("articledatedata").insert([ {
    _id: ObjectId("627b87281947aa32e2a4beb1"),
    date: ISODate("2022-05-10T16:00:00.000Z"),
    hit: NumberLong("13"),
    visitor: NumberLong("7"),
    _class: "com.wyj.blog.pojo.ArticleDateData"
} ]);
db.getCollection("articledatedata").insert([ {
    _id: ObjectId("627cb89606ea2876bc375aef"),
    date: ISODate("2022-05-11T16:00:00.000Z"),
    hit: NumberLong("7"),
    visitor: NumberLong("2"),
    _class: "com.wyj.blog.pojo.ArticleDateData"
} ]);
db.getCollection("articledatedata").insert([ {
    _id: ObjectId("627dc6fb556eb954b06fa65e"),
    date: ISODate("2022-05-12T16:00:00.000Z"),
    hit: NumberLong("26"),
    visitor: NumberLong("4"),
    _class: "com.wyj.blog.pojo.ArticleDateData"
} ]);

// ----------------------------
// Collection structure for blog
// ----------------------------
db.getCollection("blog").drop();
db.createCollection("blog");

// ----------------------------
// Documents of blog
// ----------------------------
db.getCollection("blog").insert([ {
    _id: ObjectId("627a60cfa9803a69c3d6c822"),
    title: "Java 运算符",
    content: "<h1 class=\"markdown-h1\">算术运算符</h1>\n<h2 class=\"markdown-h2\">+</h2>\n<ul class=\"markdown-list\">\n<li>数学加法\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">1+1</code> 结果为2</li>\n</ul>\n</li>\n<li>字符串拼接\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">&quot;1&quot;+1</code>结果为11</li>\n<li>当运算中有char类型时，<code class=\"markdown-linecode\">'1'+1</code> ，计算方式为'1’的ASCII码49和1相加，结果为50</li>\n<li>当前面为数值运算，中间出现字符串类型数据时，从第一个字符串数据开始变为字符串拼接，之前的数值运算还是按照加法计算,<code class=\"markdown-linecode\">3+5+&quot;1&quot;+5+3</code>,结果为8153</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">-</h2>\n<ul class=\"markdown-list\">\n<li>数学减法\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">2-1</code> 结果为1</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">*</h2>\n<p>乘法需要注意的是数据越界问题，在Java中数据越界不会出现编译错误，也不会出现运行时错误，需要格外警惕</p>\n<blockquote class=\"markdown-blockquote\">\n<p>计算一年中有多少秒？</p>\n<p><code class=\"markdown-linecode\">System.out.println(365*24*60*60*1000);</code> &gt;&gt; <code class=\"markdown-linecode\">1471228928</code></p>\n<p>我们使用计算器计算，得到的结果是<code class=\"markdown-linecode\">31,536,000,000</code></p>\n<p>显然我们程序的计算的结果是不正确的，print默认是使用int类型的</p>\n<p>我们的计算数据已经超过了int的最大值，所以需要转换为更大的long类型</p>\n<p><code class=\"markdown-linecode\">System.out.println(365L*24*60*60*1000);</code> &gt;&gt; <code class=\"markdown-linecode\">31536000000</code></p>\n</blockquote>\n<h2 class=\"markdown-h2\">/</h2>\n<p>除法得到的结果都是整数，<code class=\"markdown-linecode\">25/10*10</code> 这个算式在数学中得到的结果会是25，但在Java中结果会是20，原因就是25/10 = 2.5 在Java中只会取2，然后再*10 得到的就是20</p>\n<ul class=\"markdown-list\">\n<li>在计算进度条等需要百分比的时候，如果使用int需要考虑计算顺序(1/100 ~ 99/100 一直都是0)</li>\n</ul>\n<blockquote class=\"markdown-blockquote\">\n<p>一个网站中共计有283条数据，一页中只能显示25条，问如何用/实现分页？</p>\n</blockquote>\n<pre><code class=\"language-java\">int x = 283;\nint y = 25;\nSystem.out.println((x+y-1)/y);\n</code></pre>\n<h2 class=\"markdown-h2\">%</h2>\n<p>取余运算符</p>\n<blockquote class=\"markdown-blockquote\">\n<p>输入一个整数，判断这个数是不是奇数，返回布尔类型</p>\n</blockquote>\n<pre><code class=\"language-java\">// %操作\npublic static boolean check(int x){\n\treturn x%2 == 1;\n}\n</code></pre>\n<pre><code class=\"language-java\">// 效率更高的位运算\npublic static boolean check(int x){\n   // 取二进制最后一位，如果是1则说明为奇数\n   return (x &amp; 1) == 1;\n}\n</code></pre>\n<h1 class=\"markdown-h1\">结合赋值</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>+=、*=、/=、-=</p>\n</blockquote>\n<ul class=\"markdown-list\">\n<li>当使用<code class=\"markdown-linecode\">结合运算符</code>并且运算结果的类型与存储结果的变量类型不同时会进行隐式强制类型转换</li>\n</ul>\n<pre><code class=\"language-java\">int x = 5;\nx += 3.5;  // 等价于：x = (int)(x + 3.5)\nSystem.out.println(x);\n</code></pre>\n<h1 class=\"markdown-h1\">自增自减运算符</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>++、--</p>\n</blockquote>\n<p>这两种运算符有两种不同的形式，分别是前缀形式<code class=\"markdown-linecode\">++i</code>和后缀形式<code class=\"markdown-linecode\">i++</code></p>\n<ul class=\"markdown-list\">\n<li>前缀式：先自增或者自减，然后在参与运算</li>\n<li>后缀式：先参与运算，然后再自增或者自减</li>\n</ul>\n<blockquote class=\"markdown-blockquote\">\n<p><strong>尽量不要再表达式中使用自增自减运算符，这样使用会使阅读代码的成本提升，产生隐蔽的BUG</strong></p>\n<p>--- 《Java 核心技术 卷Ⅰ 原书第十版》</p>\n</blockquote>\n<h1 class=\"markdown-h1\">关系运算符</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>&gt;(大于)、&gt;=(大于等于)、&lt;(小于)、&lt;=(小于等于)、==(等于)、!=(不等于)</p>\n</blockquote>\n<h1 class=\"markdown-h1\">逻辑运算符</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>&amp;&amp;(与)、||(或)、!(非)</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p>&amp;&amp;和||，<strong>具有短路机制</strong>，当左侧已经满足要求时，右侧的表达式将不会执行</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p>&amp;和|也能用作逻辑判断，但是这两个<strong>没有短路机制</strong>，当不论条件是否满足都要执行表达式时，可以使用这两个运算符来实现</p>\n</blockquote>\n<pre><code class=\"language-java\">// 短路机制\nint x = 1;\nint y = 2;\nSystem.out.println((x == 1) || ((y += 1) == 3));\nSystem.out.println(x);\nSystem.out.println(y);\n&gt;&gt;&gt;\n    true\n    1\n    2\n</code></pre>\n<pre><code class=\"language-java\">// 非短路\nint x = 1;\nint y = 2;\nSystem.out.println((x == 1) | ((y += 1) == 3));\nSystem.out.println(x);\nSystem.out.println(y);\n&gt;&gt;&gt;\n    true\n    1\n    3\n</code></pre>\n<h1 class=\"markdown-h1\">三元运算符</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>也叫三目运算符</p>\n</blockquote>\n<pre><code class=\"language-java\">x &gt; y ? 1 : 0\n</code></pre>\n<h1 class=\"markdown-h1\">位运算符</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>&amp;(与)、|(或)、~(非)、^(异或)</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p>&gt;&gt;(右移运算符)、&lt;&lt;(左移运算符)、&gt;&gt;&gt;(无符号右移)</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">int</code>类型在进行<code class=\"markdown-linecode\">&lt;&lt;</code>操作时需要对右操作数进行模32运算得到的才是最终结果</p>\n</blockquote>\n<pre><code class=\"language-java\">System.out.println((1 &lt;&lt; 35) == (1 &lt;&lt; 3));\n&gt;&gt;&gt;\n    true\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">long</code>类型在进行<code class=\"markdown-linecode\">&lt;&lt;</code>操作时需要对右操作数进行模64运算才能得到最终结果</p>\n</blockquote>\n<pre><code class=\"language-java\">System.out.println((1 &lt;&lt; 67) == (1 &lt;&lt; 131));\n&gt;&gt;&gt; \n    true\n</code></pre>\n<h2 class=\"markdown-h2\"><code class=\"markdown-linecode\">&amp;</code>掩码操作</h2>\n<pre><code class=\"language-java\">// 检查X的二进制右数第四位是否为1，为1返回1，为0返回0\nint x = 123;\nint flag = (x &amp; 0b1000) / 0b1000;\nSystem.out.println(flag);\n</code></pre>\n<h2 class=\"markdown-h2\"><code class=\"markdown-linecode\">&gt;&gt;</code>掩码操作</h2>\n<pre><code class=\"language-java\">// 检查X的二进制右数第四位是否为1，为1返回1，为0返回0\nint x = 123;\nint flag = (x &amp; (1 &lt;&lt; 3)) &gt;&gt; 3;\nSystem.out.println(flag);\n</code></pre>\n",
    markdown: "# 算术运算符\n\n## +\n\n- 数学加法\n  - `1+1` 结果为2\n- 字符串拼接\n  - `\"1\"+1`结果为11\n  - 当运算中有char类型时，`'1'+1` ，计算方式为'1’的ASCII码49和1相加，结果为50\n  - 当前面为数值运算，中间出现字符串类型数据时，从第一个字符串数据开始变为字符串拼接，之前的数值运算还是按照加法计算,`3+5+\"1\"+5+3`,结果为8153\n\n## - \n\n- 数学减法\n  - `2-1` 结果为1\n\n## *\n\n乘法需要注意的是数据越界问题，在Java中数据越界不会出现编译错误，也不会出现运行时错误，需要格外警惕\n\n> 计算一年中有多少秒？\n>\n> `System.out.println(365*24*60*60*1000);` >> `1471228928`\n>\n> 我们使用计算器计算，得到的结果是`31,536,000,000`\n>\n> 显然我们程序的计算的结果是不正确的，print默认是使用int类型的\n>\n> 我们的计算数据已经超过了int的最大值，所以需要转换为更大的long类型\n>\n> `System.out.println(365L*24*60*60*1000);` >> `31536000000`\n\n\n\n## /\n\n除法得到的结果都是整数，`25/10*10` 这个算式在数学中得到的结果会是25，但在Java中结果会是20，原因就是25/10 = 2.5 在Java中只会取2，然后再*10 得到的就是20\n\n- 在计算进度条等需要百分比的时候，如果使用int需要考虑计算顺序(1/100 ~ 99/100 一直都是0)\n\n> 一个网站中共计有283条数据，一页中只能显示25条，问如何用/实现分页？\n\n ```java\nint x = 283;\nint y = 25;\nSystem.out.println((x+y-1)/y);\n ```\n\n\n\n## %\n\n取余运算符\n\n> 输入一个整数，判断这个数是不是奇数，返回布尔类型\n\n ```java\n// %操作\npublic static boolean check(int x){\n\treturn x%2 == 1;\n}\n ```\n\n ```java\n// 效率更高的位运算\npublic static boolean check(int x){\n    // 取二进制最后一位，如果是1则说明为奇数\n    return (x & 1) == 1;\n}\n ```\n\n# 结合赋值\n\n> +=、*=、/=、-=\n\n- 当使用`结合运算符`并且运算结果的类型与存储结果的变量类型不同时会进行隐式强制类型转换\n\n```java\nint x = 5;\nx += 3.5;  // 等价于：x = (int)(x + 3.5)\nSystem.out.println(x);\n```\n\n# 自增自减运算符\n\n> ++、--\n\n这两种运算符有两种不同的形式，分别是前缀形式`++i`和后缀形式`i++`\n\n- 前缀式：先自增或者自减，然后在参与运算\n- 后缀式：先参与运算，然后再自增或者自减\n\n> **尽量不要再表达式中使用自增自减运算符，这样使用会使阅读代码的成本提升，产生隐蔽的BUG**\n>\n> --- 《Java 核心技术 卷Ⅰ 原书第十版》\n\n# 关系运算符\n\n> \\>(大于)、>=(大于等于)、\\<(小于)、<=(小于等于)、==(等于)、!=(不等于)\n\n# 逻辑运算符\n\n> &&(与)、||(或)、!(非)\n\n> &&和||，**具有短路机制**，当左侧已经满足要求时，右侧的表达式将不会执行\n\n> &和|也能用作逻辑判断，但是这两个**没有短路机制**，当不论条件是否满足都要执行表达式时，可以使用这两个运算符来实现\n\n```java\n// 短路机制\nint x = 1;\nint y = 2;\nSystem.out.println((x == 1) || ((y += 1) == 3));\nSystem.out.println(x);\nSystem.out.println(y);\n>>>\n    true\n    1\n    2\n```\n\n```java\n// 非短路\nint x = 1;\nint y = 2;\nSystem.out.println((x == 1) | ((y += 1) == 3));\nSystem.out.println(x);\nSystem.out.println(y);\n>>>\n    true\n    1\n    3\n```\n\n\n\n# 三元运算符\n\n> 也叫三目运算符\n\n```java\nx > y ? 1 : 0\n```\n\n# 位运算符\n\n> &(与)、|(或)、~(非)、^(异或)\n\n> \\>>(右移运算符)、<<(左移运算符)、\\>>>(无符号右移)\n\n> `int`类型在进行`<<`操作时需要对右操作数进行模32运算得到的才是最终结果\n\n```java\nSystem.out.println((1 << 35) == (1 << 3));\n>>>\n    true\n```\n\n> `long`类型在进行`<<`操作时需要对右操作数进行模64运算才能得到最终结果\n\n```java\nSystem.out.println((1 << 67) == (1 << 131));\n>>> \n    true\n```\n\n\n\n## `&`掩码操作\n\n```java\n// 检查X的二进制右数第四位是否为1，为1返回1，为0返回0\nint x = 123;\nint flag = (x & 0b1000) / 0b1000;\nSystem.out.println(flag);\n```\n\n## `>>`掩码操作\n\n```java\n// 检查X的二进制右数第四位是否为1，为1返回1，为0返回0\nint x = 123;\nint flag = (x & (1 << 3)) >> 3;\nSystem.out.println(flag);\n```\n\n",
    type: "Java",
    tag: [
        "Java基础",
        "Python模块"
    ],
    hit: NumberLong("16"),
    createDate: ISODate("2022-05-10T12:55:43.222Z"),
    modifyDate: ISODate("2022-05-13T03:03:35.915Z"),
    _class: "com.wyj.blog.pojo.Article",
    comment: [
        {
            _id: ObjectId("627a6134a9803a69c3d6c826"),
            nickname: "张三",
            email: "1@qq.com",
            commentContent: "写的非常好！",
            createTime: ISODate("2022-05-10T12:57:24.803Z")
        },
        {
            _id: ObjectId("627a6156a9803a69c3d6c827"),
            nickname: "1",
            email: "1@qq.com",
            commentContent: "1",
            createTime: ISODate("2022-05-10T12:57:58.435Z")
        },
        {
            _id: ObjectId("627a6240a9803a69c3d6c82d"),
            nickname: "123123",
            email: "123@qq.com",
            commentContent: "123",
            createTime: ISODate("2022-05-10T13:01:52.296Z")
        },
        {
            _id: ObjectId("627dcc88556eb954b06fa667"),
            nickname: "李四",
            email: "123456789@qq.com",
            commentContent: "李四的评论内容",
            createTime: ISODate("2022-05-13T03:12:08.608Z")
        }
    ]
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627a619ba9803a69c3d6c828"),
    title: "Java 简单读写操作",
    content: "<h1 class=\"markdown-h1\">读取</h1>\n<h2 class=\"markdown-h2\">Scanner</h2>\n<pre><code class=\"language-java\">// 会抛出IOException\nScanner in = new Scanner(Paths.get(&quot;file.txt&quot;), &quot;UTF-8&quot;);\nwhile (in.hasNextLine()) {\n    System.out.println(in.nextLine());\n}\n</code></pre>\n<h1 class=\"markdown-h1\">写出</h1>\n<h2 class=\"markdown-h2\">PrintWriter</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>PrintWriter可以像System.out一样使用println、print、printf来向文件写出内容</p>\n<p>当文件不存在时，会创建一个文件</p>\n</blockquote>\n<pre><code class=\"language-java\">// 将屏幕输入的字符输出到文件\n\nScanner in = new Scanner(System.in);\nString s = &quot;&quot;; // 存储输入的临时变量\n// 写出对象\nPrintWriter pw = new PrintWriter(&quot;outfile.txt&quot;);\n// 当输入不为q时，将数据写入到文件\nwhile (!&quot;q&quot;.equals(s = in.nextLine())) {\n    pw.println(s);\n}\n// 关闭写出对象\npw.close();\n</code></pre>\n<h1 class=\"markdown-h1\">手动指定输入输出文件</h1>\n<ul class=\"markdown-list\">\n<li>下面代码+命令行实现的效果为将file.txt的内容复制到outfile.txt</li>\n</ul>\n<pre><code class=\"language-java\">Scanner in = new Scanner(System.in);\nwhile (in.hasNextLine()) {\n    System.out.println(in.nextLine());\n}\n</code></pre>\n<pre><code class=\"language-shell\"># 运行Test，将System.in设定为file.txt 将System.out设置为outfile.txt\njavac Test.java &amp;&amp; java Test &lt; file.txt &gt; outfile.txt\n</code></pre>\n<h1 class=\"markdown-h1\">读写常用功能</h1>\n<h2 class=\"markdown-h2\">获取当前运行路径</h2>\n<pre><code class=\"language-java\">System.getProperty(&quot;user.dir&quot;)\n</code></pre>\n",
    markdown: "# 读取\n\n## Scanner\n\n```java\n// 会抛出IOException\nScanner in = new Scanner(Paths.get(\"file.txt\"), \"UTF-8\");\nwhile (in.hasNextLine()) {\n    System.out.println(in.nextLine());\n}\n```\n\n# 写出\n\n## PrintWriter\n\n> PrintWriter可以像System.out一样使用println、print、printf来向文件写出内容\n>\n> 当文件不存在时，会创建一个文件\n\n```java\n// 将屏幕输入的字符输出到文件\n\nScanner in = new Scanner(System.in);\nString s = \"\"; // 存储输入的临时变量\n// 写出对象\nPrintWriter pw = new PrintWriter(\"outfile.txt\");\n// 当输入不为q时，将数据写入到文件\nwhile (!\"q\".equals(s = in.nextLine())) {\n    pw.println(s);\n}\n// 关闭写出对象\npw.close();\n```\n\n\n\n# 手动指定输入输出文件\n\n- 下面代码+命令行实现的效果为将file.txt的内容复制到outfile.txt\n\n```java\nScanner in = new Scanner(System.in);\nwhile (in.hasNextLine()) {\n    System.out.println(in.nextLine());\n}\n```\n\n```shell\n# 运行Test，将System.in设定为file.txt 将System.out设置为outfile.txt\njavac Test.java && java Test < file.txt > outfile.txt\n```\n\n\n\n# 读写常用功能\n\n## 获取当前运行路径\n\n```java\nSystem.getProperty(\"user.dir\")\n```\n\n",
    type: "Java",
    tag: [
        "Java基础"
    ],
    hit: NumberLong("7"),
    createDate: ISODate("2022-05-10T12:59:07.403Z"),
    modifyDate: ISODate("2022-05-10T12:59:07.403Z"),
    _class: "com.wyj.blog.pojo.Article",
    comment: [
        {
            _id: ObjectId("627a621ca9803a69c3d6c82c"),
            nickname: "测试",
            email: "12@qq.com",
            commentContent: "测试",
            createTime: ISODate("2022-05-10T13:01:16.448Z")
        }
    ]
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627a61cfa9803a69c3d6c829"),
    title: "Java 数组&Arrays类",
    content: "<h1 class=\"markdown-h1\">数组</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>数组是一种数据结构，用来存储同一类型值的集合。通过一个整型下标可以访问数组中的每一个值。</p>\n<p>Java中的数组是定长数组，一旦确定大小之后是不能改变的</p>\n</blockquote>\n<pre><code class=\"language-java\">// 两种方式都能创建数组\nint a[] = new int[10]; \nint[] b = new int[10]; // 使用这种方式的人更多\n</code></pre>\n<h2 class=\"markdown-h2\">初始化</h2>\n<h2 class=\"markdown-h2\">各种类型的默认初始化值</h2>\n<pre><code class=\"language-java\">int[] a = new int[3];\ndouble[] b = new double[3];\nchar[] c = new char[3];\nString[] d = new String[3];\n\nSystem.out.println(Arrays.toString(a)); // [0, 0, 0]\nSystem.out.println(Arrays.toString(b)); // [0.0, 0.0, 0.0]\nSystem.out.println(Arrays.toString(c)); // [, , ]\nSystem.out.println(Arrays.toString(d)); // [null, null, null]\n</code></pre>\n<h2 class=\"markdown-h2\">遍历</h2>\n<h3 class=\"markdown-h3\">for</h3>\n<pre><code class=\"language-java\">for (int i = 0; i &lt; a.length; i++) {\n    System.out.println(a[i]);\n}\n</code></pre>\n<h3 class=\"markdown-h3\">foreach</h3>\n<pre><code class=\"language-java\">for (int i : a) {\n    System.out.println(i);\n}\n</code></pre>\n<h3 class=\"markdown-h3\">Arrays.toString</h3>\n<pre><code class=\"language-java\">Arrays.toString(a)\n</code></pre>\n<h1 class=\"markdown-h1\">Arrays</h1>\n<h2 class=\"markdown-h2\">常用方法</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>static String toString(Object[] a)</p>\n<p>将任意类型的数组转为字符串,字符串格式为[x,x,x,x]</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>static String deepToString(Object[] a)</p>\n<p>将多维数组转换为字符串，字符串格式[[x,x,x],[y,y,y]]</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>static <T> T[] copyOf(T[] original, int newLength)</p>\n<p>复制original到一个新的数组，新数组的长度为newLength</p>\n<p>如果newLength大于原数组则按照数据类型补充默认数据</p>\n<p>如果newLength小于原数组则只取前面newLength个数据</p>\n<p>返回创建的新数组</p>\n<p>注意：该方法为<strong>浅复制</strong></p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>static void sort(int[] a)</p>\n<p>对数组a进行排序</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>static int binarySearch(Object[] a, Object key)</p>\n<p>在数组a中使用二分查找法来寻找key的下标位置</p>\n<p>存在返回下标</p>\n<p>不存在返回-1</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>static void fill(Object[] a, Object val)</p>\n<p>使用val将数组a填满</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>static boolean equals(Object[] a, Object[] a2)</p>\n<p>判断a和a2的数量和每个下标的对象是否相同(equals)，相同返回true</p>\n</blockquote>\n<hr />\n",
    markdown: "# 数组\n\n> 数组是一种数据结构，用来存储同一类型值的集合。通过一个整型下标可以访问数组中的每一个值。\n>\n> Java中的数组是定长数组，一旦确定大小之后是不能改变的\n\n```java\n// 两种方式都能创建数组\nint a[] = new int[10]; \nint[] b = new int[10]; // 使用这种方式的人更多\n```\n\n## 初始化\n\n## 各种类型的默认初始化值\n\n```java\nint[] a = new int[3];\ndouble[] b = new double[3];\nchar[] c = new char[3];\nString[] d = new String[3];\n\nSystem.out.println(Arrays.toString(a)); // [0, 0, 0]\nSystem.out.println(Arrays.toString(b)); // [0.0, 0.0, 0.0]\nSystem.out.println(Arrays.toString(c)); // [, , ]\nSystem.out.println(Arrays.toString(d)); // [null, null, null]\n```\n\n\n\n## 遍历\n\n### for\n\n```java\nfor (int i = 0; i < a.length; i++) {\n    System.out.println(a[i]);\n}\n```\n\n### foreach\n\n```java\nfor (int i : a) {\n    System.out.println(i);\n}\n```\n\n### Arrays.toString\n\n```java\nArrays.toString(a)\n```\n\n\n\n# Arrays\n\n## 常用方法\n\n> static String toString(Object[] a) \n>\n> 将任意类型的数组转为字符串,字符串格式为[x,x,x,x]\n\n---\n\n> static String deepToString(Object[] a)\n>\n> 将多维数组转换为字符串，字符串格式[[x,x,x],[y,y,y]]\n\n---\n\n> static <T> T[] copyOf(T[] original, int newLength)\n>\n> 复制original到一个新的数组，新数组的长度为newLength\n>\n> 如果newLength大于原数组则按照数据类型补充默认数据\n>\n> 如果newLength小于原数组则只取前面newLength个数据\n>\n> 返回创建的新数组\n>\n> 注意：该方法为**浅复制**\n\n---\n\n> static void sort(int[] a)\n>\n> 对数组a进行排序\n\n---\n\n> static int binarySearch(Object[] a, Object key)\n>\n> 在数组a中使用二分查找法来寻找key的下标位置\n>\n> 存在返回下标\n>\n> 不存在返回-1\n\n---\n\n> static void fill(Object[] a, Object val)\n>\n> 使用val将数组a填满\n\n---\n\n> static boolean equals(Object[] a, Object[] a2) \n>\n> 判断a和a2的数量和每个下标的对象是否相同(equals)，相同返回true\n\n---\n\n\n\n\n\n\n\n\n\n\n\n",
    type: "Java",
    tag: [
        "Java基础"
    ],
    hit: NumberLong("4"),
    createDate: ISODate("2022-05-10T12:59:59.086Z"),
    modifyDate: ISODate("2022-05-10T12:59:59.086Z"),
    _class: "com.wyj.blog.pojo.Article",
    comment: [
        {
            _id: ObjectId("627dccaf556eb954b06fa668"),
            nickname: "A",
            email: "A@qq.com",
            commentContent: "A",
            createTime: ISODate("2022-05-13T03:12:47.974Z")
        }
    ]
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627a61e1a9803a69c3d6c82a"),
    title: "Java 输入输出",
    content: "<h1 class=\"markdown-h1\">输出</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>Java想要实现输出是很简单的</p>\n<p>标准输出流System.out位于<code class=\"markdown-linecode\">java.lang.System</code>包中，无须手动引入</p>\n</blockquote>\n<pre><code class=\"language-java\">System.out.println();\n</code></pre>\n<h2 class=\"markdown-h2\">格式化输出</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>Java 中沿用了C语言中的printf函数</p>\n</blockquote>\n<pre><code class=\"language-java\">// 字符串格式化\nSystem.out.printf(&quot;Hello %s&quot;, &quot;Steve&quot;);\nSystem.out.println();\n// 整数格式化\nSystem.out.printf(&quot;score:%d&quot;, 456);\n// 换行符\nSystem.out.printf(&quot;%n&quot;);\n// 浮点数格式化\nSystem.out.printf(&quot;%5.2f&quot;, 156.667);\n</code></pre>\n<p>| 转化符 | 类型             | 示例       |\n| ------ | ---------------- | ---------- |\n| s      | 字符串           | 789        |\n| d      | 十进制整数       | 789        |\n| f      | 定点浮点数       | 15.9       |\n| c      | 字符             | H          |\n| o      | 八进制           | 237        |\n| x      | 十六进制         | 9f         |\n| b      | 布尔             | True       |\n| e      | 指数浮点数       | 159e+01    |\n| g      | 通用浮点数       |            |\n| %      | 百分号           | %          |\n| a      | 十六进制浮点数   | 0x1.fccdp3 |\n| n      | 平台自适应分隔符 |            |\n| h      | 散列码           | 42628b2    |</p>\n<p><img src=\"https://1204938086-img.oss-cn-beijing.aliyuncs.com/imgs/202112211747332.png\" alt=\"image-20211221174729213\" /></p>\n<h1 class=\"markdown-h1\">输入</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>Java想要实现输入，相较于其他语言就要繁琐许多</p>\n</blockquote>\n<h2 class=\"markdown-h2\">Scanner类</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>Scanner类官方给的说明是：一个简单的文本扫描器，可以使用正则表达式解析原始类型和字符串</p>\n<p>Scanner类 位于<code class=\"markdown-linecode\">java.util</code>包下，使用时需要手动导入</p>\n<p>想要使用Scanner类来实现输入，需要配合标准输入流<code class=\"markdown-linecode\">System.in</code>来使用</p>\n</blockquote>\n<pre><code class=\"language-java\">Scanner scanner = new Scanner(System.in);\n// 获取一行\nscanner.nextLine();\n// 获取一个单词，以回车或空格结束\nscanner.next();\n// 获取一个数字，以回车或空格结束\nscanner.nextInt();\n</code></pre>\n<h3 class=\"markdown-h3\">常用方法</h3>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">Scanner(InputStream in)</code></p>\n<p>用给定的输人流创建一个Scanner对象。</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">String nextLine()</code></p>\n<p>读取输入的下一行内容。</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">String next()</code></p>\n<p>读取输入的下一个单词（以空格作为分隔符)。</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">int nextlnt()</code></p>\n<p><code class=\"markdown-linecode\">double nextDouble()</code></p>\n<p>读取并转换下一个表示整数或浮点数的字符序列。</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>boolean hasNext()</p>\n<p>检测输人中是否还有其他单词。</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">boolean hasNextInt()</code></p>\n<p><code class=\"markdown-linecode\">boolean hasNextDouble()</code></p>\n<p>检测是否还有表示整数或浮点数的下一个字符序列。</p>\n</blockquote>\n<h2 class=\"markdown-h2\">Console类</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>Scanner类无法实现在控制台上读取密码</p>\n<p>在JDK6时引入了Console类来解决这一问题</p>\n</blockquote>\n<pre><code class=\"language-java\">Console console = System.console();\n// 读取一行，效果与Scanner类一样\nconsole.readLine();\n// 读取密码，不会在控制台上显示明文\nconsole.readPassword();\n</code></pre>\n<pre><code class=\"language-java\">// 输入账号密码示例\nConsole console = System.console();\nString name = console.readLine();\nString password = new String(console.readPassword());\nSystem.out.println(name);\nSystem.out.println(password);\n</code></pre>\n<h3 class=\"markdown-h3\">常用方法</h3>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">static Console console()</code></p>\n<p>如果有可能进行交互操作，就通过控制台窗口为交互的用户返回一个Console对象，否则返回null。对于任何一个通过控制台窗口启动的程序，都可使用Console对象。否则，其可用性将与所使用的系统有关</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">static char[] readPassword(String prompt,Object ...args)</code></p>\n<p><code class=\"markdown-linecode\">static String readLine(String prompt,Object ...args)</code></p>\n<p>显示字符串prompt并且读取用户输入，直到输入行结束。args参数可以用来提供输人格式。有关这部分内容将在下一节中介绍。</p>\n</blockquote>\n",
    markdown: "# 输出\n\n> Java想要实现输出是很简单的\n>\n> 标准输出流System.out位于`java.lang.System`包中，无须手动引入\n\n```java\nSystem.out.println();\n```\n\n## 格式化输出\n\n> Java 中沿用了C语言中的printf函数\n\n```java\n// 字符串格式化\nSystem.out.printf(\"Hello %s\", \"Steve\");\nSystem.out.println();\n// 整数格式化\nSystem.out.printf(\"score:%d\", 456);\n// 换行符\nSystem.out.printf(\"%n\");\n// 浮点数格式化\nSystem.out.printf(\"%5.2f\", 156.667);\n```\n\n| 转化符 | 类型             | 示例       |\n| ------ | ---------------- | ---------- |\n| s      | 字符串           | 789        |\n| d      | 十进制整数       | 789        |\n| f      | 定点浮点数       | 15.9       |\n| c      | 字符             | H          |\n| o      | 八进制           | 237        |\n| x      | 十六进制         | 9f         |\n| b      | 布尔             | True       |\n| e      | 指数浮点数       | 159e+01    |\n| g      | 通用浮点数       |            |\n| %      | 百分号           | %          |\n| a      | 十六进制浮点数   | 0x1.fccdp3 |\n| n      | 平台自适应分隔符 |            |\n| h      | 散列码           | 42628b2    |\n\n![image-20211221174729213](https://1204938086-img.oss-cn-beijing.aliyuncs.com/imgs/202112211747332.png)\n\n# 输入\n\n> Java想要实现输入，相较于其他语言就要繁琐许多\n\n## Scanner类\n\n> Scanner类官方给的说明是：一个简单的文本扫描器，可以使用正则表达式解析原始类型和字符串\n>\n> Scanner类 位于`java.util`包下，使用时需要手动导入\n>\n> 想要使用Scanner类来实现输入，需要配合标准输入流`System.in`来使用\n\n```java\nScanner scanner = new Scanner(System.in);\n// 获取一行\nscanner.nextLine();\n// 获取一个单词，以回车或空格结束\nscanner.next();\n// 获取一个数字，以回车或空格结束\nscanner.nextInt();\n```\n\n### 常用方法\n\n> `Scanner(InputStream in)`\n>\n> 用给定的输人流创建一个Scanner对象。\n\n---\n\n> `String nextLine()`\n>\n> 读取输入的下一行内容。\n\n---\n\n> `String next()`\n>\n> 读取输入的下一个单词（以空格作为分隔符)。\n\n---\n\n> `int nextlnt()`\n>\n> `double nextDouble()`\n>\n> 读取并转换下一个表示整数或浮点数的字符序列。\n\n---\n\n> boolean hasNext()\n>\n> 检测输人中是否还有其他单词。\n\n---\n\n> `boolean hasNextInt()`\n>\n> `boolean hasNextDouble()`\n>\n> 检测是否还有表示整数或浮点数的下一个字符序列。\n\n## Console类\n\n> Scanner类无法实现在控制台上读取密码\n>\n> 在JDK6时引入了Console类来解决这一问题\n\n```java\nConsole console = System.console();\n// 读取一行，效果与Scanner类一样\nconsole.readLine();\n// 读取密码，不会在控制台上显示明文\nconsole.readPassword();\n```\n\n```java\n// 输入账号密码示例\nConsole console = System.console();\nString name = console.readLine();\nString password = new String(console.readPassword());\nSystem.out.println(name);\nSystem.out.println(password);\n```\n\n### 常用方法\n\n> `static Console console()`\n>\n> 如果有可能进行交互操作，就通过控制台窗口为交互的用户返回一个Console对象，否则返回null。对于任何一个通过控制台窗口启动的程序，都可使用Console对象。否则，其可用性将与所使用的系统有关\n\n---\n\n> `static char[] readPassword(String prompt,Object ...args)`\n>\n> `static String readLine(String prompt,Object ...args)`\n>\n> 显示字符串prompt并且读取用户输入，直到输入行结束。args参数可以用来提供输人格式。有关这部分内容将在下一节中介绍。\n\n",
    type: "Java",
    tag: [
        "Java基础"
    ],
    hit: NumberLong("2"),
    createDate: ISODate("2022-05-10T13:00:17.509Z"),
    modifyDate: ISODate("2022-05-10T13:00:17.509Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627a61f8a9803a69c3d6c82b"),
    title: "Java 基本数据类型",
    content: "<h1 class=\"markdown-h1\">基本数据类型</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>在Java中，共有8种基本类型,其中有4种整型、2种浮点类型、1种用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型 。</p>\n<p>------ 《Java 核心技术卷Ⅰ·原书第10版》</p>\n</blockquote>\n<h1 class=\"markdown-h1\">整数类型</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>Java中没有无符号类型整数</p>\n</blockquote>\n<h2 class=\"markdown-h2\">int</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>Int是Java中最常用的整数类型</p>\n<p>在Java中，整型的范围与运行Java代码的机器无关。这就解决了软件从一个平台移植到另一个平台，或者在同一个平台中的不同操作系统之间进行移植给程序员带来的诸多问题。</p>\n<p>------ 《Java 核心技术卷Ⅰ·原书第10版》</p>\n</blockquote>\n<ul class=\"markdown-list\">\n<li>空间：4字节</li>\n<li>范围：<code class=\"markdown-linecode\">-2147483648</code> ~ <code class=\"markdown-linecode\">2147483647</code>(可以大致记为正负21亿)</li>\n<li>包装类：Integer</li>\n</ul>\n<h2 class=\"markdown-h2\">long</h2>\n<ul class=\"markdown-list\">\n<li>空间：8字节</li>\n<li>范围：<code class=\"markdown-linecode\">-9223372036854775808</code> ~ <code class=\"markdown-linecode\">9223372036854775807</code></li>\n<li>表示方法：<code class=\"markdown-linecode\">123456L</code> 或 <code class=\"markdown-linecode\">123456l</code></li>\n<li>包装类：Long</li>\n</ul>\n<h2 class=\"markdown-h2\">short</h2>\n<ul class=\"markdown-list\">\n<li>空间：2字节</li>\n<li>范围：<code class=\"markdown-linecode\">-32768</code> ~ <code class=\"markdown-linecode\">32767</code> （正负3万2）</li>\n<li>包装类：Short</li>\n</ul>\n<h2 class=\"markdown-h2\">byte</h2>\n<ul class=\"markdown-list\">\n<li>空间：1字节</li>\n<li>范围：<code class=\"markdown-linecode\">-128</code> ~ <code class=\"markdown-linecode\">127</code></li>\n<li>包装类：Byte</li>\n</ul>\n<h2 class=\"markdown-h2\">进制表示</h2>\n<p>| 进制     | 表示方法               |\n| -------- | ---------------------- |\n| 二进制   | <code class=\"markdown-linecode\">0b10101</code> 或 <code class=\"markdown-linecode\">0B10101</code> |\n| 八进制   | <code class=\"markdown-linecode\">0123</code>                 |\n| 十六进制 | <code class=\"markdown-linecode\">0xFFF</code> 或 <code class=\"markdown-linecode\">0XFFF</code>     |\n| 千分位   | <code class=\"markdown-linecode\">1_000_000</code>            |</p>\n<h1 class=\"markdown-h1\">浮点数类型</h1>\n<h2 class=\"markdown-h2\">float</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>在很多情况下，float类型的精度很难满足需求,尽可能使用double类型来进行浮点计算</p>\n</blockquote>\n<ul class=\"markdown-list\">\n<li>\n<p>空间：4字节</p>\n</li>\n<li>\n<p>范围：大约±3.40282347E+38F(有效位数为6~7位）</p>\n</li>\n<li>\n<p>表示方法：<code class=\"markdown-linecode\">12.34f</code> 或 <code class=\"markdown-linecode\">12.34F</code></p>\n</li>\n<li>\n<p>包装类：Float</p>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">double</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>double表示这种类型的数值精度是float类型的两倍（有人称之为双精度数值)。绝大部分应用程序都采用double类型。</p>\n</blockquote>\n<ul class=\"markdown-list\">\n<li>空间：8字节</li>\n<li>范围：大约±1.79769313486231570E+308(有效位数为15位)</li>\n<li>表示方法：<code class=\"markdown-linecode\">12.34</code> 或 <code class=\"markdown-linecode\">12.34d</code> 或 <code class=\"markdown-linecode\">12.34D</code></li>\n<li>包装类：Double</li>\n</ul>\n<h3 class=\"markdown-h3\">误差问题</h3>\n<p>当<code class=\"markdown-linecode\">System.out.println(2-1.1);</code>时，你会得到<code class=\"markdown-linecode\">0.8999999999...</code>，这在金融系统中是不能容忍的，当需要准确无误差的计算浮点数时，需要使用<code class=\"markdown-linecode\">BigDecimal</code></p>\n<h3 class=\"markdown-h3\">常用方法</h3>\n<h4 class=\"markdown-h4\">IsNaN</h4>\n<blockquote class=\"markdown-blockquote\">\n<p>用于判断是否为非数字</p>\n<p>当出现0/0或者复数平方根时会出现NaN</p>\n</blockquote>\n<pre><code class=\"language-java\">Double.isNaN(x / y)\n</code></pre>\n<h1 class=\"markdown-h1\">字符类型 char</h1>\n<ul class=\"markdown-list\">\n<li>包装类：<code class=\"markdown-linecode\">Character</code></li>\n</ul>\n<blockquote class=\"markdown-blockquote\">\n<p>Java 中的char类型表示的是Unicode，可以表示从<code class=\"markdown-linecode\">\\u0000</code> 到 <code class=\"markdown-linecode\">\\uffff</code>的Unicode值</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p><strong>我们强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理</strong></p>\n<p>------ 《Java 核心技术卷Ⅰ·原书第10版》</p>\n</blockquote>\n<h2 class=\"markdown-h2\">Unicode注意事项</h2>\n<p>下面这种操作编译也是能执行成功的，甚至你将所有的代码都替换成Unicode也能编译通过</p>\n<pre><code class=\"language-java\">public static void main(String\\u005B\\u005D args){\n    \n}\n</code></pre>\n<p>下面的代码就需要注意了</p>\n<pre><code class=\"language-java\">// \\u000d System.out.println(&quot;Hello World!&quot;);\n</code></pre>\n<p>上面这行代码中的<code class=\"markdown-linecode\">System.out.println(&quot;Hello World!&quot;);</code>会被执行</p>\n<p>测试时，Vscode会识别该问题并自动修复，IDEA暂时未尝试</p>\n<hr />\n<p>类似问题还有：</p>\n<pre><code class=\"language-java\">//Lookinsidec:\\users\n</code></pre>\n<p>上方代码中的<code class=\"markdown-linecode\">\\u</code>后面没有跟四位数字,所以会报错</p>\n<hr />\n<p>下面的代码执行之后什么都没有输出</p>\n<pre><code class=\"language-java\">String s = &quot;\\u0022 + \\u0022&quot;;\nSystem.out.println(s);\n</code></pre>\n<p>原因在于\\u0022是<code class=\"markdown-linecode\">&quot;</code>，所以原字符串被解析成立<code class=\"markdown-linecode\">&quot;&quot;+&quot;&quot;</code>，是空字符串，所以什么也没有输出</p>\n<h1 class=\"markdown-h1\">布尔类型 boolean</h1>\n<ul class=\"markdown-list\">\n<li>包装类：Boolean</li>\n</ul>\n<p>boolean(布尔）类型有两个值：false和true,用来判定逻辑条件整型值和布尔值之间不能进行相互转换。</p>\n<blockquote class=\"markdown-blockquote\">\n<p>Java 中不能像C和C++中那样使用0来表示false，使用非零数字表示true，只能通过布尔类型表示。</p>\n</blockquote>\n<h1 class=\"markdown-h1\">类型转换</h1>\n<p><img src=\"https://1204938086-img.oss-cn-beijing.aliyuncs.com/imgs/202112101757780.png\" alt=\"image-20211210175737650\" /></p>\n<ul class=\"markdown-list\">\n<li>\n<p>当需要进行精度丢失的类型转换时，需要强制类型转换。</p>\n</li>\n<li>\n<p>boolean类型不要强制类型转换成其他类型，实在需要转换的，使用下面的方法</p>\n<pre><code class=\"language-java\">b?1:0\n</code></pre>\n</li>\n</ul>\n",
    markdown: "# 基本数据类型\n\n> 在Java中，共有8种基本类型,其中有4种整型、2种浮点类型、1种用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型 。\n>\n> ------ 《Java 核心技术卷Ⅰ·原书第10版》\n\n# 整数类型\n\n> Java中没有无符号类型整数\n\n## int\n\n> Int是Java中最常用的整数类型\n>\n> 在Java中，整型的范围与运行Java代码的机器无关。这就解决了软件从一个平台移植到另一个平台，或者在同一个平台中的不同操作系统之间进行移植给程序员带来的诸多问题。\n>\n> ------ 《Java 核心技术卷Ⅰ·原书第10版》\n\n- 空间：4字节\n- 范围：`-2147483648` ~ `2147483647`(可以大致记为正负21亿)\n- 包装类：Integer\n\n## long\n\n- 空间：8字节\n- 范围：`-9223372036854775808` ~ `9223372036854775807`\n- 表示方法：`123456L` 或 `123456l`\n- 包装类：Long\n\n## short\n\n- 空间：2字节\n- 范围：`-32768` ~ `32767` （正负3万2）\n- 包装类：Short\n\n## byte\n\n- 空间：1字节\n- 范围：`-128` ~ `127`\n- 包装类：Byte\n\n## 进制表示\n\n| 进制     | 表示方法               |\n| -------- | ---------------------- |\n| 二进制   | `0b10101` 或 `0B10101` |\n| 八进制   | `0123`                 |\n| 十六进制 | `0xFFF` 或 `0XFFF`     |\n| 千分位   | `1_000_000`            |\n\n# 浮点数类型\n\n## float\n\n> 在很多情况下，float类型的精度很难满足需求,尽可能使用double类型来进行浮点计算\n\n- 空间：4字节\n\n- 范围：大约±3.40282347E+38F(有效位数为6~7位）\n- 表示方法：`12.34f` 或 `12.34F`\n- 包装类：Float\n\n## double\n\n>  double表示这种类型的数值精度是float类型的两倍（有人称之为双精度数值)。绝大部分应用程序都采用double类型。\n\n- 空间：8字节\n- 范围：大约±1.79769313486231570E+308(有效位数为15位)\n- 表示方法：`12.34` 或 `12.34d` 或 `12.34D`\n- 包装类：Double\n\n### 误差问题\n\n当`System.out.println(2-1.1);`时，你会得到`0.8999999999...`，这在金融系统中是不能容忍的，当需要准确无误差的计算浮点数时，需要使用`BigDecimal`\n\n### 常用方法\n\n#### IsNaN\n\n> 用于判断是否为非数字\n>\n> 当出现0/0或者复数平方根时会出现NaN\n\n```java\nDouble.isNaN(x / y)\n```\n\n\n\n# 字符类型 char\n\n- 包装类：`Character`\n\n> Java 中的char类型表示的是Unicode，可以表示从`\\u0000` 到 `\\uffff`的Unicode值\n\n> **我们强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理**\n>\n> ------ 《Java 核心技术卷Ⅰ·原书第10版》\n\n## Unicode注意事项\n\n下面这种操作编译也是能执行成功的，甚至你将所有的代码都替换成Unicode也能编译通过\n\n```java\npublic static void main(String\\u005B\\u005D args){\n    \n}\n```\n\n下面的代码就需要注意了\n\n```java\n// \\u000d System.out.println(\"Hello World!\");\n```\n\n上面这行代码中的`System.out.println(\"Hello World!\");`会被执行\n\n测试时，Vscode会识别该问题并自动修复，IDEA暂时未尝试\n\n---\n\n类似问题还有：\n\n```java\n//Lookinsidec:\\users\n```\n\n上方代码中的`\\u`后面没有跟四位数字,所以会报错\n\n---\n\n下面的代码执行之后什么都没有输出\n\n```java\nString s = \"\\u0022 + \\u0022\";\nSystem.out.println(s);\n```\n\n原因在于\\u0022是`\"`，所以原字符串被解析成立`\"\"+\"\"`，是空字符串，所以什么也没有输出\n\n# 布尔类型 boolean\n\n- 包装类：Boolean\n\nboolean(布尔）类型有两个值：false和true,用来判定逻辑条件整型值和布尔值之间不能进行相互转换。\n\n> Java 中不能像C和C++中那样使用0来表示false，使用非零数字表示true，只能通过布尔类型表示。\n\n\n\n\n\n# 类型转换\n\n![image-20211210175737650](https://1204938086-img.oss-cn-beijing.aliyuncs.com/imgs/202112101757780.png)\n\n\n\n- 当需要进行精度丢失的类型转换时，需要强制类型转换。\n\n- boolean类型不要强制类型转换成其他类型，实在需要转换的，使用下面的方法\n\n  ```java\n  b?1:0\n  ```\n\n  ",
    type: "Java",
    tag: [
        "Java基础"
    ],
    hit: NumberLong("7"),
    createDate: ISODate("2022-05-10T13:00:40.185Z"),
    modifyDate: ISODate("2022-05-10T13:00:40.185Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627b8dc21947aa32e2a4beb4"),
    title: "Python Numpy",
    content: "<h1 class=\"markdown-h1\">安装numpy</h1>\n<pre><code class=\"language-shell\">pip install numpy\n</code></pre>\n<h1 class=\"markdown-h1\">导包</h1>\n<pre><code class=\"language-python\">import numpy as np\n</code></pre>\n<h1 class=\"markdown-h1\">数组</h1>\n<h2 class=\"markdown-h2\">创建</h2>\n<h3 class=\"markdown-h3\">手动创建</h3>\n<ul class=\"markdown-list\">\n<li>\n<p>参数</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-python\">np.array(【数据】,dtype=【数组类型】,order=【行列优先,默认C行优先,F列优先】)\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-python\"># 转换为数组\nprint(np.array([1, 2, 3, 4, 5]))#一维列表转为一维数组\nprint(np.array((1,2,3,4,5)))#元组转数组\nprint(np.array([[1, 2, 3], [4, 5, 6]]))#二维列表转二维数组\n</code></pre>\n<h3 class=\"markdown-h3\">arange</h3>\n<ul class=\"markdown-list\">\n<li>\n<p>参数</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-python\">arange(【结束下标】)\narange(【起始下标】,【结束下标(不包含)】,【步长】)\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>实例</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-python\"># arange创建数组\nprint(np.arange(8))#方法同内置方法range\nprint(np.arange(1, 8, 2))\n</code></pre>\n</li>\n<li>\n<pre><code class=\"language-python\"># 输出\n&gt;&gt;array([0, 1, 2, 3, 4, 5, 6, 7])\n&gt;&gt;array([1, 3, 5, 7])\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 class=\"markdown-h3\">等差数列</h3>\n<ul class=\"markdown-list\">\n<li>\n<p>作用</p>\n<ul class=\"markdown-list\">\n<li>在【起始数值】到【结束数值】之间取任意个数个数值，且每个数值之间的差相同</li>\n</ul>\n</li>\n<li>\n<p>参数</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-python\">linspace(【起始数值】,【结束数值】,【取几个】)\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>实例</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-python\">print(np.linspace(0, 10,3))\n</code></pre>\n</li>\n<li>\n<pre><code class=\"language-python\"># 输出\n&gt;&gt;array([ 0.,  5., 10.])\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 class=\"markdown-h3\">empty</h3>\n<ul class=\"markdown-list\">\n<li>\n<p>作用</p>\n<ul class=\"markdown-list\">\n<li>创建一个未初始化的数组</li>\n</ul>\n</li>\n<li>\n<p>参数</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-python\">np.empty(【形状】,dtype=【数组类型】,order=【行列优先,默认C行优先,F列优先】)\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>实例</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-python\">np.empty((4,4))\n&gt;&gt;&gt; array([[6.23042070e-307, 4.67296746e-307, 1.69121096e-306,\n        1.29061074e-306],\n       [8.34441742e-308, 1.78022342e-306, 6.23058028e-307,\n        9.79107872e-307],\n       [6.89807188e-307, 7.56594375e-307, 6.23060065e-307,\n        1.78021527e-306],\n       [8.34454050e-308, 1.11261027e-306, 1.15706896e-306,\n        1.33512173e-306]])\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 class=\"markdown-h3\">全0全1数组</h3>\n<pre><code class=\"language-python\">np.zeros((2,2))\n&gt;&gt;&gt; array([[0., 0.],\n\t       [0., 0.]])\nnp.ones((2,2))\n&gt;&gt;&gt; array([[1., 1.],\n\t\t   [1., 1.]])\n</code></pre>\n<h3 class=\"markdown-h3\">随机生成</h3>\n<pre><code class=\"language-python\"># 随机生成指定个数0-1(不包含1)之间的浮点数\nnp.random.rand(5)\n# 生成指定形状的数组，值为随机0-1(不包含1)之间的浮点数值\nnp.random.random((2,2))\n# \n</code></pre>\n<h2 class=\"markdown-h2\">数组访问</h2>\n<h3 class=\"markdown-h3\">一维数组</h3>\n<pre><code class=\"language-python\">a = np.array([0, 1, 2, 3, 4])\n\na[0]\n&gt;&gt;&gt; 0\n\na[0:3]\n&gt;&gt;&gt; array([0, 1, 2])\n\na[::-1]\n&gt;&gt;&gt; array([4, 3, 2, 1, 0])\n\n</code></pre>\n<h3 class=\"markdown-h3\">二维数组</h3>\n<pre><code class=\"language-python\">a = np.array([[0, 1, 2],\n              [3, 4, 5],\n              [6, 7, 8]])\n\na[0]\n&gt;&gt;&gt; array([0, 1, 2])\n\na[0:2]\n&gt;&gt;&gt; array([[0, 1, 2],\n           [3, 4, 5]])\n\na[::-1] # 行倒序\n&gt;&gt;&gt; array([[6, 7, 8],\n           [3, 4, 5],\n           [0, 1, 2]])\n\na[::-1,::-1]# 行列倒序\n&gt;&gt;&gt; array([[8, 7, 6],\n           [5, 4, 3],\n           [2, 1, 0]])\na[0,0] # 取行列下标为都0的元素\na[0][0]\n&gt;&gt;&gt; 0\n\na[[0],[0]] # 取行列下标为0的元素\n&gt;&gt;&gt; array([0])\n\na[[0,2],[0,2]] # 取下标为(0,0),(2,2)的元素\n&gt;&gt;&gt; array([[6, 7, 8]])\n\na[[2],:] # 取行下标为2的所有元素\n&gt;&gt;&gt; array([[6, 7, 8]])\n\na.T\n# 转换矩阵\n&gt;&gt;&gt; array([[0, 3, 6],\n           [1, 4, 7],\n           [2, 5, 8]])\n\na.flat\n# 返回一个包含数组中所有对象的迭代器\n&gt;&gt;&gt; &lt;numpy.flatiter at 0x2d061b7a350&gt;\n\na.flatten()\n# 返回一个包含数组中所有对象的列表\n&gt;&gt;&gt; array([0, 1, 2, 3, 4, 5, 6, 7, 8])\n</code></pre>\n<h2 class=\"markdown-h2\">数组类型</h2>\n<pre><code class=\"language-python\">a = np.array([1,2,3],dtype=np.int)\n</code></pre>\n<p>|    类型    |     含义     |\n| :--------: | :----------: |\n|   np.int   | 64位整数类型 |\n|  np.int64  | 64位整数类型 |\n|  np.int32  | 32位整数类型 |\n|  np.int16  | 16位整数类型 |\n|  np.int8   | 8位整数类型  |\n|  np.int0   | 64位整数类型 |\n|  np.float  | 64位浮点类型 |\n| np.float64 | 64位浮点类型 |\n| np.float32 | 32位浮点类型 |\n| np.float16 | 16位浮点类型 |\n| np.float8  | 8位浮点类型  |\n|  np.uint   | 32位无符号数 |\n|  np.uint8  | 8位无符号数  |\n| np.uint16  | 16位无符号数 |\n| np.uint32  | 32位无符号数 |\n| np.uint64  | 64位无符号数 |\n|  np.bool   |   布尔类型   |</p>\n<h2 class=\"markdown-h2\">数组属性</h2>\n<ul class=\"markdown-list\">\n<li>array.ndim  数组维度</li>\n<li>array.shape   数组形状</li>\n<li>array.size  数组个数</li>\n<li>array.dtype 数组类型</li>\n</ul>\n<h2 class=\"markdown-h2\">变换形状</h2>\n<pre><code class=\"language-python\">a = np.arange(12)\n&gt;&gt;&gt; array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\na.reshape((3,4))\n&gt;&gt;&gt; array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11]])\n\n\n</code></pre>\n<h2 class=\"markdown-h2\">数组运算</h2>\n<pre><code class=\"language-python\">a = np.array([1,2,3])\nb = np.array([3,4,5])\n</code></pre>\n<h3 class=\"markdown-h3\">四则运算</h3>\n<ul class=\"markdown-list\">\n<li>形状不同的数组不能进行运算</li>\n<li>运算规则：对应位置进行四则运算\n<ul class=\"markdown-list\">\n<li>以加法为例：下标0与下标0相加，下标1与下标1相加，组成新的数组</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-python\">a + b\n&gt;&gt;&gt; array([4, 6, 8])\na - b\n&gt;&gt;&gt; array([-2, -2, -2])\na * b\n&gt;&gt;&gt; array([ 3,  8, 15])\na / b\n&gt;&gt;&gt; array([0.33333333, 0.5, 0.6])\n\n\n# 不同维度相乘\n# 维度内必须个数相同\na = a = np.array([1,2,3,4])\nc = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]])\na*c\n&gt;&gt;&gt; array([[ 1,  4,  9, 16],\n           [ 5, 12, 21, 32],\n           [ 9, 20, 33, 48]])\n# 将a数组变成和c数组维度相同的数组，各个位置的元素相乘\n# # a：[[1,2,3,4],\n# #    [1,2,3,4],\n# #    [1,2,3,4]]\n</code></pre>\n<h3 class=\"markdown-h3\">幂运算</h3>\n<pre><code class=\"language-python\"># a 中所有元素的平方\na ** 2\n&gt;&gt;&gt; array([1, 4, 9], dtype=int32)\n</code></pre>\n<h3 class=\"markdown-h3\">三角函数运算</h3>\n<pre><code class=\"language-python\"># 对a中的所有元素求sin值\nnp.sin(a)\n&gt;&gt;&gt; array([0.84147098, 0.90929743, 0.14112001])\n# 对a中的所有元素求cos值\nnp.cos(a)\n&gt;&gt;&gt; array([ 0.54030231, -0.41614684, -0.9899925 ])\n# 对a中的所有元素求tan值\nnp.tan(a)\n&gt;&gt;&gt; array([ 1.55740772, -2.18503986, -0.14254654])\n</code></pre>\n<h3 class=\"markdown-h3\">矩阵运算</h3>\n<pre><code class=\"language-python\">a2 = np.array([[1,2],\n               [4,5]])\nb2 = np.array([[7,8],\n               [10,11]])\n</code></pre>\n<pre><code class=\"language-python\"># 注意：必须是行列数相等的矩阵\nnp.dot(a2,b2)\n&gt;&gt;&gt; array([[27, 30],\n           [78, 87]])\na2.dot(b2)\n&gt;&gt;&gt; array([[27, 30],\n           [78, 87]])\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>矩阵点乘</p>\n</blockquote>\n<pre><code class=\"language-python\">[ [1*7+2*10,1*8+2*11],\n  [4*7+5*10,4*8+5*11] ]\n</code></pre>\n<h3 class=\"markdown-h3\">比较运算</h3>\n<pre><code class=\"language-python\">a &lt; 2\n&gt;&gt;&gt; array([ True, False, False])\na == 3\n&gt;&gt;&gt; array([False, False,  True])\n</code></pre>\n<h2 class=\"markdown-h2\">常用方法</h2>\n<h3 class=\"markdown-h3\">sum</h3>\n<pre><code class=\"language-python\"># 求和\na2.sum()\nnp.sum(a2)# 整个数组求和\n\n\n# 行求和，必须为二维及以上数组\n# axis 1横0纵\nnp.sum(a2,axis=0)#行求和 \na2.sum(axis=0)\n&gt;&gt;&gt; array([5, 7])\n\n# 列求和，必须为二维及以上数组\nnp.sum(a2,axis=1)#列求和 # axis 1横0纵\na2.sum(axis=1)\n&gt;&gt;&gt; array([3, 9])\n\n\n</code></pre>\n<h3 class=\"markdown-h3\">max</h3>\n<pre><code class=\"language-python\"># 取最大值\na.max()\nnp.max(a)\n\n# 取最大值下标\na.argmax()\nnp.argmax(a)\n</code></pre>\n<h3 class=\"markdown-h3\">min</h3>\n<pre><code class=\"language-python\"># 求最小值\na.min()\nnp.min(a)\n\n# 取最小值下标\na.argmin()\nnp.argmin(a)\n</code></pre>\n<h3 class=\"markdown-h3\">mean</h3>\n<pre><code class=\"language-python\"># 求平均值\na.mean()\nnp.average(a)\nnp.mean(a)\n\n# 求中位数\nnp.median(a)\n\n</code></pre>\n<h3 class=\"markdown-h3\">cumsum</h3>\n<pre><code class=\"language-python\"># 累加函数\na.cumsum()\nnp.cumsum(a)\n# 结果是一个数组，数组的每一项都是自身与前面所有项相加的和\n&gt;&gt;&gt; array([0.56633041, 1.082195  , 1.91468194, 1.99288879, 2.73631416,\n       3.10854215, 3.16579981, 3.95826817, 4.53986483])\n</code></pre>\n<h3 class=\"markdown-h3\">diff</h3>\n<pre><code class=\"language-python\"># 累减\nnp.diff(a)\n# 结果是一个数组，每一项都是后一项减去当前项的结果\n</code></pre>\n<h3 class=\"markdown-h3\">sort</h3>\n<p>注意：排序是行或者列内的排序，并不是整个数组进行排序</p>\n<pre><code class=\"language-python\">a = np.array([[6, 9, 8],\n              [2, 3, 1],\n              [5, 9, 4]])\n\n# 直接在a数组中进行排序\na.sort()# 行排序\na\n&gt;&gt;&gt; array([[6, 8, 9],\n           [1, 2, 3],\n           [4, 5, 9]])\n\na.sort(axis=0)\na\n&gt;&gt;&gt; array([[2, 3, 1],\n           [5, 9, 4],\n           [6, 9, 8]])\n\n# 不操作原数组，排序后返回新数组\nnp.sort(a) # 行排序\n&gt;&gt; array([[6, 8, 9],\n          [1, 2, 3],\n          [4, 5, 9]])\n\nnp.sort(a,axis=0)# 列排序\n&gt;&gt;&gt; array([[2, 3, 1],\n           [5, 9, 4],\n           [6, 9, 8]])\n\n# 排序返回下标\n# 返回新数组，不对原数组修改\na.argsort()# 行排序\nnp.argsort(a)\n&gt;&gt;&gt; array([[0, 2, 1],\n           [2, 0, 1],\n           [2, 0, 1]], dtype=int64)\n\na.argsort(axis=0)# 列排序\nnp.argsort(a)\n&gt;&gt;&gt; array([[1, 1, 1],\n           [2, 0, 2],\n           [0, 2, 0]], dtype=int64)\n\n</code></pre>\n<h3 class=\"markdown-h3\">nonzero</h3>\n<pre><code class=\"language-python\"># 一维数组\n# 返回非零元素\na = np.array([0,1,2,3,0])\na.nonzero()\nnp.nonzero(a)\n&gt;&gt;&gt; (array([1, 2, 3], dtype=int64),)\n\n\n# 二维数组\n# 返回两个数组，分别是每个非零元素的行下标和列下标\na = np.array([[0,1,2,3,0],\n              [0,1,2,3,0]])\na.nonzero()\nnp.nonzero(a)\n&gt;&gt;&gt; (array([0, 0, 0, 1, 1, 1], dtype=int64),\n     array([1, 2, 3, 1, 2, 3], dtype=int64))\n</code></pre>\n<h3 class=\"markdown-h3\">clip</h3>\n<pre><code class=\"language-python\">a = np.arange(12)\n\na.clip(5,9)\nnp.clip(a,5,9)\n# 小于5的改为5,5-9之间的保留，大于9的改为9\n&gt;&gt;&gt; array([5, 5, 5, 5, 5, 5, 6, 7, 8, 9, 9, 9])\n</code></pre>\n<h3 class=\"markdown-h3\">stack</h3>\n<pre><code class=\"language-python\">a = np.array([1,1,1])\nb = np.array([2,2,2])\n\n# 垂直合并\nnp.vstack((a,b))# 注意参数必须是元组\n&gt;&gt;&gt; array([[1, 1, 1],\n           [2, 2, 2]])\n\n# 水平合并\nnp.hstack((a,b))# 注意参数必须是元组\n&gt;&gt;&gt; array([1, 1, 1, 2, 2, 2])\n</code></pre>\n<h3 class=\"markdown-h3\">newaxis</h3>\n<pre><code class=\"language-python\"># 添加维度\n\na[np.newaxis,:]\n&gt;&gt;&gt; array([[1, 1, 1]])\n\na[:,np.newaxis]\n&gt;&gt;&gt; array([[1],\n           [1],\n           [1]])\n</code></pre>\n<h3 class=\"markdown-h3\">split</h3>\n<pre><code class=\"language-python\"># 对矩阵进行分割\n# 只能等长才拆分，否则报错\na = np.arange(12).reshape((3,4))\nnp.split(a,2,axis=1)# 横向分割\n&gt;&gt;&gt; [array([[0, 1],\n            [4, 5],\n            [8, 9]]),\n\t array([[ 2,  3],\n            [ 6,  7],\n            [10, 11]])]\n\na = np.arange(12).reshape((4,3))\nnp.split(a,2,axis=0)# 纵向分割\n&gt;&gt;&gt; [array([[0, 1, 2],\n            [3, 4, 5]]),\n\t array([[ 6,  7,  8],\n            [ 9, 10, 11]])]\n# 不等长拆分\na = np.arange(12).reshape((3,4))\nnp.array_split(a,2,axis=0)\n&gt;&gt;&gt; [array([[0, 1, 2, 3],\n            [4, 5, 6, 7]]),\n     array([[ 8,  9, 10, 11]])]\n\n# 横向分割\n# 等长分割\na = np.arange(12).reshape((3,4))\nnp.hsplit(a,2)\n&gt;&gt;&gt; [array([[0, 1],\n            [4, 5],\n            [8, 9]]),\n\t array([[ 2,  3],\n            [ 6,  7],\n            [10, 11]])]\n# 纵向分割\n# 等长分割\na = np.arange(12).reshape((3,4))\nnp.vsplit(a,3)\n&gt;&gt;&gt; [array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]\n</code></pre>\n<h2 class=\"markdown-h2\">数组拷贝</h2>\n<pre><code class=\"language-python\"># numpy数组默认赋值是浅拷贝\na = np.array([1,2,3,4])\nb = a\na[0] = 11\na\n&gt;&gt;&gt; array([11,  2,  3,  4])\nb\n&gt;&gt;&gt; array([11,  2,  3,  4])\n\n# 深拷贝\na = np.array([1,2,3,4])\nb = a.copy()\na[0] = 11\na\n&gt;&gt;&gt; array([11,  2,  3,  4])\nb\n&gt;&gt;&gt; array([1,  2,  3,  4])\n</code></pre>\n<h1 class=\"markdown-h1\">数组矩阵</h1>\n<h2 class=\"markdown-h2\">全0矩阵</h2>\n<ul class=\"markdown-list\">\n<li>\n<p>作用</p>\n<ul class=\"markdown-list\">\n<li>创建一个有0.组成的浮点数数组矩阵</li>\n</ul>\n</li>\n<li>\n<p>参数</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-python\">np.zeros(【矩阵大小】)\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>实例</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-python\">np.zeros(3)\nnp.zeros((3,3))\n</code></pre>\n</li>\n<li>\n<pre><code class=\"language-python\">&gt;&gt;&gt; array([0., 0., 0.])\n&gt;&gt;&gt; array([[0., 0., 0.],\n           [0., 0., 0.],\n           [0., 0., 0.]])\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">全1矩阵</h2>\n<ul class=\"markdown-list\">\n<li>\n<p>作用</p>\n<ul class=\"markdown-list\">\n<li>创建一个由1.组成的浮点数数组矩阵</li>\n</ul>\n</li>\n<li>\n<p>参数</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-python\">np.ones(【矩阵大小】)\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>实例</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-python\">np.ones(3)\nnp.ones((3,3))\n</code></pre>\n</li>\n<li>\n<pre><code class=\"language-python\">&gt;&gt;&gt;array([1., 1., 1.])\n&gt;&gt;&gt;array([[1., 1., 1.],\n          [1., 1., 1.],\n          [1., 1., 1.]])\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">对角矩阵</h2>\n<ul class=\"markdown-list\">\n<li>\n<p>作用</p>\n<ul class=\"markdown-list\">\n<li>生成一个对角矩阵，</li>\n</ul>\n</li>\n<li>\n<p>实例</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-python\"># 对角矩阵\nprint(np.diag([1,2,3]))\nprint(np.diag([[1, 2], [4, 5]]))\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">单位矩阵</h2>\n<pre><code class=\"language-python\">np.identity(3)# 生成一个3*3的数组矩阵，这个矩阵是一个单位矩阵\n\nnp.eye(3, 3, k=0) # 生成一个3*3的矩阵,对角线起始位置为下标为0的行\n</code></pre>\n<h1 class=\"markdown-h1\">随机数</h1>\n<h2 class=\"markdown-h2\">rand</h2>\n<ul class=\"markdown-list\">\n<li>只能生成一维数组，不能生成多为数组</li>\n</ul>\n<pre><code class=\"language-python\">np.random.rand()# 生成一个0-1(不包含1)之间的浮点数\n&gt;&gt;&gt; 0.26892871866476986\nnp.random.rand(5)# 随机生产5个0-1(不包含1)之间的浮点数,组成一个数组\n&gt;&gt;&gt; array([0.45022147, 0.66909482, 0.63136124, 0.72245819, 0.47870558])\n</code></pre>\n<h2 class=\"markdown-h2\">random</h2>\n<ul class=\"markdown-list\">\n<li>可以生成矩阵</li>\n</ul>\n<pre><code class=\"language-python\"># 随机数\nnp.random.random()# 生成一个0-1(不包含1)之间的浮点数\n&gt;&gt;&gt; 0.15547611884135792\n\nnp.random.random(5)# 随机生产5个0-1(不包含1)之间的浮点数,组成一个数组\n&gt;&gt;&gt; array([0.99632323, 0.51509429, 0.67734695, 0.69681068, 0.33284558])\n\nnp.random.random((3,3))# 生成一个三行三列的数组，内容为随机生成的0-1(不包含1)之间的浮点数\n&gt;&gt;&gt; array([[0.87322854, 0.36999661, 0.07765183],\n           [0.02444957, 0.27369457, 0.8201719 ],\n           [0.84077081, 0.63784691, 0.60817815]])\n\n\n\n</code></pre>\n<h2 class=\"markdown-h2\">randint</h2>\n<pre><code class=\"language-python\">np.random.randint(1,10,(3,3))# 生成3*3的数组矩阵，其中的每一个元素都是1-10（不包含10）之间的整数\n</code></pre>\n",
    markdown: "# 安装numpy\n\n```shell\npip install numpy\n```\n\n# 导包\n\n```python\nimport numpy as np\n```\n\n# 数组\n\n## 创建\n\n### 手动创建\n\n- 参数\n\n  - ```python\n    np.array(【数据】,dtype=【数组类型】,order=【行列优先,默认C行优先,F列优先】)\n    ```\n\n```python\n# 转换为数组\nprint(np.array([1, 2, 3, 4, 5]))#一维列表转为一维数组\nprint(np.array((1,2,3,4,5)))#元组转数组\nprint(np.array([[1, 2, 3], [4, 5, 6]]))#二维列表转二维数组\n```\n\n### arange\n\n- 参数\n\n  - ```python\n    arange(【结束下标】)\n    arange(【起始下标】,【结束下标(不包含)】,【步长】)\n    ```\n\n- 实例\n\n  - ```python\n    # arange创建数组\n    print(np.arange(8))#方法同内置方法range\n    print(np.arange(1, 8, 2))\n    ```\n\n  - ```python\n    # 输出\n    >>array([0, 1, 2, 3, 4, 5, 6, 7])\n    >>array([1, 3, 5, 7])\n    ```\n\n### 等差数列\n\n- 作用\n\n  - 在【起始数值】到【结束数值】之间取任意个数个数值，且每个数值之间的差相同\n\n- 参数\n\n  - ```python\n    linspace(【起始数值】,【结束数值】,【取几个】)\n    ```\n\n- 实例\n\n  - ```python\n    print(np.linspace(0, 10,3))\n    ```\n\n  - ```python\n    # 输出\n    >>array([ 0.,  5., 10.])\n    ```\n\n### empty\n\n- 作用\n\n  - 创建一个未初始化的数组\n\n- 参数\n\n  - ```python\n    np.empty(【形状】,dtype=【数组类型】,order=【行列优先,默认C行优先,F列优先】)\n    ```\n\n- 实例\n\n  - ```python\n    np.empty((4,4))\n    >>> array([[6.23042070e-307, 4.67296746e-307, 1.69121096e-306,\n            1.29061074e-306],\n           [8.34441742e-308, 1.78022342e-306, 6.23058028e-307,\n            9.79107872e-307],\n           [6.89807188e-307, 7.56594375e-307, 6.23060065e-307,\n            1.78021527e-306],\n           [8.34454050e-308, 1.11261027e-306, 1.15706896e-306,\n            1.33512173e-306]])\n    ```\n\n### 全0全1数组\n\n```python\nnp.zeros((2,2))\n>>> array([[0., 0.],\n\t       [0., 0.]])\nnp.ones((2,2))\n>>> array([[1., 1.],\n\t\t   [1., 1.]])\n```\n\n### 随机生成\n\n```python\n# 随机生成指定个数0-1(不包含1)之间的浮点数\nnp.random.rand(5)\n# 生成指定形状的数组，值为随机0-1(不包含1)之间的浮点数值\nnp.random.random((2,2))\n# \n```\n\n\n\n## 数组访问\n\n### 一维数组\n\n```python\na = np.array([0, 1, 2, 3, 4])\n\na[0]\n>>> 0\n\na[0:3]\n>>> array([0, 1, 2])\n\na[::-1]\n>>> array([4, 3, 2, 1, 0])\n\n```\n\n###  二维数组\n\n```python\na = np.array([[0, 1, 2],\n              [3, 4, 5],\n              [6, 7, 8]])\n\na[0]\n>>> array([0, 1, 2])\n\na[0:2]\n>>> array([[0, 1, 2],\n           [3, 4, 5]])\n\na[::-1] # 行倒序\n>>> array([[6, 7, 8],\n           [3, 4, 5],\n           [0, 1, 2]])\n\na[::-1,::-1]# 行列倒序\n>>> array([[8, 7, 6],\n           [5, 4, 3],\n           [2, 1, 0]])\na[0,0] # 取行列下标为都0的元素\na[0][0]\n>>> 0\n\na[[0],[0]] # 取行列下标为0的元素\n>>> array([0])\n\na[[0,2],[0,2]] # 取下标为(0,0),(2,2)的元素\n>>> array([[6, 7, 8]])\n\na[[2],:] # 取行下标为2的所有元素\n>>> array([[6, 7, 8]])\n\na.T\n# 转换矩阵\n>>> array([[0, 3, 6],\n           [1, 4, 7],\n           [2, 5, 8]])\n\na.flat\n# 返回一个包含数组中所有对象的迭代器\n>>> <numpy.flatiter at 0x2d061b7a350>\n\na.flatten()\n# 返回一个包含数组中所有对象的列表\n>>> array([0, 1, 2, 3, 4, 5, 6, 7, 8])\n```\n\n\n\n## 数组类型\n\n```python\na = np.array([1,2,3],dtype=np.int)\n```\n\n|    类型    |     含义     |\n| :--------: | :----------: |\n|   np.int   | 64位整数类型 |\n|  np.int64  | 64位整数类型 |\n|  np.int32  | 32位整数类型 |\n|  np.int16  | 16位整数类型 |\n|  np.int8   | 8位整数类型  |\n|  np.int0   | 64位整数类型 |\n|  np.float  | 64位浮点类型 |\n| np.float64 | 64位浮点类型 |\n| np.float32 | 32位浮点类型 |\n| np.float16 | 16位浮点类型 |\n| np.float8  | 8位浮点类型  |\n|  np.uint   | 32位无符号数 |\n|  np.uint8  | 8位无符号数  |\n| np.uint16  | 16位无符号数 |\n| np.uint32  | 32位无符号数 |\n| np.uint64  | 64位无符号数 |\n|  np.bool   |   布尔类型   |\n\n\n\n## 数组属性\n\n- array.ndim  数组维度\n- array.shape   数组形状\n- array.size  数组个数\n- array.dtype 数组类型\n\n\n\n## 变换形状\n\n```python\na = np.arange(12)\n>>> array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\na.reshape((3,4))\n>>> array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11]])\n\n\n```\n\n## 数组运算\n\n```python\na = np.array([1,2,3])\nb = np.array([3,4,5])\n```\n\n### 四则运算\n\n- 形状不同的数组不能进行运算\n- 运算规则：对应位置进行四则运算\n  - 以加法为例：下标0与下标0相加，下标1与下标1相加，组成新的数组\n\n```python\na + b\n>>> array([4, 6, 8])\na - b\n>>> array([-2, -2, -2])\na * b\n>>> array([ 3,  8, 15])\na / b\n>>> array([0.33333333, 0.5, 0.6])\n\n\n# 不同维度相乘\n# 维度内必须个数相同\na = a = np.array([1,2,3,4])\nc = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]])\na*c\n>>> array([[ 1,  4,  9, 16],\n           [ 5, 12, 21, 32],\n           [ 9, 20, 33, 48]])\n# 将a数组变成和c数组维度相同的数组，各个位置的元素相乘\n# # a：[[1,2,3,4],\n# #    [1,2,3,4],\n# #    [1,2,3,4]]\n```\n\n### 幂运算\n\n```python\n# a 中所有元素的平方\na ** 2\n>>> array([1, 4, 9], dtype=int32)\n```\n\n### 三角函数运算\n\n```python\n# 对a中的所有元素求sin值\nnp.sin(a)\n>>> array([0.84147098, 0.90929743, 0.14112001])\n# 对a中的所有元素求cos值\nnp.cos(a)\n>>> array([ 0.54030231, -0.41614684, -0.9899925 ])\n# 对a中的所有元素求tan值\nnp.tan(a)\n>>> array([ 1.55740772, -2.18503986, -0.14254654])\n```\n\n### 矩阵运算\n\n```python\na2 = np.array([[1,2],\n               [4,5]])\nb2 = np.array([[7,8],\n               [10,11]])\n```\n\n```python\n# 注意：必须是行列数相等的矩阵\nnp.dot(a2,b2)\n>>> array([[27, 30],\n           [78, 87]])\na2.dot(b2)\n>>> array([[27, 30],\n           [78, 87]])\n```\n\n> 矩阵点乘\n\n```python\n[ [1*7+2*10,1*8+2*11],\n  [4*7+5*10,4*8+5*11] ]\n```\n\n### 比较运算\n\n```python\na < 2\n>>> array([ True, False, False])\na == 3\n>>> array([False, False,  True])\n```\n\n\n\n## 常用方法\n\n### sum\n\n```python\n# 求和\na2.sum()\nnp.sum(a2)# 整个数组求和\n\n\n# 行求和，必须为二维及以上数组\n# axis 1横0纵\nnp.sum(a2,axis=0)#行求和 \na2.sum(axis=0)\n>>> array([5, 7])\n\n# 列求和，必须为二维及以上数组\nnp.sum(a2,axis=1)#列求和 # axis 1横0纵\na2.sum(axis=1)\n>>> array([3, 9])\n\n\n```\n\n### max\n\n```python\n# 取最大值\na.max()\nnp.max(a)\n\n# 取最大值下标\na.argmax()\nnp.argmax(a)\n```\n\n### min\n\n```python\n# 求最小值\na.min()\nnp.min(a)\n\n# 取最小值下标\na.argmin()\nnp.argmin(a)\n```\n\n\n\n### mean\n\n```python\n# 求平均值\na.mean()\nnp.average(a)\nnp.mean(a)\n\n# 求中位数\nnp.median(a)\n\n```\n\n### cumsum\n\n```python\n# 累加函数\na.cumsum()\nnp.cumsum(a)\n# 结果是一个数组，数组的每一项都是自身与前面所有项相加的和\n>>> array([0.56633041, 1.082195  , 1.91468194, 1.99288879, 2.73631416,\n       3.10854215, 3.16579981, 3.95826817, 4.53986483])\n```\n\n### diff\n\n```python\n# 累减\nnp.diff(a)\n# 结果是一个数组，每一项都是后一项减去当前项的结果\n```\n\n### sort\n\n注意：排序是行或者列内的排序，并不是整个数组进行排序\n\n```python\na = np.array([[6, 9, 8],\n              [2, 3, 1],\n              [5, 9, 4]])\n\n# 直接在a数组中进行排序\na.sort()# 行排序\na\n>>> array([[6, 8, 9],\n           [1, 2, 3],\n           [4, 5, 9]])\n\na.sort(axis=0)\na\n>>> array([[2, 3, 1],\n           [5, 9, 4],\n           [6, 9, 8]])\n\n# 不操作原数组，排序后返回新数组\nnp.sort(a) # 行排序\n>> array([[6, 8, 9],\n          [1, 2, 3],\n          [4, 5, 9]])\n\nnp.sort(a,axis=0)# 列排序\n>>> array([[2, 3, 1],\n           [5, 9, 4],\n           [6, 9, 8]])\n\n# 排序返回下标\n# 返回新数组，不对原数组修改\na.argsort()# 行排序\nnp.argsort(a)\n>>> array([[0, 2, 1],\n           [2, 0, 1],\n           [2, 0, 1]], dtype=int64)\n\na.argsort(axis=0)# 列排序\nnp.argsort(a)\n>>> array([[1, 1, 1],\n           [2, 0, 2],\n           [0, 2, 0]], dtype=int64)\n\n```\n\n### nonzero\n\n```python\n# 一维数组\n# 返回非零元素\na = np.array([0,1,2,3,0])\na.nonzero()\nnp.nonzero(a)\n>>> (array([1, 2, 3], dtype=int64),)\n\n\n# 二维数组\n# 返回两个数组，分别是每个非零元素的行下标和列下标\na = np.array([[0,1,2,3,0],\n              [0,1,2,3,0]])\na.nonzero()\nnp.nonzero(a)\n>>> (array([0, 0, 0, 1, 1, 1], dtype=int64),\n     array([1, 2, 3, 1, 2, 3], dtype=int64))\n```\n\n### clip\n\n```python\na = np.arange(12)\n\na.clip(5,9)\nnp.clip(a,5,9)\n# 小于5的改为5,5-9之间的保留，大于9的改为9\n>>> array([5, 5, 5, 5, 5, 5, 6, 7, 8, 9, 9, 9])\n```\n\n\n\n### stack\n\n```python\na = np.array([1,1,1])\nb = np.array([2,2,2])\n\n# 垂直合并\nnp.vstack((a,b))# 注意参数必须是元组\n>>> array([[1, 1, 1],\n           [2, 2, 2]])\n\n# 水平合并\nnp.hstack((a,b))# 注意参数必须是元组\n>>> array([1, 1, 1, 2, 2, 2])\n```\n\n\n\n### newaxis\n\n```python\n# 添加维度\n\na[np.newaxis,:]\n>>> array([[1, 1, 1]])\n\na[:,np.newaxis]\n>>> array([[1],\n           [1],\n           [1]])\n```\n\n### split\n\n```python\n# 对矩阵进行分割\n# 只能等长才拆分，否则报错\na = np.arange(12).reshape((3,4))\nnp.split(a,2,axis=1)# 横向分割\n>>> [array([[0, 1],\n            [4, 5],\n            [8, 9]]),\n\t array([[ 2,  3],\n            [ 6,  7],\n            [10, 11]])]\n\na = np.arange(12).reshape((4,3))\nnp.split(a,2,axis=0)# 纵向分割\n>>> [array([[0, 1, 2],\n            [3, 4, 5]]),\n\t array([[ 6,  7,  8],\n            [ 9, 10, 11]])]\n# 不等长拆分\na = np.arange(12).reshape((3,4))\nnp.array_split(a,2,axis=0)\n>>> [array([[0, 1, 2, 3],\n            [4, 5, 6, 7]]),\n     array([[ 8,  9, 10, 11]])]\n\n# 横向分割\n# 等长分割\na = np.arange(12).reshape((3,4))\nnp.hsplit(a,2)\n>>> [array([[0, 1],\n            [4, 5],\n            [8, 9]]),\n\t array([[ 2,  3],\n            [ 6,  7],\n            [10, 11]])]\n# 纵向分割\n# 等长分割\na = np.arange(12).reshape((3,4))\nnp.vsplit(a,3)\n>>> [array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]\n```\n\n## 数组拷贝\n\n```python\n# numpy数组默认赋值是浅拷贝\na = np.array([1,2,3,4])\nb = a\na[0] = 11\na\n>>> array([11,  2,  3,  4])\nb\n>>> array([11,  2,  3,  4])\n\n# 深拷贝\na = np.array([1,2,3,4])\nb = a.copy()\na[0] = 11\na\n>>> array([11,  2,  3,  4])\nb\n>>> array([1,  2,  3,  4])\n```\n\n\n\n# 数组矩阵\n\n## 全0矩阵\n\n- 作用\n\n  - 创建一个有0.组成的浮点数数组矩阵\n\n- 参数\n\n  - ```python\n    np.zeros(【矩阵大小】)\n    ```\n\n- 实例\n\n  - ```python\n    np.zeros(3)\n    np.zeros((3,3))\n    ```\n\n  - ```python\n    >>> array([0., 0., 0.])\n    >>> array([[0., 0., 0.],\n               [0., 0., 0.],\n               [0., 0., 0.]])\n    ```\n\n\n\n## 全1矩阵\n\n- 作用\n\n  - 创建一个由1.组成的浮点数数组矩阵\n\n- 参数\n\n  - ```python\n    np.ones(【矩阵大小】)\n    ```\n\n- 实例\n\n  - ```python\n    np.ones(3)\n    np.ones((3,3))\n    ```\n\n  - ```python\n    >>>array([1., 1., 1.])\n    >>>array([[1., 1., 1.],\n              [1., 1., 1.],\n              [1., 1., 1.]])\n    ```\n\n## 对角矩阵\n\n- 作用\n\n  - 生成一个对角矩阵，\n\n- 实例\n\n  - ```python\n    # 对角矩阵\n    print(np.diag([1,2,3]))\n    print(np.diag([[1, 2], [4, 5]]))\n    ```\n\n## 单位矩阵\n\n```python\nnp.identity(3)# 生成一个3*3的数组矩阵，这个矩阵是一个单位矩阵\n\nnp.eye(3, 3, k=0) # 生成一个3*3的矩阵,对角线起始位置为下标为0的行\n```\n\n\n\n# 随机数\n\n## rand\n\n- 只能生成一维数组，不能生成多为数组\n\n```python\nnp.random.rand()# 生成一个0-1(不包含1)之间的浮点数\n>>> 0.26892871866476986\nnp.random.rand(5)# 随机生产5个0-1(不包含1)之间的浮点数,组成一个数组\n>>> array([0.45022147, 0.66909482, 0.63136124, 0.72245819, 0.47870558])\n```\n\n\n\n## random\n\n- 可以生成矩阵\n\n```python\n# 随机数\nnp.random.random()# 生成一个0-1(不包含1)之间的浮点数\n>>> 0.15547611884135792\n\nnp.random.random(5)# 随机生产5个0-1(不包含1)之间的浮点数,组成一个数组\n>>> array([0.99632323, 0.51509429, 0.67734695, 0.69681068, 0.33284558])\n\nnp.random.random((3,3))# 生成一个三行三列的数组，内容为随机生成的0-1(不包含1)之间的浮点数\n>>> array([[0.87322854, 0.36999661, 0.07765183],\n           [0.02444957, 0.27369457, 0.8201719 ],\n           [0.84077081, 0.63784691, 0.60817815]])\n\n\n\n```\n\n## randint\n\n```python\nnp.random.randint(1,10,(3,3))# 生成3*3的数组矩阵，其中的每一个元素都是1-10（不包含10）之间的整数\n```\n\n\n\n\n\n\n\n",
    type: "Python",
    tag: [
        "Python模块"
    ],
    hit: NumberLong("3"),
    createDate: ISODate("2022-05-11T10:19:46.284Z"),
    modifyDate: ISODate("2022-05-11T10:19:46.284Z"),
    _class: "com.wyj.blog.pojo.Article",
    comment: [
        {
            _id: ObjectId("627dccc6556eb954b06fa669"),
            nickname: "A",
            email: "A@qq.com",
            commentContent: "A",
            createTime: ISODate("2022-05-13T03:13:10.964Z")
        }
    ]
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627b8e931947aa32e2a4beb6"),
    title: "Python Pandas",
    content: "<h1 class=\"markdown-h1\">创建Series</h1>\n<pre><code class=\"language-python\"># 带索引的数据\npd.Series([1,2,3,4,np.nan])\n&gt;&gt;&gt; \n0    1.0\n1    2.0\n2    3.0\n3    4.0\n4    NaN\ndtype: float64\n</code></pre>\n<h1 class=\"markdown-h1\">创建DataFrame</h1>\n<pre><code class=\"language-python\"># 数据表\n# 默认行列标题为从0开始的数字表示\npd.DataFrame(np.arange(12).reshape((3,4)))\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102155230905.png\" alt=\"image-20201102155230905\" /></p>\n<pre><code class=\"language-python\"># 数据表\npd.DataFrame(np.random.randn(6,4),index=np.arange(1,7),columns=np.array([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]))\n# 参数1：数据\n# index:左侧行标题\n# columns：顶部列标题\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102155343553.png\" alt=\"image-20201102155343553\" /></p>\n<h1 class=\"markdown-h1\">DataFrame 属性</h1>\n<pre><code class=\"language-python\">datas = pd.DataFrame({&quot;A&quot;:1.,\n              &quot;B&quot;:pd.Timestamp(&quot;20201102&quot;),\n              &quot;C&quot;:np.array([1,2,3,4])\n             })\n\n# 显示每列的数据类型\ndatas.dtypes\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102155409859.png\" alt=\"image-20201102155409859\" /></p>\n<pre><code class=\"language-python\"># 输出行标题\ndatas.index\n&gt;&gt;&gt; RangeIndex(start=0, stop=4, step=1)\n</code></pre>\n<pre><code class=\"language-python\"># 输出列标题\ndatas.columns\n&gt;&gt;&gt; Index(['A', 'B', 'C'], dtype='object')\n</code></pre>\n<h1 class=\"markdown-h1\">查找数据</h1>\n<h2 class=\"markdown-h2\">按行输出</h2>\n<pre><code class=\"language-python\"># 按照行，输出数据\ndatas.values\n&gt;&gt;&gt; array([[1.0, Timestamp('2020-11-02 00:00:00'), 1],\n           [1.0, Timestamp('2020-11-02 00:00:00'), 2],\n           [1.0, Timestamp('2020-11-02 00:00:00'), 3],\n           [1.0, Timestamp('2020-11-02 00:00:00'), 4]], dtype=object)\n</code></pre>\n<h2 class=\"markdown-h2\">数据转置</h2>\n<pre><code class=\"language-python\"># 矩阵转置\n# 行列转换\n\ndatas.T\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102155806000.png\" alt=\"image-20201102155806000\" /></p>\n<h2 class=\"markdown-h2\">数据选择</h2>\n<h3 class=\"markdown-h3\">按行选择</h3>\n<pre><code class=\"language-python\"># 选择A列\ndatas.A\n&gt;&gt;&gt; \n0    1.0\n1    1.0\n2    1.0\n3    1.0\nName: A, dtype: float64\n        \n# 选择A列\ndatas[&quot;A&quot;]\n&gt;&gt;&gt;\n0    1.0\n1    1.0\n2    1.0\n3    1.0\nName: A, dtype: float64\n</code></pre>\n<h2 class=\"markdown-h2\">切片</h2>\n<pre><code class=\"language-python\">datas = pd.DataFrame(np.random.randn(6,4),index=np.array(['1', '2', '3', '4', '5', '6']),columns=np.array([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]))\n# 列下标选择列\ndatas[0:3]\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102162010650.png\" alt=\"image-20201102162010650\" /></p>\n<h2 class=\"markdown-h2\">loc</h2>\n<pre><code class=\"language-python\"># 标题取值\n# loc只能使用标题值，不能使用下标\ndatas.loc[&quot;1&quot;]\n&gt;&gt;&gt;\na   -1.239144\nb   -1.459701\nc    1.104956\nd    1.941115\nName: 1, dtype: float64\n</code></pre>\n<pre><code class=\"language-python\"># 行列同时选取\ndatas.loc[[&quot;1&quot;,&quot;3&quot;],[&quot;a&quot;,&quot;c&quot;]]# 第1、3行，第a、c列的数据\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102162156168.png\" alt=\"image-20201102162156168\" /></p>\n<pre><code class=\"language-python\"># 第1行的所有数据\ndatas.loc[&quot;1&quot;,:]\n&gt;&gt;&gt;\na    0.163850\nb   -1.042624\nc    0.574844\nd   -0.051947\nName: 1, dtype: float64\n</code></pre>\n<pre><code class=\"language-python\"># 数值\n# 行标题，列标题\ndatas.loc[&quot;1&quot;,&quot;a&quot;]\n&gt;&gt;&gt;\n0.1638497479327632\n</code></pre>\n<h2 class=\"markdown-h2\">iloc</h2>\n<pre><code class=\"language-python\"># 取行\ndatas.iloc[0]\n&gt;&gt;&gt;\na   -1.239144\nb   -1.459701\nc    1.104956\nd    1.941115\nName: 1, dtype: float64\n</code></pre>\n<pre><code class=\"language-python\"># 下标取值\ndatas.iloc[0,3]# 1行4列\n&gt;&gt;&gt;\n-0.33845562939301094\n</code></pre>\n<pre><code class=\"language-python\">datas.iloc[1:3,2:4]# 切片操作\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102162527200.png\" alt=\"image-20201102162527200\" /></p>\n<pre><code class=\"language-python\">datas.iloc[[1,3],[2,3]]# 单独选择\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102162552817.png\" alt=\"image-20201102162552817\" /></p>\n<h2 class=\"markdown-h2\">条件选取</h2>\n<pre><code class=\"language-python\"># 条件选取\ndatas[datas.a &gt; 0.5]\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102162720696.png\" alt=\"image-20201102162720696\" /></p>\n<h1 class=\"markdown-h1\">数据处理</h1>\n<h2 class=\"markdown-h2\">排序</h2>\n<pre><code class=\"language-python\"># 按照标题进行排序\n# axis：1 横(列排序)，0纵（行排序）\n# ascending：是否升序\ndatas.sort_index(axis=1,ascending=False)\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102155929163.png\" alt=\"image-20201102155929163\" /></p>\n<pre><code class=\"language-python\"># 按照值排序\n# by:根据哪个列进行排序\n# ascending：是否升序\ndatas.sort_values(by=&quot;C&quot;,ascending=False)\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102160320560.png\" alt=\"image-20201102160320560\" /></p>\n<h2 class=\"markdown-h2\">数据概览</h2>\n<pre><code class=\"language-python\"># 描述数据\n# 包括个数、平均值、方差、最大值、最小值等等\ndatas.describe()\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102155741897.png\" alt=\"image-20201102155741897\" /></p>\n<h2 class=\"markdown-h2\">修改</h2>\n<pre><code class=\"language-python\"># 利用查找数据的方法查找到数据后进行修改\n</code></pre>\n<pre><code class=\"language-python\"># 条件修改\n\ndatas[datas.a &gt; 1] = 1 # a大于1的整行都修改为1\ndatas\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102163207274.png\" alt=\"image-20201102163207274\" /></p>\n<pre><code class=\"language-python\"># a大于1的 a这一列为1\ndatas.a[datas.a &gt; 1] = 1\ndatas\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102163217777.png\" alt=\"image-20201102163217777\" /></p>\n<h2 class=\"markdown-h2\">添加</h2>\n<pre><code class=\"language-python\"># 添加一列空数据\ndatas[&quot;e&quot;] = np.nan\ndatas\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102163422017.png\" alt=\"image-20201102163422017\" /></p>\n<pre><code class=\"language-python\"># 添加指定数据，行标题必须相同\ndatas[&quot;f&quot;] = pd.Series([1,2,3,4,5,6],index=np.array(['1', '2', '3', '4', '5', '6']))\ndatas\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102163447482.png\" alt=\"image-20201102163447482\" /></p>\n<pre><code class=\"language-python\"># 必须指定行标题，否则插入值为NaN\ndatas[&quot;g&quot;] = pd.Series([1,2,3,4,5,6])\ndatas\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102163522017.png\" alt=\"image-20201102163522017\" /></p>\n<h2 class=\"markdown-h2\">脏数据处理</h2>\n<pre><code class=\"language-python\"># 模拟脏数据\ndatas = pd.DataFrame(np.random.randn(6,4),index=np.array(['1', '2', '3', '4', '5', '6']),columns=np.array([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]))\ndatas.iloc[2,2] = np.nan\ndatas.iloc[3,1] = np.nan\ndatas\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102163607962.png\" alt=\"image-20201102163607962\" /></p>\n<h3 class=\"markdown-h3\">检查脏数据</h3>\n<pre><code class=\"language-python\"># 检查是否有脏数据\ndatas.isnull() # 是datas.isna()的别名  两者功能相同\n# 返回的是一个dataframe对象\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102163655091.png\" alt=\"image-20201102163655091\" /></p>\n<pre><code class=\"language-python\"># 当dataframe很大的时候，可以使用如下方法检测是否有脏数据\nnp.all(datas.isnull()) == True# 为True说明没有脏数据，False说明有脏数据\n&gt;&gt;&gt; False\n</code></pre>\n<h3 class=\"markdown-h3\">删除脏数据</h3>\n<pre><code class=\"language-python\"># 处理脏数据，清理值为空的数据\n# 注意：返回新数据，没有对原数据进行修改\n\n# 删除有空数据的行\ndatas.dropna(axis=0,how='any')\n# axis 1:列  0:行\n# how  any:有一个空就删除  all：全为空就删除\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102164036888.png\" alt=\"image-20201102164036888\" /></p>\n<h3 class=\"markdown-h3\">填充为指定值</h3>\n<pre><code class=\"language-python\"># 处理脏数据，将空值填入默认的值\ndatas.fillna(value=1)# 将所有为空的值设置为1\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102164101786.png\" alt=\"image-20201102164101786\" /></p>\n<h2 class=\"markdown-h2\">数据合并</h2>\n<h3 class=\"markdown-h3\">concat</h3>\n<h4 class=\"markdown-h4\">行列数据不冲突</h4>\n<pre><code class=\"language-python\"># 合并测试数据\n# 数据行列标题相同\nd1 = pd.DataFrame(np.ones((3,4))*0,columns=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;])\nd2 = pd.DataFrame(np.ones((3,4))*1,columns=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;])\nd3 = pd.DataFrame(np.ones((3,4))*2,columns=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;])\n</code></pre>\n<pre><code class=\"language-python\"># 数据合并\n# 注意：生成新的数据表，并不修改原数据\npd.concat([d1,d2,d3],axis=0)\n# axis ： 1横0纵\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102164202267.png\" alt=\"image-20201102164202267\" /></p>\n<pre><code class=\"language-python\"># 下标重新排序\npd.concat([d1,d2,d3],axis=0,ignore_index=True)\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102164224385.png\" alt=\"image-20201102164224385\" /></p>\n<h4 class=\"markdown-h4\">行列数据冲突</h4>\n<pre><code class=\"language-python\"># 合并测试数据\n# 行列标题不重合\nd1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;])\nd2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;])\n</code></pre>\n<pre><code class=\"language-python\"># 直接合并，多与填充空数据\n# 也就相当于join=&quot;outer&quot;\npd.concat([d1,d2])\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102164443737.png\" alt=\"image-20201102164443737\" /></p>\n<pre><code class=\"language-python\"># 只保留相同的，去除不同列\npd.concat([d1,d2],join=&quot;inner&quot;)\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102164508474.png\" alt=\"image-20201102164508474\" /></p>\n<pre><code class=\"language-python\"># 处理行标题\npd.concat([d1,d2],join=&quot;inner&quot;,ignore_index=True)\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102164541434.png\" alt=\"image-20201102164541434\" /></p>\n<pre><code class=\"language-python\"># 横向合并\n# 保留所有行列，多余填充NaN\npd.concat([d1,d2],axis=1)\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102164607960.png\" alt=\"image-20201102164607960\" /></p>\n<h3 class=\"markdown-h3\">append</h3>\n<pre><code class=\"language-python\"># 添加\n# 注意：生成新的数据表，不会对原数据进行修改\n\n# 添加一个数组\nd1.append(d2,ignore_index=True)\n# 可以同时添加多个数据表，使用列表包括即可\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102164714809.png\" alt=\"image-20201102164714809\" /></p>\n<pre><code class=\"language-python\"># 添加一行\n# 必须标明列名，否则会创建数字列名，并添加输入的数据到最后一行\nd1.append(pd.Series([1,2,3,4],index=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]),ignore_index=True)\n</code></pre>\n<p><img src=\"Python%20pandas.assets/image-20201102164741417.png\" alt=\"image-20201102164741417\" /></p>\n<h3 class=\"markdown-h3\">merge</h3>\n<pre><code class=\"language-python\">d1 = pd.DataFrame({&quot;key&quot;:[&quot;k0&quot;,&quot;k1&quot;,&quot;k2&quot;],\n                   &quot;A&quot;:[&quot;A0&quot;,&quot;A1&quot;,&quot;A2&quot;],\n                   &quot;B&quot;:[&quot;B0&quot;,&quot;B1&quot;,&quot;B2&quot;]\n                  })\nd2 = pd.DataFrame({&quot;key&quot;:[&quot;k0&quot;,&quot;k1&quot;,&quot;k2&quot;,&quot;k3&quot;],\n                   &quot;C&quot;:[&quot;C0&quot;,&quot;C1&quot;,&quot;C2&quot;,&quot;C3&quot;],\n                   &quot;D&quot;:[&quot;D0&quot;,&quot;D1&quot;,&quot;D2&quot;,&quot;D3&quot;]\n                  })\n</code></pre>\n<h4 class=\"markdown-h4\">根据列合并</h4>\n<pre><code class=\"language-python\">pd.merge(d1,d2,on=&quot;key&quot;,how=&quot;inner&quot;)\n# on:合并关键字，根据他来确定要合并哪些数据,多个字段用列表传入\n# how：\n    #inner：保留相同，默认\n    #outer：全部保留\n    #left： 根据左边的数据表保存数据\n    #right: 根据右边的数据表保留数据\n</code></pre>\n<h4 class=\"markdown-h4\">根据行合并</h4>\n<pre><code class=\"language-python\">pd.merge(d1,d2,left_index=True,right_index=True)\n# left_index: \n    #True: 合并时考虑左侧数据表的行标题\n    #False：合并时不考虑左侧数据表的行标题\n# right_index:\n    #True：合并时考虑右侧数据表的行标题\n    #False：合并时不考虑右侧数据表的行标题\n</code></pre>\n<h4 class=\"markdown-h4\">显示合并状态</h4>\n<pre><code class=\"language-python\">pd.merge(d1,d2,on=&quot;key&quot;,how=&quot;right&quot;,indicator=True)\n# indicator: 新建一列用来显示合并数据在两个表中的状态\n    #True： 显示状态\n    #False： 不显示状态，默认\n    #指定名称: 显示状态，并且按照指定的名字命名新建的列\n</code></pre>\n<h4 class=\"markdown-h4\">同名列处理</h4>\n<pre><code class=\"language-python\">grils = pd.DataFrame({&quot;K&quot;:[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;],\n                     &quot;age&quot;:[1,2,3]\n                     })\nboys = pd.DataFrame({&quot;K&quot;:list(&quot;ACD&quot;),\n                    &quot;age&quot;:[4,5,6]})\n\n\npd.merge(grils,boys,on=&quot;K&quot;,suffixes=[&quot;_grils&quot;,&quot;_boys&quot;],how=&quot;outer&quot;)\n#suffixes:当两组数据列名相同但实际表示含义不同时，使用它来区分\n</code></pre>\n<h1 class=\"markdown-h1\">数据存取</h1>\n<p>| 文件格式 |     读取      |      存储      |\n| :------: | :-----------: | :------------: |\n|   csv    | pd.read_csv() | datas.to_csv() |\n|  excel   | pd.read_excel | datas.to_excel |\n|   json   | pd.read_json  | datas.to_json  |\n|   sql    |  pd.read_sql  |  datas.to_sql  |\n|   ...    |               |                |</p>\n<pre><code class=\"language-python\"># 读取csv数据\ndatas = pd.read_csv(&quot;Income.csv&quot;)\n# 保存成pickle\ndatas.to_pickle(&quot;Income.pickle&quot;)\n</code></pre>\n<h1 class=\"markdown-h1\">axis</h1>\n<p><img src=\"Python%20pandas.assets/axis.png\" alt=\"img\" /></p>\n",
    markdown: "# 创建Series\n\n```python\n# 带索引的数据\npd.Series([1,2,3,4,np.nan])\n>>> \n0    1.0\n1    2.0\n2    3.0\n3    4.0\n4    NaN\ndtype: float64\n```\n\n# 创建DataFrame\n\n```python\n# 数据表\n# 默认行列标题为从0开始的数字表示\npd.DataFrame(np.arange(12).reshape((3,4)))\n```\n\n![image-20201102155230905](Python%20pandas.assets/image-20201102155230905.png)\n\n```python\n# 数据表\npd.DataFrame(np.random.randn(6,4),index=np.arange(1,7),columns=np.array([\"a\",\"b\",\"c\",\"d\"]))\n# 参数1：数据\n# index:左侧行标题\n# columns：顶部列标题\n```\n\n![image-20201102155343553](Python%20pandas.assets/image-20201102155343553.png)\n\n# DataFrame 属性\n\n\n\n```python\ndatas = pd.DataFrame({\"A\":1.,\n              \"B\":pd.Timestamp(\"20201102\"),\n              \"C\":np.array([1,2,3,4])\n             })\n\n# 显示每列的数据类型\ndatas.dtypes\n```\n\n![image-20201102155409859](Python%20pandas.assets/image-20201102155409859.png)\n\n```python\n# 输出行标题\ndatas.index\n>>> RangeIndex(start=0, stop=4, step=1)\n```\n\n```python\n# 输出列标题\ndatas.columns\n>>> Index(['A', 'B', 'C'], dtype='object')\n```\n\n# 查找数据\n\n## 按行输出\n\n```python\n# 按照行，输出数据\ndatas.values\n>>> array([[1.0, Timestamp('2020-11-02 00:00:00'), 1],\n           [1.0, Timestamp('2020-11-02 00:00:00'), 2],\n           [1.0, Timestamp('2020-11-02 00:00:00'), 3],\n           [1.0, Timestamp('2020-11-02 00:00:00'), 4]], dtype=object)\n```\n\n## 数据转置\n\n```python\n# 矩阵转置\n# 行列转换\n\ndatas.T\n```\n\n![image-20201102155806000](Python%20pandas.assets/image-20201102155806000.png)\n\n## 数据选择\n\n### 按行选择\n\n```python\n# 选择A列\ndatas.A\n>>> \n0    1.0\n1    1.0\n2    1.0\n3    1.0\nName: A, dtype: float64\n        \n# 选择A列\ndatas[\"A\"]\n>>>\n0    1.0\n1    1.0\n2    1.0\n3    1.0\nName: A, dtype: float64\n```\n\n## 切片\n\n```python\ndatas = pd.DataFrame(np.random.randn(6,4),index=np.array(['1', '2', '3', '4', '5', '6']),columns=np.array([\"a\",\"b\",\"c\",\"d\"]))\n# 列下标选择列\ndatas[0:3]\n```\n\n![image-20201102162010650](Python%20pandas.assets/image-20201102162010650.png)\n\n## loc\n\n```python\n# 标题取值\n# loc只能使用标题值，不能使用下标\ndatas.loc[\"1\"]\n>>>\na   -1.239144\nb   -1.459701\nc    1.104956\nd    1.941115\nName: 1, dtype: float64\n```\n\n```python\n# 行列同时选取\ndatas.loc[[\"1\",\"3\"],[\"a\",\"c\"]]# 第1、3行，第a、c列的数据\n```\n\n![image-20201102162156168](Python%20pandas.assets/image-20201102162156168.png)\n\n```python\n# 第1行的所有数据\ndatas.loc[\"1\",:]\n>>>\na    0.163850\nb   -1.042624\nc    0.574844\nd   -0.051947\nName: 1, dtype: float64\n```\n\n```python\n# 数值\n# 行标题，列标题\ndatas.loc[\"1\",\"a\"]\n>>>\n0.1638497479327632\n```\n\n## iloc\n\n```python\n# 取行\ndatas.iloc[0]\n>>>\na   -1.239144\nb   -1.459701\nc    1.104956\nd    1.941115\nName: 1, dtype: float64\n```\n\n```python\n# 下标取值\ndatas.iloc[0,3]# 1行4列\n>>>\n-0.33845562939301094\n```\n\n```python\ndatas.iloc[1:3,2:4]# 切片操作\n```\n\n![image-20201102162527200](Python%20pandas.assets/image-20201102162527200.png)\n\n```python\ndatas.iloc[[1,3],[2,3]]# 单独选择\n```\n\n![image-20201102162552817](Python%20pandas.assets/image-20201102162552817.png)\n\n## 条件选取\n\n```python\n# 条件选取\ndatas[datas.a > 0.5]\n```\n\n![image-20201102162720696](Python%20pandas.assets/image-20201102162720696.png)\n\n\n\n# 数据处理\n\n## 排序\n\n```python\n# 按照标题进行排序\n# axis：1 横(列排序)，0纵（行排序）\n# ascending：是否升序\ndatas.sort_index(axis=1,ascending=False)\n```\n\n![image-20201102155929163](Python%20pandas.assets/image-20201102155929163.png)\n\n\n\n```python\n# 按照值排序\n# by:根据哪个列进行排序\n# ascending：是否升序\ndatas.sort_values(by=\"C\",ascending=False)\n```\n\n![image-20201102160320560](Python%20pandas.assets/image-20201102160320560.png)\n\n## 数据概览\n\n\n\n```python\n# 描述数据\n# 包括个数、平均值、方差、最大值、最小值等等\ndatas.describe()\n```\n\n![image-20201102155741897](Python%20pandas.assets/image-20201102155741897.png)\n\n## 修改\n\n```python\n# 利用查找数据的方法查找到数据后进行修改\n```\n\n\n\n```python\n# 条件修改\n\ndatas[datas.a > 1] = 1 # a大于1的整行都修改为1\ndatas\n```\n\n![image-20201102163207274](Python%20pandas.assets/image-20201102163207274.png)\n\n```python\n# a大于1的 a这一列为1\ndatas.a[datas.a > 1] = 1\ndatas\n```\n\n![image-20201102163217777](Python%20pandas.assets/image-20201102163217777.png)\n\n## 添加\n\n```python\n# 添加一列空数据\ndatas[\"e\"] = np.nan\ndatas\n```\n\n![image-20201102163422017](Python%20pandas.assets/image-20201102163422017.png)\n\n```python\n# 添加指定数据，行标题必须相同\ndatas[\"f\"] = pd.Series([1,2,3,4,5,6],index=np.array(['1', '2', '3', '4', '5', '6']))\ndatas\n```\n\n![image-20201102163447482](Python%20pandas.assets/image-20201102163447482.png)\n\n```python\n# 必须指定行标题，否则插入值为NaN\ndatas[\"g\"] = pd.Series([1,2,3,4,5,6])\ndatas\n```\n\n![image-20201102163522017](Python%20pandas.assets/image-20201102163522017.png)\n\n## 脏数据处理\n\n```python\n# 模拟脏数据\ndatas = pd.DataFrame(np.random.randn(6,4),index=np.array(['1', '2', '3', '4', '5', '6']),columns=np.array([\"a\",\"b\",\"c\",\"d\"]))\ndatas.iloc[2,2] = np.nan\ndatas.iloc[3,1] = np.nan\ndatas\n```\n\n![image-20201102163607962](Python%20pandas.assets/image-20201102163607962.png)\n\n### 检查脏数据\n\n```python\n# 检查是否有脏数据\ndatas.isnull() # 是datas.isna()的别名  两者功能相同\n# 返回的是一个dataframe对象\n```\n\n![image-20201102163655091](Python%20pandas.assets/image-20201102163655091.png)\n\n```python\n# 当dataframe很大的时候，可以使用如下方法检测是否有脏数据\nnp.all(datas.isnull()) == True# 为True说明没有脏数据，False说明有脏数据\n>>> False\n```\n\n### 删除脏数据\n\n```python\n# 处理脏数据，清理值为空的数据\n# 注意：返回新数据，没有对原数据进行修改\n\n# 删除有空数据的行\ndatas.dropna(axis=0,how='any')\n# axis 1:列  0:行\n# how  any:有一个空就删除  all：全为空就删除\n```\n\n![image-20201102164036888](Python%20pandas.assets/image-20201102164036888.png)\n\n### 填充为指定值\n\n```python\n# 处理脏数据，将空值填入默认的值\ndatas.fillna(value=1)# 将所有为空的值设置为1\n```\n\n![image-20201102164101786](Python%20pandas.assets/image-20201102164101786.png)\n\n\n\n## 数据合并\n\n### concat\n\n#### 行列数据不冲突\n\n```python\n# 合并测试数据\n# 数据行列标题相同\nd1 = pd.DataFrame(np.ones((3,4))*0,columns=[\"a\",\"b\",\"c\",\"d\"])\nd2 = pd.DataFrame(np.ones((3,4))*1,columns=[\"a\",\"b\",\"c\",\"d\"])\nd3 = pd.DataFrame(np.ones((3,4))*2,columns=[\"a\",\"b\",\"c\",\"d\"])\n```\n\n```python\n# 数据合并\n# 注意：生成新的数据表，并不修改原数据\npd.concat([d1,d2,d3],axis=0)\n# axis ： 1横0纵\n```\n\n![image-20201102164202267](Python%20pandas.assets/image-20201102164202267.png)\n\n```python\n# 下标重新排序\npd.concat([d1,d2,d3],axis=0,ignore_index=True)\n```\n\n![image-20201102164224385](Python%20pandas.assets/image-20201102164224385.png)\n\n#### 行列数据冲突\n\n```python\n# 合并测试数据\n# 行列标题不重合\nd1 = pd.DataFrame(np.ones((3,4))*0,index=[1,2,3],columns=[\"a\",\"b\",\"c\",\"d\"])\nd2 = pd.DataFrame(np.ones((3,4))*1,index=[2,3,4],columns=[\"b\",\"c\",\"d\",\"e\"])\n```\n\n```python\n# 直接合并，多与填充空数据\n# 也就相当于join=\"outer\"\npd.concat([d1,d2])\n```\n\n![image-20201102164443737](Python%20pandas.assets/image-20201102164443737.png)\n\n```python\n# 只保留相同的，去除不同列\npd.concat([d1,d2],join=\"inner\")\n```\n\n![image-20201102164508474](Python%20pandas.assets/image-20201102164508474.png)\n\n```python\n# 处理行标题\npd.concat([d1,d2],join=\"inner\",ignore_index=True)\n```\n\n![image-20201102164541434](Python%20pandas.assets/image-20201102164541434.png)\n\n```python\n# 横向合并\n# 保留所有行列，多余填充NaN\npd.concat([d1,d2],axis=1)\n```\n\n![image-20201102164607960](Python%20pandas.assets/image-20201102164607960.png)\n\n### append\n\n```python\n# 添加\n# 注意：生成新的数据表，不会对原数据进行修改\n\n# 添加一个数组\nd1.append(d2,ignore_index=True)\n# 可以同时添加多个数据表，使用列表包括即可\n```\n\n![image-20201102164714809](Python%20pandas.assets/image-20201102164714809.png)\n\n```python\n# 添加一行\n# 必须标明列名，否则会创建数字列名，并添加输入的数据到最后一行\nd1.append(pd.Series([1,2,3,4],index=[\"a\",\"b\",\"c\",\"d\"]),ignore_index=True)\n```\n\n![image-20201102164741417](Python%20pandas.assets/image-20201102164741417.png)\n\n### merge\n\n```python\nd1 = pd.DataFrame({\"key\":[\"k0\",\"k1\",\"k2\"],\n                   \"A\":[\"A0\",\"A1\",\"A2\"],\n                   \"B\":[\"B0\",\"B1\",\"B2\"]\n                  })\nd2 = pd.DataFrame({\"key\":[\"k0\",\"k1\",\"k2\",\"k3\"],\n                   \"C\":[\"C0\",\"C1\",\"C2\",\"C3\"],\n                   \"D\":[\"D0\",\"D1\",\"D2\",\"D3\"]\n                  })\n```\n\n\n\n#### 根据列合并\n\n```python\npd.merge(d1,d2,on=\"key\",how=\"inner\")\n# on:合并关键字，根据他来确定要合并哪些数据,多个字段用列表传入\n# how：\n    #inner：保留相同，默认\n    #outer：全部保留\n    #left： 根据左边的数据表保存数据\n    #right: 根据右边的数据表保留数据\n```\n\n#### 根据行合并\n\n```python\npd.merge(d1,d2,left_index=True,right_index=True)\n# left_index: \n    #True: 合并时考虑左侧数据表的行标题\n    #False：合并时不考虑左侧数据表的行标题\n# right_index:\n    #True：合并时考虑右侧数据表的行标题\n    #False：合并时不考虑右侧数据表的行标题\n```\n\n#### 显示合并状态\n\n```python\npd.merge(d1,d2,on=\"key\",how=\"right\",indicator=True)\n# indicator: 新建一列用来显示合并数据在两个表中的状态\n    #True： 显示状态\n    #False： 不显示状态，默认\n    #指定名称: 显示状态，并且按照指定的名字命名新建的列\n```\n\n#### 同名列处理\n\n```python\ngrils = pd.DataFrame({\"K\":[\"A\",\"B\",\"C\"],\n                     \"age\":[1,2,3]\n                     })\nboys = pd.DataFrame({\"K\":list(\"ACD\"),\n                    \"age\":[4,5,6]})\n\n\npd.merge(grils,boys,on=\"K\",suffixes=[\"_grils\",\"_boys\"],how=\"outer\")\n#suffixes:当两组数据列名相同但实际表示含义不同时，使用它来区分\n```\n\n\n\n# 数据存取\n\n| 文件格式 |     读取      |      存储      |\n| :------: | :-----------: | :------------: |\n|   csv    | pd.read_csv() | datas.to_csv() |\n|  excel   | pd.read_excel | datas.to_excel |\n|   json   | pd.read_json  | datas.to_json  |\n|   sql    |  pd.read_sql  |  datas.to_sql  |\n|   ...    |               |                |\n\n```python\n# 读取csv数据\ndatas = pd.read_csv(\"Income.csv\")\n# 保存成pickle\ndatas.to_pickle(\"Income.pickle\")\n```\n\n# axis\n\n![img](Python%20pandas.assets/axis.png)",
    type: "Python",
    tag: [
        "Python模块"
    ],
    hit: NumberInt("0"),
    createDate: ISODate("2022-05-11T10:23:15.528Z"),
    modifyDate: ISODate("2022-05-11T10:23:15.528Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627b90331947aa32e2a4beb7"),
    title: "Java 多线程",
    content: "<h1 class=\"markdown-h1\">多线程</h1>\n<p>在计算机中，每个程序都是一个进程，打开Windows的任务管理器，第一个选项卡就是进程，里面列出了系统中所有的进程。</p>\n<p>每个程序启动时都会开启一个进程，进程内包含一个主线程。</p>\n<p>每个进程都可以开辟多个线程，多个线程可以在宏观上并行执行，但是在微观上实际还是串行执行</p>\n<blockquote class=\"markdown-blockquote\">\n<p>举个例子</p>\n<p>假如我们编写了一个服务器程序，但是这个程序只有一个线程，当有两个用户同时访问这个程序时，第一个到达服务器的用户服务器可以正常的被处理，但第二个到达服务器的用户只能等待第一个用户访问结束后才能处理第二个用户的处理。假如第一个用户需要处理的任务时间是1小时，那么第二个用户铁定已经点了右上角的叉号了。</p>\n<p>另外，第一个用户的任务时长是一小时，那么在处理完这个任务之前是无法给该用户返回消息的，这也就是说该用户只能盯着网页看一个小时才能得到结果，并且中途不会受到任何进度提示，那么铁定第一个用户也在枯燥的等待中点了右上角的叉号。</p>\n<p>也就是说没有多线程的服务器程序可以说是什么事情都干不了的</p>\n<p>假如我们给每个用户开了2条线程，一条线程用于处理业务，另一条线程用于向用户汇报进度</p>\n<p>这样每个用户进入服务器后都会开辟两条线程，第一条线程直接开始任务，一个小时完成，第二条线程告诉用户任务已经开始了，一个小时或一天后来看结果，这样两个用户的任务都完成了，也不会出现第一个用户任务没完成第二个用户只能等待的情况</p>\n</blockquote>\n<h1 class=\"markdown-h1\">多线程实现</h1>\n<p>多线程实现由三种方式，分别是继承Thread，实现Runable接口，实现Callable接口三种，每种都有不同的作用</p>\n<p>实现Callable接口的实现方式需要线程池实现，所以会在线程池中说明如何使用</p>\n<h2 class=\"markdown-h2\">继承Thread</h2>\n<p>Thread类，位于<code class=\"markdown-linecode\">java.lang</code>包下，是Java内置的线程对象，无须导包即可使用</p>\n<blockquote class=\"markdown-blockquote\">\n<p>举个例子</p>\n<p>在2000年左右，中国的汽车进口关税曾经高达230%，相当于你买车是买了两辆半，一辆自己开，剩下的一辆半捐给了国家，当时能够开的起汽车的人是真的富有，国外的汽车厂商看到如此高的关税使得他们的汽车在中国不好卖，又眼馋中国巨大的市场，不得不和中国的企业合作，这也就出现的像一汽大众，长安福特等等的合资企业，这些企业是在国内生产外壳等零部件，只进口发动机，这样车的关税就只有发动机部分的了，这样就降低了价格，让更多人的人能够买上汽车，这也就促进了中国汽车也的发展，使中国能够在起步晚的情况下不至于掉队</p>\n<p>回到多线程中，继承Thread的方法相当于是整车进口，可以直接点火启动启动</p>\n<p>实现Runable接口的方法相当于是只进口了发动机，还需要再制造外壳</p>\n</blockquote>\n<pre><code class=\"language-java\">public class TestThread{\n\tpublic static void main(String  [] args){\n\t\tThreadOne t1 = new ThreadOne(); // 创建线程，新生状态(创建状态)，进口整车\n\t\tt1.start();// 启动线程，就绪状态\n    }\n}\nclass ThreadOne extends Thread{\n\t// 第一种实现方式，继承Thread类,实现run方法\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0; i &lt; 100; i++){\n\t\t\tSystem.out.println(&quot;第一种线程实现方式&quot;);\n\t\t}\n\t}\n}\n</code></pre>\n<h2 class=\"markdown-h2\">实现Runable接口</h2>\n<p>Runable接口是为了弥补在类已经继承了父类，无法继承Thread类时的不足</p>\n<pre><code class=\"language-java\">public class TestThread{\n\tpublic static void main(String  [] args){\n\t\tThreadTwo t2 = new ThreadTwo(); // 相当于发动机\n\t\tThread t = new Thread(t2);// 创建外壳，并装上发动机，新生状态(创建状态)\n\t\tt.start();// 启动线程，就绪状态\n    }\n}\nclass ThreadTwo implements Runnable{\n\t// 第二种实现方式，实现Runnable接口，实现run方法\n\t// 相较于第一种，在继承其他类时可以使用该方法\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0; i &lt; 100; i++){\n\t\t\tSystem.out.println(&quot;第二种线程实现方式&quot;);\n\t\t}\n\t}\n}\n</code></pre>\n<h1 class=\"markdown-h1\">线程执行的控制方式</h1>\n<h2 class=\"markdown-h2\">(setPriority)设置优先级</h2>\n<p>优先级高的线程有更大的概率获得时间片，而并非优先级高的线程先执行，既然是概率就会有很大的不确定性，谁也无法保证哪个线程先执行</p>\n<ul class=\"markdown-list\">\n<li>1最小，10最大，默认5</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.concurrent.*;\npublic class TestThread{\n\tpublic static void main(String  [] args){\n\t\tThreadOne t1 = new ThreadOne(); // 创建线程，新生状态(创建状态)\n\t\tt1.setPriority(10);\n\t\tt1.start();// 启动线程，就绪状态\n\t\tThreadTwo t2 = new ThreadTwo();\n\t\tThreadThree t3 = new ThreadThree();\n\t\tThread t = new Thread(t2);\n\t\tt.setPriority(1);\n\t\tt.start();\n\n\t}\n}\nclass ThreadOne extends Thread{\n\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0; i &lt; 1000; i++){\n\t\t\tSystem.out.println(&quot;第一种线程实现方式&quot;);\n\t\t}\n\t}\n}\nclass ThreadTwo implements Runnable{\n\t// 第二种实现方式，实现Runnable接口，实现run方法\n\t// 相较于第一种，在继承其他类时可以使用该方法\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0; i &lt; 1000; i++){\n\t\t\tSystem.out.println(&quot;第二种线程实现方式&quot;);\n\t\t}\n\t}\n}\n</code></pre>\n<h2 class=\"markdown-h2\">sleep(休眠)</h2>\n<p>休眠指定的毫秒数，休眠是阻塞方法，需要处理异常</p>\n<pre><code class=\"language-java\">public class TestSleep{\n\tpublic static void main(String[] args)throws Exception{\n\t\tThreadOne t1 = new ThreadOne();\n\t\tt1.start();\n\t\tThread.sleep(5000);\n\n\t\tfor(int i = 0;i&lt;100;i++){\n\t\t\tSystem.out.println(&quot;叶莉&quot;);\n\t\t}\n\t}\n}\nclass ThreadOne extends Thread{\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0;i&lt;100;i++){\n\t\t\tSystem.out.println(&quot;姚明&quot;);\n\t\t}\n\t}\n}\n</code></pre>\n<p>休眠sleep是一个静态方法，也就是说任意一个继承Tread类的实例对象能使用该方法，这就会造成很大的迷惑性例如:</p>\n<pre><code class=\"language-java\">public class TestSleep{\n\tpublic static void main(String[] args)throws Exception{\n\t\tThreadOne t1 = new ThreadOne();\n\t\tt1.start();\n\t\tt1.sleep(5000); // 此处做了修改\n\n\t\tfor(int i = 0;i&lt;100;i++){\n\t\t\tSystem.out.println(&quot;叶莉&quot;);\n\t\t}\n\t}\n}\nclass ThreadOne extends Thread{\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0;i&lt;100;i++){\n\t\t\tSystem.out.println(&quot;姚明&quot;);\n\t\t}\n\t}\n}\n</code></pre>\n<p>当你执行之后你会发现与之前的代码并无区别，但是我们调用的是<code class=\"markdown-linecode\">t1.sleep(5000); </code>，不是应该t1线程休眠5秒吗？</p>\n<p><font color=red>在线程中大部分方法调用并不会看是哪个对象调用的，而是看在哪条线程中调用的</font></p>\n<h2 class=\"markdown-h2\">yield(放弃当前时间片)</h2>\n<p>yield放弃当前时间片，重新争抢时间片，这种方法与设置优先级类似，对于线程的控制是不确定的，yield方式时间片之后很可能会出现自投自抢的情况</p>\n<pre><code class=\"language-java\">public class TestYield{\n\tpublic static void main(String[] args){\n\t\tNumberThread nt = new NumberThread();\n\t\tCharThread ct = new CharThread();\n\t\tnt.start();\n\t\tct.start();\n\t}\n}\nclass NumberThread extends Thread{\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 1;i&lt;=26;i++){\n\t\t\tSystem.out.println(i);\n\t\t\tThread.yield();\n\t\t}\n\t}\n}\nclass CharThread extends Thread{\n\t@Override\n\tpublic void run(){\n\t\tfor(char c = 'a';c&lt;='z';c++){\n\t\t\tSystem.out.println(c);\n\t\t\tThread.yield();\n\t\t}\n\t}\n}\n</code></pre>\n<p>执行完上面的代码会发现，并不是<code class=\"markdown-linecode\">1a2b3c</code>这种交替执行的，可能会出现某条线程多次执行的情况</p>\n<h2 class=\"markdown-h2\">join</h2>\n<p>join方法所在的线程会邀请执行join方法的线程优先执行，被邀请的线程未执行完之前邀请的线程不会执行</p>\n<p>这种方法使用于A线程会生成数据，这些数据是B线程执行所必须的数据，这时候可以在B线程中邀请A线程先执行，当A线程执行完毕后生成的数据用于B线程的执行</p>\n<pre><code class=\"language-java\">public class TestJoin{\n\tpublic static void main(String[] args)throws Exception{\n\t\tMyThread mt = new MyThread();\n\t\tmt.start();\n\n\t\t//当前线程(主线程)邀请调用方法的线程(mt)优先执行\n\t\tmt.join();\n\n\t\tfor(int i = 0;i&lt;100;i++){\n\t\t\tSystem.out.println(&quot;梦回吹角连营&quot;);\n\t\t}\n\t}\n}\nclass MyThread extends Thread{\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0;i&lt;100;i++){\n\t\t\tSystem.out.println(&quot;醉里挑灯看剑&quot;);\n\t\t}\n\t}\n}\n</code></pre>\n<h1 class=\"markdown-h1\">线程常用的方法</h1>\n<h2 class=\"markdown-h2\">getName()和setName()</h2>\n<p>用于设置和获取线程的名字，用于区分不同线程</p>\n<pre><code class=\"language-java\">public class TestSetNameAndGetName{\n\tpublic static void main(String[] args){\n\t\tStudent s1 = new Student(&quot;刘玄德&quot;,777,&quot;雌雄双股剑&quot;);\n\t\tStudent s2 = new Student(&quot;关云长&quot;,666,&quot;青龙偃月刀&quot;);\n\t\tStudent s3 = new Student(&quot;张翼德&quot;,555,&quot;AK47&quot;);\n\t\ts1.start();\n\t\ts2.start();\n\t\ts3.start();\n\t}\n}\n\nclass Student extends Thread{\n\tint num;\n\tString weapon;\n\tpublic Student(String name,int num,String weapon){\n\t\tsetName(name);//调用父类继承来的设置名字的方法\n\t\tthis.num = num;\n\t\tthis.weapon = weapon;\n\t}\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0;i&lt;num;i++){\n\t\t\tSystem.out.println(&quot;我叫&quot;+getName()+&quot; 手持&quot;+weapon);\n\t\t}\n\t}\n}\n</code></pre>\n<h2 class=\"markdown-h2\">activeCount</h2>\n<p>用于获取当先活跃线程数量，包括主线程</p>\n<p>活跃线程：除去新生状态和消亡状态的线程，其他都是活跃状态</p>\n<pre><code class=\"language-java\">public class TestActiveCount{\n\tpublic static void main(String[] args){\n\t\tint x = (int)(Math.random()*5)+5;//5-9\n\t\tfor(int i = 0;i&lt;x;i++){\n\t\t\tnew MyThread().start();\n\t\t}\n\t\twhile(true){\n\t\t\tSystem.out.println(Thread.activeCount());\n\t\t}\n\t}\n}\nclass MyThread extends Thread{\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0;i&lt;100;i++){\n\t\t\ttry{\n\t\t\t\tThread.sleep(1000);\n\t\t\t}catch(Exception e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t}\n\t}\n}\n</code></pre>\n<h2 class=\"markdown-h2\">setDaemon</h2>\n<p>设置守护线程，守护线程：在非守护线程全部执行完毕后自动消亡</p>\n<blockquote class=\"markdown-blockquote\">\n<p>守护线程应该具备的条件</p>\n<ul class=\"markdown-list\">\n<li>应该是无限循环，防止过早消亡</li>\n<li>应该设置最低优先级，防止与业务逻辑争抢资源</li>\n<li>设置守护线程必须在其线程启动之前</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-java\">public class TestSetDaemon{\n\tpublic static void main(String[] args){\n\t\tGYJJ gy = new GYJJ();\n\t\t//*:守护线程应该具有最低的优先级 防止其与核心业务争抢资源\n\t\tgy.setPriority(1);\n\t\t//*:它必须早于自身的start()\n\t\tgy.setDaemon(true);\n\t\tgy.start();\n\n\t\tfor(int i = 0;i&lt;1000;i++){\n\t\t\tSystem.out.println(&quot;西天取经上大路 一走就是几万里&quot;);\n\t\t}\n\t}\n}\nclass GYJJ extends Thread{\n\t@Override\n\tpublic void run(){\n\t\t//*: 守护线程通常都是无限循环 防止其过早消亡\n\t\twhile(true){\n\t\t\tSystem.out.println(&quot;你这泼猴儿~&quot;);\n\t\t}\n\t}\n}\n</code></pre>\n<h2 class=\"markdown-h2\">interrupt</h2>\n<p>打断线程的阻塞状态,手动唤醒阻塞的线程</p>\n<pre><code class=\"language-java\">public class TestInterrupt{\n\tpublic static void main(String[] args){\n\t\tMyThread mt = new MyThread();\n\t\tmt.start();\n\n\t\t//当前线程(主线程) 中断 调用方法的线程(mt) 的阻塞状态\n\t\tmt.interrupt();\n\t}\n}\nclass MyThread extends Thread{\n\t@Override\n\tpublic void run(){\n\t\ttry{\n\t\t\tThread.sleep(999999999999999L);\n\t\t}catch(Exception e){\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(&quot;吖！神清气爽吖！&quot;);\n\t}\n}\n</code></pre>\n<p>执行后会输出异常信息，是因为Thread.sleep方法被主线程强制唤醒，sleep方法未能正常执行报的异常，但是因为我们已经捕获了异常，并将异常打印了，并不会影响执行，在正常开发中需要对它进行处理</p>\n<h1 class=\"markdown-h1\">线程状态</h1>\n<p><img src=\"http://pandacode.xyz/upload/2021/05/image-4e48089a52a94aa4ac45bef7158439f1.png\" alt=\"image.png\" /></p>\n<h1 class=\"markdown-h1\">并发错误及处理</h1>\n<p>并发错误是一种非常难缠且危险的错误类型，它编译不报错，执行无异常，但是就是数据不对，杀程序员与无形</p>\n<p>并发错误出现的根本原因在于多个线程同时操作一份数据或者一个对象</p>\n<p>并发错误是一组本应该连续执行的操作，在执行到一半时时间片耗尽，数据被其他线程修改出现的数据不一致</p>\n<blockquote class=\"markdown-blockquote\">\n<p>并发错误演示</p>\n</blockquote>\n<pre><code class=\"language-java\">public class TestConcurrentError{\n\tpublic static void main(String[] args){\n\t\tPerson p = new Person(&quot;梁朝伟&quot;,&quot;先生&quot;);\n\t\tPrintThread pt = new PrintThread(p);\n\t\tChangeThread ct = new ChangeThread(p);\n\t\tpt.start();\n\t\tct.start();\n\t}\n}\n\nclass PrintThread extends Thread{\n\tPerson p;\n\tpublic PrintThread(Person p){\n\t\tthis.p = p;\n\t}\n\t@Override\n\tpublic void run(){\n\t\twhile(true){\n\t\t\tSystem.out.println(p.name + &quot; : &quot; + p.gender);\n\t\t}\n\t}\n}\nclass ChangeThread extends Thread{\n\tPerson p;\n\tpublic ChangeThread(Person p){\n\t\tthis.p = p;\n\t}\n\t@Override\n\tpublic void run(){\n\t\tboolean isOkay = true;\n\t\twhile(true){\n\n\t\t\tif(isOkay){\n\t\t\t\tp.name = &quot;张曼玉&quot;;\n\t\t\t\tp.gender = &quot;女士&quot;;\n\t\t\t}else{\n\t\t\t\tp.name = &quot;梁朝伟&quot;;\n\t\t\t\tp.gender = &quot;先生&quot;;\n\t\t\t}\n\t\t\tisOkay = !isOkay;\n\t\t}\n\t}\n}\nclass Person{\n\tString name;\n\tString gender;\n\tpublic Person(String name,String gender){\n\t\tthis.name = name;\n\t\tthis.gender = gender;\n\t}\n}\n\n</code></pre>\n<p>在上面的程序执行过程中，你会发现有时会打印<code class=\"markdown-linecode\">梁朝伟：女士</code>，<code class=\"markdown-linecode\">张曼玉：先生</code>，这就是并发错误造成的</p>\n<p>解决并发错误的方法就两个字：<font color=red>加锁</font>，所有要使用某个数据的线程都约定好一个锁，谁拿到了锁标记，谁有执行权限，没有锁标记的线程进入锁池，等待锁标记的归还</p>\n<h2 class=\"markdown-h2\">synchronized</h2>\n<p>synchronized 是java内置的加锁方式，它有两种使用方式，一种是直接指定对某个对象加锁，也就是下面代码使用的方式；另一种是在方法体上作为修饰符使用，改方法实际上是对调用该方法的对象加锁，也就是this锁</p>\n<pre><code class=\"language-java\">public class TestConcurrentError{\n\tpublic static void main(String[] args){\n\t\tPerson p = new Person(&quot;梁朝伟&quot;,&quot;先生&quot;);\n\t\tPrintThread pt = new PrintThread(p);\n\t\tChangeThread ct = new ChangeThread(p);\n\t\tpt.start();\n\t\tct.start();\n\t}\n}\n\nclass PrintThread extends Thread{\n\tPerson p;\n\tpublic PrintThread(Person p){\n\t\tthis.p = p;\n\t}\n\t@Override\n\tpublic void run(){\n\t\twhile(true){\n\t\t\tsynchronized(p){\n\t\t\t\tSystem.out.println(p.name + &quot; : &quot; + p.gender);\n\t\t\t}\n\n\t\t}\n\t}\n}\nclass ChangeThread extends Thread{\n\tPerson p;\n\tpublic ChangeThread(Person p){\n\t\tthis.p = p;\n\t}\n\t@Override\n\tpublic void run(){\n\t\tboolean isOkay = true;\n\t\twhile(true){\n\t\t\tsynchronized(p){\n\t\t\t\tif(isOkay){\n\t\t\t\t\tp.name = &quot;张曼玉&quot;;\n\t\t\t\t\tp.gender = &quot;女士&quot;;\n\t\t\t\t}else{\n\t\t\t\t\tp.name = &quot;梁朝伟&quot;;\n\t\t\t\t\tp.gender = &quot;先生&quot;;\n\t\t\t\t}\n\t\t\t}\n\t\t\tisOkay = !isOkay;\n\n\t\t}\n\t}\n}\nclass Person{\n\tString name;\n\tString gender;\n\tpublic Person(String name,String gender){\n\t\tthis.name = name;\n\t\tthis.gender = gender;\n\t}\n}\n</code></pre>\n<h2 class=\"markdown-h2\">ReentrantLock</h2>\n<p>可重入锁，用面向对象思想实现的加锁方式</p>\n<p>使用之前需要导入java.util.concurrent.locks.ReentrantLock包</p>\n<p>该方法因为是使用面向对象思想创建的，所以更容易扩展</p>\n<p>同时该方法还支持公平锁和非公平锁</p>\n<p>公平锁：按照线程的先来后到给锁标记，需要多加一个队列，更加消耗资源</p>\n<p>非公平锁：所以线程在锁标记归还时争抢锁</p>\n<ul class=\"markdown-list\">\n<li>默认是非公平锁</li>\n</ul>\n<pre><code class=\"language-java\">import java.util.concurrent.locks.ReentrantLock;\npublic class TestConcurrentError{\n\tpublic static void main(String[] args){\n\t\tReentrantLock lock = new ReentrantLock();\n\t\tPerson p = new Person(&quot;梁朝伟&quot;,&quot;先生&quot;);\n\t\tPrintThread pt = new PrintThread(p,lock);\n\t\tChangeThread ct = new ChangeThread(p,lock);\n\t\tpt.start();\n\t\tct.start();\n\t}\n}\n\nclass PrintThread extends Thread{\n\tReentrantLock lock;\n\tPerson p;\n\tpublic PrintThread(Person p,ReentrantLock lock){\n\t\tthis.p = p;\n\t\tthis.lock = lock;\n\t}\n\t@Override\n\tpublic void run(){\n\t\twhile(true){\n\t\t\tlock.lock();\n\t\t\tSystem.out.println(p.name + &quot; : &quot; + p.gender);\n\t\t\tlock.unlock();\n\n\t\t}\n\t}\n}\nclass ChangeThread extends Thread{\n\tReentrantLock lock;\n\tPerson p;\n\tpublic ChangeThread(Person p,ReentrantLock lock){\n\t\tthis.p = p;\n\t\tthis.lock = lock;\n\t}\n\t@Override\n\tpublic void run(){\n\t\tboolean isOkay = true;\n\t\twhile(true){\n\t\t\tlock.lock();\n\t\t\tif(isOkay){\n\t\t\t\tp.name = &quot;张曼玉&quot;;\n\t\t\t\tp.gender = &quot;女士&quot;;\n\t\t\t}else{\n\t\t\t\tp.name = &quot;梁朝伟&quot;;\n\t\t\t\tp.gender = &quot;先生&quot;;\n\t\t\t}\n\t\t\tlock.unlock();\n\t\t\tisOkay = !isOkay;\n\n\t\t}\n\t}\n}\nclass Person{\n\tString name;\n\tString gender;\n\tpublic Person(String name,String gender){\n\t\tthis.name = name;\n\t\tthis.gender = gender;\n\t}\n}\n</code></pre>\n<h2 class=\"markdown-h2\">死锁</h2>\n<p>死锁是加锁过多或者加锁不当造成的，互相持有对方想要的资源不愿放弃，同时又想要对方手里的资源的情况，这种情况就会造成程序的卡死</p>\n<blockquote class=\"markdown-blockquote\">\n<p>死锁问题演示</p>\n<p>刘总和安总上班都需要经过泉城路，一个从东侧进入泉城路，一个从西侧进入泉城路，两人都想去到对方的位置，但是都不想放弃现在的位置，两个人就在这耗着谁也走不了，这就会造成死锁</p>\n</blockquote>\n<pre><code class=\"language-java\">public class TestDeadLock{\n\tpublic static void main(String[] args){\n\t\tQCRoad r = new QCRoad();\n\t\tQCRoad.Benz s900 = r.new Benz();\n\t\tQCRoad.Bmw x9 = r.new Bmw();\n\t\ts900.start();\n\t\tx9.start();\n\t}\n}\nclass QCRoad{\n\tObject east = new Object();//路东资源\n\tObject west = new Object();//路西资源\n\n\tclass Benz extends Thread{\n\t\t@Override\n\t\tpublic void run(){\n\t\t\tSystem.out.println(&quot;安总驾驶奔驰驶出家门去上课&quot;);\n\t\t\tsynchronized(east){\n\t\t\t\tSystem.out.println(&quot;安总和他的奔驰占领了泉城路东侧&quot;);\n\t\t\t\tsynchronized(west){\n\t\t\t\t\tSystem.out.println(&quot;安总和他的奔驰又占领了泉城路西侧&quot;);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(&quot;安总顺利的通过了泉城路~&quot;);\n\t\t}\n\t}\n\tclass Bmw extends Thread{\n\t\t@Override\n\t\tpublic void run(){\n\t\t\tSystem.out.println(&quot;刘总驾驶宝马驶出家门去上课&quot;);\n\t\t\tsynchronized(west){\n\t\t\t\tSystem.out.println(&quot;刘总和他的宝马已经占领泉城路西侧&quot;);\n\t\t\t\tsynchronized(east){\n\t\t\t\t\tSystem.out.println(&quot;刘总和他的宝马又占领了泉城路东侧&quot;);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(&quot;刘总顺利的通过了泉城路~&quot;);\n\t\t}\n\t}\n}\n</code></pre>\n<p>上面的程序多数情况下会是死锁，只有在一方线程启动较晚的时候会出现正常执行，可以理解为刘总或者安总起晚了，已经走过泉城路了对方还没来</p>\n<blockquote class=\"markdown-blockquote\">\n<p>解决死锁问题</p>\n<p>解决死锁问题其实非常简单，安总或者刘总一方把路让出来就可以了，比如安总把车开到了小胡同里，让出了自己这一侧的路，让刘总先通过，然后在刘总通过后再从互通里出来通过泉城路</p>\n</blockquote>\n<pre><code class=\"language-java\">public class TestDeadLock{\n\tpublic static void main(String[] args){\n\t\tQCRoad r = new QCRoad();\n\t\tQCRoad.Benz s900 = r.new Benz();\n\t\tQCRoad.Bmw x9 = r.new Bmw();\n\t\ts900.start();\n\t\tx9.start();\n\t}\n}\nclass QCRoad{\n\tObject east = new Object();//路东资源\n\tObject west = new Object();//路西资源\n\n\tclass Benz extends Thread{\n\t\t@Override\n\t\tpublic void run(){\n\t\t\tSystem.out.println(&quot;安总驾驶奔驰驶出家门去上课&quot;);\n\t\t\tsynchronized(east){\n\t\t\t\tSystem.out.println(&quot;安总和他的奔驰占领了泉城路东侧&quot;);\n\n\t\t\t\ttry{\n\t\t\t\t\teast.wait();\n\t\t\t\t}catch(Exception e){\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tsynchronized(west){\n\t\t\t\t\tSystem.out.println(&quot;安总和他的奔驰又占领了泉城路西侧&quot;);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(&quot;安总顺利的通过了泉城路~&quot;);\n\t\t}\n\t}\n\tclass Bmw extends Thread{\n\t\t@Override\n\t\tpublic void run(){\n\t\t\tSystem.out.println(&quot;刘总驾驶宝马驶出家门去上课&quot;);\n\t\t\tsynchronized(west){\n\t\t\t\tSystem.out.println(&quot;刘总和他的宝马已经占领泉城路西侧&quot;);\n\t\t\t\tsynchronized(east){\n\t\t\t\t\tSystem.out.println(&quot;刘总和他的宝马又占领了泉城路东侧&quot;);\n\t\t\t\t\teast.notify();//从east对象的等待池当中随机的唤醒一个线程\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(&quot;刘总顺利的通过了泉城路~&quot;);\n\t\t}\n\t}\n}\n</code></pre>\n<p>上面安总代码中使用到wait方法就是让出自己占有的资源，让其他线程优先使用，自已让出来后需要进入“小胡同”这个小胡同在并发处理中被称为等待池，而刘总代码中使用的notify方法是通知安总已经用完资源了，可以出来了，也就是将其从等待池中唤醒</p>\n<p>解决死锁问题共计需要</p>\n<ul class=\"markdown-list\">\n<li>\n<p>一块空间：对象的等待池；</p>\n</li>\n<li>\n<p>三个方法：</p>\n<ul class=\"markdown-list\">\n<li>wait 等待；</li>\n<li>notify通知随机一个线程资源已经被释放；</li>\n<li>notifyAll通知等待池中的全部线程资源已经被释放</li>\n</ul>\n</li>\n</ul>\n<h1 class=\"markdown-h1\">线程池</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>什么是线程池？</p>\n<p>线程可以生命周期可以分为创建线程、执行核心业务、销毁线程三部分</p>\n<p>当一个线程的核心业务在这三部分中占比很小的时候，创建线程和销毁线程会花费大量的时间，但是这部分时间是毫无意义的，这就会造成资源大量的浪费，在程序需要服务的客户数量较少时，这部分资源的浪费体现并不明显，但是当用户数量不断上升时，这部分浪费的资源也会随之增加，这部分资源的浪费就会越发明显</p>\n<p>举个例子</p>\n<p>我们在家吃饭时情况与上述的问题是十分相似的，我们的核心业务是吃饭，但是饭不是凭空生成的，我们就需要做饭，这就相当于创建线程，做饭可能需要半小时，吃饭可能只需要10分钟，这是核心业务，吃完饭之后需要刷碗，这相当于销毁线程，这可能又需要10分钟，我们的核心业务吃饭在整个任务中只占了10分钟，创建和销毁线程需要40分钟，这就存在大量的资源浪费</p>\n<p>线程池就相当于我们去下馆子，做饭和刷碗的事情不归我们管了，我们的核心业务吃饭从原来的50分钟，降低到了10分钟，剩下的40分钟并非消失了，而是都由饭店来帮我处理了，线程池的作用就和饭店是类似的。虽然总时间是相同的，但是用户在体验上得到了大幅度优化。</p>\n<p>线程池把影响用户体验但实际上占用的时间与核心业务无关的创建和销毁线程的动作给接管了，我们不在需要创建和销毁线程</p>\n</blockquote>\n<h2 class=\"markdown-h2\">Callable接口</h2>\n<p>多线程实现的前两种方式都可以使用线程池来实现，但是前两种方式存在很大的局限性，当线程中处理的数据需要返回结果时，前两种方法时无法实现的，并且这两种方式都无法在线程内抛出异常，强迫程序员必须处理异常。</p>\n<p>Callable接口可以有返回值，并且能够抛出异常这就弥补了前面两种创建线程的不足，但是Callable接口也是存在局限性的，前两种实现方式是可以直接创建线程的，但是Callable接口是不能直接创建线程，Callable接口需要借助线程池来实现</p>\n<h2 class=\"markdown-h2\">修复后可重用的线程池</h2>\n<p>Executors.newFixedThreadPool</p>\n<p>Executors(执行器)是线程池的工具类，其中的newFixedThreadPool是修复后可重用的线程池，该方法接收一个参数，改参数表示要在线程池中预先创建多少个线程，被创建的线程数在线程池关闭前不会销毁，而是每次提交一个任务则分配一个线程给任务使用，当任务执行完毕后，线程不会销毁，而是归还线程池等待下一个任务的提交，当线程池中的线程全部被耗尽后，其他提交的线程会被存放在一个容器中，等待有空余线程时执行。</p>\n<p>这种线程池可以很好的应对用户数量很稳定不会出现像双十一这种用户数量大幅度增长的情况。</p>\n<pre><code class=\"language-java\">import java.util.concurrent.*;\npublic class TestThreadPool1{\n\tpublic static void main(String [] args){\n        // 创建一个有3条线程的线程池\n\t\tExecutorService es = Executors.newFixedThreadPool(3); \n\t\tCallableThread ct = new CallableThread(); // 创建Callable对象\n\t\tes.submit(ct); // 提交任务\n\t\tes.shutdown(); // 关闭线程池\n\t}\n}\nclass CallableThread implements Callable&lt;String&gt; { // 泛型定义返回值\n\t@Override\n\tpublic String call() throws Exception{ // 可以抛出异常\n\t\tfor(int i = 0; i &lt; 100; i++){\n\t\t\tSystem.out.println(&quot;Callable 线程&quot;);\n\t\t}\n\t\treturn &quot;call&quot;; // 返回值\n\t}\n}\n</code></pre>\n<h2 class=\"markdown-h2\">缓存机制的线程池</h2>\n<p>Executors工具类下的newCachedThreadPool是缓存机制的线程池，该线程池能够动态的控制线程池内的线程数量，newCachedThreadPool创建线程的规则是当有一个用户向线程池提交任务时，线程池内没有可用的线程则创建一个线程，这条线程在完成当前用户的任务后会存活60秒，如果这60秒之内有新的任务提交到线程池中则直接给用户分配该线程，如果在完成任务60秒之内没有新的任务提交到线程池则销毁该线程。</p>\n<p>这种线程池可以应对双十一这种在某一时间段并发量会大幅度波动的情况。</p>\n<pre><code class=\"language-java\">import java.util.concurrent.*;\npublic class TestThreadPool1{\n\tpublic static void main(String [] args){\n\t\tExecutorService es = Executors.newCachedThreadPool(); \n\t\tCallableThread ct1 = new CallableThread(&quot;1&quot;); // 创建Callable对象\n\t\tCallableThread ct2 = new CallableThread(&quot;2&quot;); // 创建Callable对象\n\t\tCallableThread ct3 = new CallableThread(&quot;3&quot;); // 创建Callable对象\n\t\tes.submit(ct1); // 提交任务\n\t\tes.submit(ct2); // 提交任务\n\t\tes.submit(ct3); // 提交任务\n\t\t\n\t\tes.shutdown(); // 关闭线程池\n\t}\n}\nclass CallableThread implements Callable&lt;String&gt; { // 泛型定义返回值\n\tString name;\n\tpublic CallableThread(String name){\n\t\tthis.name = name;\n\t}\n\t@Override\n\tpublic String call() throws Exception{ // 可以抛出异常\n\t\tfor(int i = 0; i &lt; 100; i++){\n\t\t\tSystem.out.println(&quot;Callable 线程&quot; + name);\n\t\t}\n\t\treturn &quot;call&quot;; // 返回值\n\t}\n}\n</code></pre>\n<h2 class=\"markdown-h2\">单一线程执行器</h2>\n<p>Executors.newSingleThreadExecutor</p>\n<p>实际上他并不是线程池，他相当于是在程序中修了一座独木桥，只允许一个线程通过</p>\n<p>利用这种机制可以实现像商品秒杀这种只用固定几个线程能够抢到执行权限的应用场景</p>\n<pre><code class=\"language-java\">import java.util.concurrent.*;\npublic class TestThreadPool1{\n\tpublic static void main(String [] args){\n\t\tExecutorService es = Executors.newSingleThreadExecutor(); \n\t\tCallableThread ct1 = new CallableThread(&quot;1&quot;); // 创建Callable对象\n\t\tCallableThread ct2 = new CallableThread(&quot;2&quot;); // 创建Callable对象\n\t\tCallableThread ct3 = new CallableThread(&quot;3&quot;); // 创建Callable对象\n\t\tes.submit(ct1); // 提交任务\n\t\tes.submit(ct2); // 提交任务\n\t\tes.submit(ct3); // 提交任务\n\t\t\n\t\tes.shutdown(); // 关闭线程池\n\t}\n}\nclass CallableThread implements Callable&lt;String&gt; { // 泛型定义返回值\n\tString name;\n\tpublic CallableThread(String name){\n\t\tthis.name = name;\n\t}\n\t@Override\n\tpublic String call() throws Exception{ // 可以抛出异常\n\t\tfor(int i = 0; i &lt; 100; i++){\n\t\t\tSystem.out.println(&quot;Callable 线程&quot; + name);\n\t\t}\n\t\treturn &quot;call&quot;; // 返回值\n\t}\n}\n</code></pre>\n<h2 class=\"markdown-h2\">线程池两种关闭方式的区别</h2>\n<ul class=\"markdown-list\">\n<li>shutdown ： 不再接收新任务的提交，但已经提交的任务会被执行，正在执行的任务也不会被终止</li>\n<li>shutdownNow ：不再接收新任务的提交，已经提交的任务也不会被执行，但是已经开始的任务不会被终止</li>\n</ul>\n<h2 class=\"markdown-h2\">线程池源码分析</h2>\n<pre><code class=\"language-java\">public static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue&lt;Runnable&gt;());\n}\n</code></pre>\n<pre><code class=\"language-java\">public static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue&lt;Runnable&gt;());\n}\n</code></pre>\n<pre><code class=\"language-java\">public static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue&lt;Runnable&gt;()));\n}\n</code></pre>\n<p>通过查看源码，我们可以发现，这三种线程池的本质都是创建了一个ThreadPoolExecutor类的对象</p>\n<p>该对象的构造函数的参数代表的意思分别为</p>\n<ul class=\"markdown-list\">\n<li>线程池内线程最低个数</li>\n<li>线程池内线程最大个数</li>\n<li>线程存活时间</li>\n<li>线程存活时间的单位</li>\n<li>用于存储任务的队列\n<ul class=\"markdown-list\">\n<li>只有当线程池内没有可以执行当前任务的线程时才会存入队列等待执行</li>\n</ul>\n</li>\n</ul>\n",
    markdown: "# 多线程\n\n在计算机中，每个程序都是一个进程，打开Windows的任务管理器，第一个选项卡就是进程，里面列出了系统中所有的进程。\n\n每个程序启动时都会开启一个进程，进程内包含一个主线程。\n\n每个进程都可以开辟多个线程，多个线程可以在宏观上并行执行，但是在微观上实际还是串行执行\n\n> 举个例子\n>\n> 假如我们编写了一个服务器程序，但是这个程序只有一个线程，当有两个用户同时访问这个程序时，第一个到达服务器的用户服务器可以正常的被处理，但第二个到达服务器的用户只能等待第一个用户访问结束后才能处理第二个用户的处理。假如第一个用户需要处理的任务时间是1小时，那么第二个用户铁定已经点了右上角的叉号了。\n>\n> 另外，第一个用户的任务时长是一小时，那么在处理完这个任务之前是无法给该用户返回消息的，这也就是说该用户只能盯着网页看一个小时才能得到结果，并且中途不会受到任何进度提示，那么铁定第一个用户也在枯燥的等待中点了右上角的叉号。\n>\n> 也就是说没有多线程的服务器程序可以说是什么事情都干不了的\n>\n> 假如我们给每个用户开了2条线程，一条线程用于处理业务，另一条线程用于向用户汇报进度\n>\n> 这样每个用户进入服务器后都会开辟两条线程，第一条线程直接开始任务，一个小时完成，第二条线程告诉用户任务已经开始了，一个小时或一天后来看结果，这样两个用户的任务都完成了，也不会出现第一个用户任务没完成第二个用户只能等待的情况\n\n# 多线程实现\n\n多线程实现由三种方式，分别是继承Thread，实现Runable接口，实现Callable接口三种，每种都有不同的作用\n\n实现Callable接口的实现方式需要线程池实现，所以会在线程池中说明如何使用\n\n## 继承Thread\n\nThread类，位于`java.lang`包下，是Java内置的线程对象，无须导包即可使用\n\n> 举个例子\n>\n> 在2000年左右，中国的汽车进口关税曾经高达230%，相当于你买车是买了两辆半，一辆自己开，剩下的一辆半捐给了国家，当时能够开的起汽车的人是真的富有，国外的汽车厂商看到如此高的关税使得他们的汽车在中国不好卖，又眼馋中国巨大的市场，不得不和中国的企业合作，这也就出现的像一汽大众，长安福特等等的合资企业，这些企业是在国内生产外壳等零部件，只进口发动机，这样车的关税就只有发动机部分的了，这样就降低了价格，让更多人的人能够买上汽车，这也就促进了中国汽车也的发展，使中国能够在起步晚的情况下不至于掉队\n>\n> 回到多线程中，继承Thread的方法相当于是整车进口，可以直接点火启动启动\n>\n> 实现Runable接口的方法相当于是只进口了发动机，还需要再制造外壳\n\n\n\n```java\npublic class TestThread{\n\tpublic static void main(String  [] args){\n\t\tThreadOne t1 = new ThreadOne(); // 创建线程，新生状态(创建状态)，进口整车\n\t\tt1.start();// 启动线程，就绪状态\n    }\n}\nclass ThreadOne extends Thread{\n\t// 第一种实现方式，继承Thread类,实现run方法\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tSystem.out.println(\"第一种线程实现方式\");\n\t\t}\n\t}\n}\n```\n\n## 实现Runable接口\n\nRunable接口是为了弥补在类已经继承了父类，无法继承Thread类时的不足\n\n```java\npublic class TestThread{\n\tpublic static void main(String  [] args){\n\t\tThreadTwo t2 = new ThreadTwo(); // 相当于发动机\n\t\tThread t = new Thread(t2);// 创建外壳，并装上发动机，新生状态(创建状态)\n\t\tt.start();// 启动线程，就绪状态\n    }\n}\nclass ThreadTwo implements Runnable{\n\t// 第二种实现方式，实现Runnable接口，实现run方法\n\t// 相较于第一种，在继承其他类时可以使用该方法\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tSystem.out.println(\"第二种线程实现方式\");\n\t\t}\n\t}\n}\n```\n\n# 线程执行的控制方式\n\n## (setPriority)设置优先级\n\n优先级高的线程有更大的概率获得时间片，而并非优先级高的线程先执行，既然是概率就会有很大的不确定性，谁也无法保证哪个线程先执行\n\n- 1最小，10最大，默认5\n\n```java\nimport java.util.concurrent.*;\npublic class TestThread{\n\tpublic static void main(String  [] args){\n\t\tThreadOne t1 = new ThreadOne(); // 创建线程，新生状态(创建状态)\n\t\tt1.setPriority(10);\n\t\tt1.start();// 启动线程，就绪状态\n\t\tThreadTwo t2 = new ThreadTwo();\n\t\tThreadThree t3 = new ThreadThree();\n\t\tThread t = new Thread(t2);\n\t\tt.setPriority(1);\n\t\tt.start();\n\n\t}\n}\nclass ThreadOne extends Thread{\n\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0; i < 1000; i++){\n\t\t\tSystem.out.println(\"第一种线程实现方式\");\n\t\t}\n\t}\n}\nclass ThreadTwo implements Runnable{\n\t// 第二种实现方式，实现Runnable接口，实现run方法\n\t// 相较于第一种，在继承其他类时可以使用该方法\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0; i < 1000; i++){\n\t\t\tSystem.out.println(\"第二种线程实现方式\");\n\t\t}\n\t}\n}\n```\n\n## sleep(休眠)\n\n休眠指定的毫秒数，休眠是阻塞方法，需要处理异常\n\n```java\npublic class TestSleep{\n\tpublic static void main(String[] args)throws Exception{\n\t\tThreadOne t1 = new ThreadOne();\n\t\tt1.start();\n\t\tThread.sleep(5000);\n\n\t\tfor(int i = 0;i<100;i++){\n\t\t\tSystem.out.println(\"叶莉\");\n\t\t}\n\t}\n}\nclass ThreadOne extends Thread{\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0;i<100;i++){\n\t\t\tSystem.out.println(\"姚明\");\n\t\t}\n\t}\n}\n```\n\n休眠sleep是一个静态方法，也就是说任意一个继承Tread类的实例对象能使用该方法，这就会造成很大的迷惑性例如:\n\n```java\npublic class TestSleep{\n\tpublic static void main(String[] args)throws Exception{\n\t\tThreadOne t1 = new ThreadOne();\n\t\tt1.start();\n\t\tt1.sleep(5000); // 此处做了修改\n\n\t\tfor(int i = 0;i<100;i++){\n\t\t\tSystem.out.println(\"叶莉\");\n\t\t}\n\t}\n}\nclass ThreadOne extends Thread{\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0;i<100;i++){\n\t\t\tSystem.out.println(\"姚明\");\n\t\t}\n\t}\n}\n```\n\n当你执行之后你会发现与之前的代码并无区别，但是我们调用的是`t1.sleep(5000); `，不是应该t1线程休眠5秒吗？\n\n<font color=red>在线程中大部分方法调用并不会看是哪个对象调用的，而是看在哪条线程中调用的</font>\n\n## yield(放弃当前时间片)\n\nyield放弃当前时间片，重新争抢时间片，这种方法与设置优先级类似，对于线程的控制是不确定的，yield方式时间片之后很可能会出现自投自抢的情况\n\n```java\npublic class TestYield{\n\tpublic static void main(String[] args){\n\t\tNumberThread nt = new NumberThread();\n\t\tCharThread ct = new CharThread();\n\t\tnt.start();\n\t\tct.start();\n\t}\n}\nclass NumberThread extends Thread{\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 1;i<=26;i++){\n\t\t\tSystem.out.println(i);\n\t\t\tThread.yield();\n\t\t}\n\t}\n}\nclass CharThread extends Thread{\n\t@Override\n\tpublic void run(){\n\t\tfor(char c = 'a';c<='z';c++){\n\t\t\tSystem.out.println(c);\n\t\t\tThread.yield();\n\t\t}\n\t}\n}\n```\n\n执行完上面的代码会发现，并不是`1a2b3c`这种交替执行的，可能会出现某条线程多次执行的情况\n\n## join\n\njoin方法所在的线程会邀请执行join方法的线程优先执行，被邀请的线程未执行完之前邀请的线程不会执行\n\n这种方法使用于A线程会生成数据，这些数据是B线程执行所必须的数据，这时候可以在B线程中邀请A线程先执行，当A线程执行完毕后生成的数据用于B线程的执行\n\n```java\npublic class TestJoin{\n\tpublic static void main(String[] args)throws Exception{\n\t\tMyThread mt = new MyThread();\n\t\tmt.start();\n\n\t\t//当前线程(主线程)邀请调用方法的线程(mt)优先执行\n\t\tmt.join();\n\n\t\tfor(int i = 0;i<100;i++){\n\t\t\tSystem.out.println(\"梦回吹角连营\");\n\t\t}\n\t}\n}\nclass MyThread extends Thread{\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0;i<100;i++){\n\t\t\tSystem.out.println(\"醉里挑灯看剑\");\n\t\t}\n\t}\n}\n```\n\n# 线程常用的方法\n\n## getName()和setName()\n\n用于设置和获取线程的名字，用于区分不同线程\n\n```java\npublic class TestSetNameAndGetName{\n\tpublic static void main(String[] args){\n\t\tStudent s1 = new Student(\"刘玄德\",777,\"雌雄双股剑\");\n\t\tStudent s2 = new Student(\"关云长\",666,\"青龙偃月刀\");\n\t\tStudent s3 = new Student(\"张翼德\",555,\"AK47\");\n\t\ts1.start();\n\t\ts2.start();\n\t\ts3.start();\n\t}\n}\n\nclass Student extends Thread{\n\tint num;\n\tString weapon;\n\tpublic Student(String name,int num,String weapon){\n\t\tsetName(name);//调用父类继承来的设置名字的方法\n\t\tthis.num = num;\n\t\tthis.weapon = weapon;\n\t}\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0;i<num;i++){\n\t\t\tSystem.out.println(\"我叫\"+getName()+\" 手持\"+weapon);\n\t\t}\n\t}\n}\n```\n\n## activeCount\n\n用于获取当先活跃线程数量，包括主线程\n\n活跃线程：除去新生状态和消亡状态的线程，其他都是活跃状态\n\n```java\npublic class TestActiveCount{\n\tpublic static void main(String[] args){\n\t\tint x = (int)(Math.random()*5)+5;//5-9\n\t\tfor(int i = 0;i<x;i++){\n\t\t\tnew MyThread().start();\n\t\t}\n\t\twhile(true){\n\t\t\tSystem.out.println(Thread.activeCount());\n\t\t}\n\t}\n}\nclass MyThread extends Thread{\n\t@Override\n\tpublic void run(){\n\t\tfor(int i = 0;i<100;i++){\n\t\t\ttry{\n\t\t\t\tThread.sleep(1000);\n\t\t\t}catch(Exception e){\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t}\n\t}\n}\n```\n\n## setDaemon\n\n设置守护线程，守护线程：在非守护线程全部执行完毕后自动消亡\n\n> 守护线程应该具备的条件\n>\n> - 应该是无限循环，防止过早消亡\n> - 应该设置最低优先级，防止与业务逻辑争抢资源\n> - 设置守护线程必须在其线程启动之前\n\n```java\npublic class TestSetDaemon{\n\tpublic static void main(String[] args){\n\t\tGYJJ gy = new GYJJ();\n\t\t//*:守护线程应该具有最低的优先级 防止其与核心业务争抢资源\n\t\tgy.setPriority(1);\n\t\t//*:它必须早于自身的start()\n\t\tgy.setDaemon(true);\n\t\tgy.start();\n\n\t\tfor(int i = 0;i<1000;i++){\n\t\t\tSystem.out.println(\"西天取经上大路 一走就是几万里\");\n\t\t}\n\t}\n}\nclass GYJJ extends Thread{\n\t@Override\n\tpublic void run(){\n\t\t//*: 守护线程通常都是无限循环 防止其过早消亡\n\t\twhile(true){\n\t\t\tSystem.out.println(\"你这泼猴儿~\");\n\t\t}\n\t}\n}\n```\n\n## interrupt\n\n打断线程的阻塞状态,手动唤醒阻塞的线程\n\n```java\npublic class TestInterrupt{\n\tpublic static void main(String[] args){\n\t\tMyThread mt = new MyThread();\n\t\tmt.start();\n\n\t\t//当前线程(主线程) 中断 调用方法的线程(mt) 的阻塞状态\n\t\tmt.interrupt();\n\t}\n}\nclass MyThread extends Thread{\n\t@Override\n\tpublic void run(){\n\t\ttry{\n\t\t\tThread.sleep(999999999999999L);\n\t\t}catch(Exception e){\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(\"吖！神清气爽吖！\");\n\t}\n}\n```\n\n执行后会输出异常信息，是因为Thread.sleep方法被主线程强制唤醒，sleep方法未能正常执行报的异常，但是因为我们已经捕获了异常，并将异常打印了，并不会影响执行，在正常开发中需要对它进行处理\n\n# 线程状态\n\n![image.png](http://pandacode.xyz/upload/2021/05/image-4e48089a52a94aa4ac45bef7158439f1.png)\n\n# 并发错误及处理\n\n并发错误是一种非常难缠且危险的错误类型，它编译不报错，执行无异常，但是就是数据不对，杀程序员与无形\n\n并发错误出现的根本原因在于多个线程同时操作一份数据或者一个对象\n\n并发错误是一组本应该连续执行的操作，在执行到一半时时间片耗尽，数据被其他线程修改出现的数据不一致\n\n> 并发错误演示\n\n ```java\npublic class TestConcurrentError{\n\tpublic static void main(String[] args){\n\t\tPerson p = new Person(\"梁朝伟\",\"先生\");\n\t\tPrintThread pt = new PrintThread(p);\n\t\tChangeThread ct = new ChangeThread(p);\n\t\tpt.start();\n\t\tct.start();\n\t}\n}\n\nclass PrintThread extends Thread{\n\tPerson p;\n\tpublic PrintThread(Person p){\n\t\tthis.p = p;\n\t}\n\t@Override\n\tpublic void run(){\n\t\twhile(true){\n\t\t\tSystem.out.println(p.name + \" : \" + p.gender);\n\t\t}\n\t}\n}\nclass ChangeThread extends Thread{\n\tPerson p;\n\tpublic ChangeThread(Person p){\n\t\tthis.p = p;\n\t}\n\t@Override\n\tpublic void run(){\n\t\tboolean isOkay = true;\n\t\twhile(true){\n\n\t\t\tif(isOkay){\n\t\t\t\tp.name = \"张曼玉\";\n\t\t\t\tp.gender = \"女士\";\n\t\t\t}else{\n\t\t\t\tp.name = \"梁朝伟\";\n\t\t\t\tp.gender = \"先生\";\n\t\t\t}\n\t\t\tisOkay = !isOkay;\n\t\t}\n\t}\n}\nclass Person{\n\tString name;\n\tString gender;\n\tpublic Person(String name,String gender){\n\t\tthis.name = name;\n\t\tthis.gender = gender;\n\t}\n}\n\n ```\n\n 在上面的程序执行过程中，你会发现有时会打印`梁朝伟：女士`，`张曼玉：先生`，这就是并发错误造成的\n\n\n\n解决并发错误的方法就两个字：<font color=red>加锁</font>，所有要使用某个数据的线程都约定好一个锁，谁拿到了锁标记，谁有执行权限，没有锁标记的线程进入锁池，等待锁标记的归还\n\n## synchronized\n\nsynchronized 是java内置的加锁方式，它有两种使用方式，一种是直接指定对某个对象加锁，也就是下面代码使用的方式；另一种是在方法体上作为修饰符使用，改方法实际上是对调用该方法的对象加锁，也就是this锁\n\n```java\npublic class TestConcurrentError{\n\tpublic static void main(String[] args){\n\t\tPerson p = new Person(\"梁朝伟\",\"先生\");\n\t\tPrintThread pt = new PrintThread(p);\n\t\tChangeThread ct = new ChangeThread(p);\n\t\tpt.start();\n\t\tct.start();\n\t}\n}\n\nclass PrintThread extends Thread{\n\tPerson p;\n\tpublic PrintThread(Person p){\n\t\tthis.p = p;\n\t}\n\t@Override\n\tpublic void run(){\n\t\twhile(true){\n\t\t\tsynchronized(p){\n\t\t\t\tSystem.out.println(p.name + \" : \" + p.gender);\n\t\t\t}\n\n\t\t}\n\t}\n}\nclass ChangeThread extends Thread{\n\tPerson p;\n\tpublic ChangeThread(Person p){\n\t\tthis.p = p;\n\t}\n\t@Override\n\tpublic void run(){\n\t\tboolean isOkay = true;\n\t\twhile(true){\n\t\t\tsynchronized(p){\n\t\t\t\tif(isOkay){\n\t\t\t\t\tp.name = \"张曼玉\";\n\t\t\t\t\tp.gender = \"女士\";\n\t\t\t\t}else{\n\t\t\t\t\tp.name = \"梁朝伟\";\n\t\t\t\t\tp.gender = \"先生\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tisOkay = !isOkay;\n\n\t\t}\n\t}\n}\nclass Person{\n\tString name;\n\tString gender;\n\tpublic Person(String name,String gender){\n\t\tthis.name = name;\n\t\tthis.gender = gender;\n\t}\n}\n```\n\n## ReentrantLock\n\n可重入锁，用面向对象思想实现的加锁方式\n\n使用之前需要导入java.util.concurrent.locks.ReentrantLock包\n\n该方法因为是使用面向对象思想创建的，所以更容易扩展\n\n同时该方法还支持公平锁和非公平锁\n\n公平锁：按照线程的先来后到给锁标记，需要多加一个队列，更加消耗资源\n\n非公平锁：所以线程在锁标记归还时争抢锁\n\n- 默认是非公平锁\n\n```java\nimport java.util.concurrent.locks.ReentrantLock;\npublic class TestConcurrentError{\n\tpublic static void main(String[] args){\n\t\tReentrantLock lock = new ReentrantLock();\n\t\tPerson p = new Person(\"梁朝伟\",\"先生\");\n\t\tPrintThread pt = new PrintThread(p,lock);\n\t\tChangeThread ct = new ChangeThread(p,lock);\n\t\tpt.start();\n\t\tct.start();\n\t}\n}\n\nclass PrintThread extends Thread{\n\tReentrantLock lock;\n\tPerson p;\n\tpublic PrintThread(Person p,ReentrantLock lock){\n\t\tthis.p = p;\n\t\tthis.lock = lock;\n\t}\n\t@Override\n\tpublic void run(){\n\t\twhile(true){\n\t\t\tlock.lock();\n\t\t\tSystem.out.println(p.name + \" : \" + p.gender);\n\t\t\tlock.unlock();\n\n\t\t}\n\t}\n}\nclass ChangeThread extends Thread{\n\tReentrantLock lock;\n\tPerson p;\n\tpublic ChangeThread(Person p,ReentrantLock lock){\n\t\tthis.p = p;\n\t\tthis.lock = lock;\n\t}\n\t@Override\n\tpublic void run(){\n\t\tboolean isOkay = true;\n\t\twhile(true){\n\t\t\tlock.lock();\n\t\t\tif(isOkay){\n\t\t\t\tp.name = \"张曼玉\";\n\t\t\t\tp.gender = \"女士\";\n\t\t\t}else{\n\t\t\t\tp.name = \"梁朝伟\";\n\t\t\t\tp.gender = \"先生\";\n\t\t\t}\n\t\t\tlock.unlock();\n\t\t\tisOkay = !isOkay;\n\n\t\t}\n\t}\n}\nclass Person{\n\tString name;\n\tString gender;\n\tpublic Person(String name,String gender){\n\t\tthis.name = name;\n\t\tthis.gender = gender;\n\t}\n}\n```\n\n## 死锁\n\n死锁是加锁过多或者加锁不当造成的，互相持有对方想要的资源不愿放弃，同时又想要对方手里的资源的情况，这种情况就会造成程序的卡死\n\n> 死锁问题演示\n>\n> 刘总和安总上班都需要经过泉城路，一个从东侧进入泉城路，一个从西侧进入泉城路，两人都想去到对方的位置，但是都不想放弃现在的位置，两个人就在这耗着谁也走不了，这就会造成死锁\n\n ```java\npublic class TestDeadLock{\n\tpublic static void main(String[] args){\n\t\tQCRoad r = new QCRoad();\n\t\tQCRoad.Benz s900 = r.new Benz();\n\t\tQCRoad.Bmw x9 = r.new Bmw();\n\t\ts900.start();\n\t\tx9.start();\n\t}\n}\nclass QCRoad{\n\tObject east = new Object();//路东资源\n\tObject west = new Object();//路西资源\n\n\tclass Benz extends Thread{\n\t\t@Override\n\t\tpublic void run(){\n\t\t\tSystem.out.println(\"安总驾驶奔驰驶出家门去上课\");\n\t\t\tsynchronized(east){\n\t\t\t\tSystem.out.println(\"安总和他的奔驰占领了泉城路东侧\");\n\t\t\t\tsynchronized(west){\n\t\t\t\t\tSystem.out.println(\"安总和他的奔驰又占领了泉城路西侧\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"安总顺利的通过了泉城路~\");\n\t\t}\n\t}\n\tclass Bmw extends Thread{\n\t\t@Override\n\t\tpublic void run(){\n\t\t\tSystem.out.println(\"刘总驾驶宝马驶出家门去上课\");\n\t\t\tsynchronized(west){\n\t\t\t\tSystem.out.println(\"刘总和他的宝马已经占领泉城路西侧\");\n\t\t\t\tsynchronized(east){\n\t\t\t\t\tSystem.out.println(\"刘总和他的宝马又占领了泉城路东侧\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"刘总顺利的通过了泉城路~\");\n\t\t}\n\t}\n}\n ```\n\n 上面的程序多数情况下会是死锁，只有在一方线程启动较晚的时候会出现正常执行，可以理解为刘总或者安总起晚了，已经走过泉城路了对方还没来\n\n\n\n\n\n> 解决死锁问题\n>\n> 解决死锁问题其实非常简单，安总或者刘总一方把路让出来就可以了，比如安总把车开到了小胡同里，让出了自己这一侧的路，让刘总先通过，然后在刘总通过后再从互通里出来通过泉城路\n\n ```java\npublic class TestDeadLock{\n\tpublic static void main(String[] args){\n\t\tQCRoad r = new QCRoad();\n\t\tQCRoad.Benz s900 = r.new Benz();\n\t\tQCRoad.Bmw x9 = r.new Bmw();\n\t\ts900.start();\n\t\tx9.start();\n\t}\n}\nclass QCRoad{\n\tObject east = new Object();//路东资源\n\tObject west = new Object();//路西资源\n\n\tclass Benz extends Thread{\n\t\t@Override\n\t\tpublic void run(){\n\t\t\tSystem.out.println(\"安总驾驶奔驰驶出家门去上课\");\n\t\t\tsynchronized(east){\n\t\t\t\tSystem.out.println(\"安总和他的奔驰占领了泉城路东侧\");\n\n\t\t\t\ttry{\n\t\t\t\t\teast.wait();\n\t\t\t\t}catch(Exception e){\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tsynchronized(west){\n\t\t\t\t\tSystem.out.println(\"安总和他的奔驰又占领了泉城路西侧\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"安总顺利的通过了泉城路~\");\n\t\t}\n\t}\n\tclass Bmw extends Thread{\n\t\t@Override\n\t\tpublic void run(){\n\t\t\tSystem.out.println(\"刘总驾驶宝马驶出家门去上课\");\n\t\t\tsynchronized(west){\n\t\t\t\tSystem.out.println(\"刘总和他的宝马已经占领泉城路西侧\");\n\t\t\t\tsynchronized(east){\n\t\t\t\t\tSystem.out.println(\"刘总和他的宝马又占领了泉城路东侧\");\n\t\t\t\t\teast.notify();//从east对象的等待池当中随机的唤醒一个线程\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"刘总顺利的通过了泉城路~\");\n\t\t}\n\t}\n}\n ```\n\n 上面安总代码中使用到wait方法就是让出自己占有的资源，让其他线程优先使用，自已让出来后需要进入“小胡同”这个小胡同在并发处理中被称为等待池，而刘总代码中使用的notify方法是通知安总已经用完资源了，可以出来了，也就是将其从等待池中唤醒\n\n解决死锁问题共计需要\n\n- 一块空间：对象的等待池；\n\n- 三个方法：\n  - wait 等待；\n  - notify通知随机一个线程资源已经被释放；\n  - notifyAll通知等待池中的全部线程资源已经被释放\n\n\n\n# 线程池\n\n> 什么是线程池？\n>\n> 线程可以生命周期可以分为创建线程、执行核心业务、销毁线程三部分\n>\n> 当一个线程的核心业务在这三部分中占比很小的时候，创建线程和销毁线程会花费大量的时间，但是这部分时间是毫无意义的，这就会造成资源大量的浪费，在程序需要服务的客户数量较少时，这部分资源的浪费体现并不明显，但是当用户数量不断上升时，这部分浪费的资源也会随之增加，这部分资源的浪费就会越发明显\n>\n> 举个例子\n>\n> 我们在家吃饭时情况与上述的问题是十分相似的，我们的核心业务是吃饭，但是饭不是凭空生成的，我们就需要做饭，这就相当于创建线程，做饭可能需要半小时，吃饭可能只需要10分钟，这是核心业务，吃完饭之后需要刷碗，这相当于销毁线程，这可能又需要10分钟，我们的核心业务吃饭在整个任务中只占了10分钟，创建和销毁线程需要40分钟，这就存在大量的资源浪费\n>\n> 线程池就相当于我们去下馆子，做饭和刷碗的事情不归我们管了，我们的核心业务吃饭从原来的50分钟，降低到了10分钟，剩下的40分钟并非消失了，而是都由饭店来帮我处理了，线程池的作用就和饭店是类似的。虽然总时间是相同的，但是用户在体验上得到了大幅度优化。\n>\n> 线程池把影响用户体验但实际上占用的时间与核心业务无关的创建和销毁线程的动作给接管了，我们不在需要创建和销毁线程\n\n## Callable接口\n\n多线程实现的前两种方式都可以使用线程池来实现，但是前两种方式存在很大的局限性，当线程中处理的数据需要返回结果时，前两种方法时无法实现的，并且这两种方式都无法在线程内抛出异常，强迫程序员必须处理异常。\n\nCallable接口可以有返回值，并且能够抛出异常这就弥补了前面两种创建线程的不足，但是Callable接口也是存在局限性的，前两种实现方式是可以直接创建线程的，但是Callable接口是不能直接创建线程，Callable接口需要借助线程池来实现\n\n\n\n## 修复后可重用的线程池\n\nExecutors.newFixedThreadPool\n\nExecutors(执行器)是线程池的工具类，其中的newFixedThreadPool是修复后可重用的线程池，该方法接收一个参数，改参数表示要在线程池中预先创建多少个线程，被创建的线程数在线程池关闭前不会销毁，而是每次提交一个任务则分配一个线程给任务使用，当任务执行完毕后，线程不会销毁，而是归还线程池等待下一个任务的提交，当线程池中的线程全部被耗尽后，其他提交的线程会被存放在一个容器中，等待有空余线程时执行。\n\n这种线程池可以很好的应对用户数量很稳定不会出现像双十一这种用户数量大幅度增长的情况。\n\n```java\nimport java.util.concurrent.*;\npublic class TestThreadPool1{\n\tpublic static void main(String [] args){\n        // 创建一个有3条线程的线程池\n\t\tExecutorService es = Executors.newFixedThreadPool(3); \n\t\tCallableThread ct = new CallableThread(); // 创建Callable对象\n\t\tes.submit(ct); // 提交任务\n\t\tes.shutdown(); // 关闭线程池\n\t}\n}\nclass CallableThread implements Callable<String> { // 泛型定义返回值\n\t@Override\n\tpublic String call() throws Exception{ // 可以抛出异常\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tSystem.out.println(\"Callable 线程\");\n\t\t}\n\t\treturn \"call\"; // 返回值\n\t}\n}\n```\n\n## 缓存机制的线程池\n\nExecutors工具类下的newCachedThreadPool是缓存机制的线程池，该线程池能够动态的控制线程池内的线程数量，newCachedThreadPool创建线程的规则是当有一个用户向线程池提交任务时，线程池内没有可用的线程则创建一个线程，这条线程在完成当前用户的任务后会存活60秒，如果这60秒之内有新的任务提交到线程池中则直接给用户分配该线程，如果在完成任务60秒之内没有新的任务提交到线程池则销毁该线程。\n\n这种线程池可以应对双十一这种在某一时间段并发量会大幅度波动的情况。\n\n```java\nimport java.util.concurrent.*;\npublic class TestThreadPool1{\n\tpublic static void main(String [] args){\n\t\tExecutorService es = Executors.newCachedThreadPool(); \n\t\tCallableThread ct1 = new CallableThread(\"1\"); // 创建Callable对象\n\t\tCallableThread ct2 = new CallableThread(\"2\"); // 创建Callable对象\n\t\tCallableThread ct3 = new CallableThread(\"3\"); // 创建Callable对象\n\t\tes.submit(ct1); // 提交任务\n\t\tes.submit(ct2); // 提交任务\n\t\tes.submit(ct3); // 提交任务\n\t\t\n\t\tes.shutdown(); // 关闭线程池\n\t}\n}\nclass CallableThread implements Callable<String> { // 泛型定义返回值\n\tString name;\n\tpublic CallableThread(String name){\n\t\tthis.name = name;\n\t}\n\t@Override\n\tpublic String call() throws Exception{ // 可以抛出异常\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tSystem.out.println(\"Callable 线程\" + name);\n\t\t}\n\t\treturn \"call\"; // 返回值\n\t}\n}\n```\n\n## 单一线程执行器\n\nExecutors.newSingleThreadExecutor\n\n实际上他并不是线程池，他相当于是在程序中修了一座独木桥，只允许一个线程通过\n\n利用这种机制可以实现像商品秒杀这种只用固定几个线程能够抢到执行权限的应用场景\n\n```java\nimport java.util.concurrent.*;\npublic class TestThreadPool1{\n\tpublic static void main(String [] args){\n\t\tExecutorService es = Executors.newSingleThreadExecutor(); \n\t\tCallableThread ct1 = new CallableThread(\"1\"); // 创建Callable对象\n\t\tCallableThread ct2 = new CallableThread(\"2\"); // 创建Callable对象\n\t\tCallableThread ct3 = new CallableThread(\"3\"); // 创建Callable对象\n\t\tes.submit(ct1); // 提交任务\n\t\tes.submit(ct2); // 提交任务\n\t\tes.submit(ct3); // 提交任务\n\t\t\n\t\tes.shutdown(); // 关闭线程池\n\t}\n}\nclass CallableThread implements Callable<String> { // 泛型定义返回值\n\tString name;\n\tpublic CallableThread(String name){\n\t\tthis.name = name;\n\t}\n\t@Override\n\tpublic String call() throws Exception{ // 可以抛出异常\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tSystem.out.println(\"Callable 线程\" + name);\n\t\t}\n\t\treturn \"call\"; // 返回值\n\t}\n}\n```\n\n## 线程池两种关闭方式的区别\n\n- shutdown ： 不再接收新任务的提交，但已经提交的任务会被执行，正在执行的任务也不会被终止\n- shutdownNow ：不再接收新任务的提交，已经提交的任务也不会被执行，但是已经开始的任务不会被终止\n\n## 线程池源码分析\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n```\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n```\n\n通过查看源码，我们可以发现，这三种线程池的本质都是创建了一个ThreadPoolExecutor类的对象\n\n该对象的构造函数的参数代表的意思分别为\n\n- 线程池内线程最低个数\n- 线程池内线程最大个数\n- 线程存活时间\n- 线程存活时间的单位\n- 用于存储任务的队列\n  - 只有当线程池内没有可以执行当前任务的线程时才会存入队列等待执行\n\n",
    type: "Java",
    tag: [
        "Java基础"
    ],
    hit: NumberLong("1"),
    createDate: ISODate("2022-05-11T10:30:11.211Z"),
    modifyDate: ISODate("2022-05-11T10:30:11.211Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627b90b31947aa32e2a4beb9"),
    title: "Spring Boot",
    content: "<p>一 、环境配置</p>\n<h2 class=\"markdown-h2\">JDK</h2>\n<p>版本要求：1.8+</p>\n<h2 class=\"markdown-h2\">Maven</h2>\n<p>版本要求：3.3+</p>\n<p>配置文件：<code class=\"markdown-linecode\">maven安装路径/conf/setting.xml</code></p>\n<ul class=\"markdown-list\">\n<li>\n<p>镜像设置为阿里云镜像，加快依赖下载速度</p>\n<pre><code class=\"language-xml\">&lt;mirrors&gt;\n    &lt;!-- 配置阿里云镜像 --&gt;\n    &lt;mirror&gt;\n        &lt;id&gt;aliyunmaven&lt;/id&gt;\n        &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\n        &lt;name&gt;阿里云公共仓库&lt;/name&gt;\t             \n        &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;\n    &lt;/mirror&gt;\n&lt;/mirrors&gt;\n</code></pre>\n</li>\n<li>\n<p>配置项目以java1.8编译，因为springboot2.0+要求最低版本java8，固定配置防止错误</p>\n<pre><code class=\"language-xml\">&lt;profiles&gt;\n\t&lt;profile&gt;\n\t\t&lt;id&gt;jdk-1.8&lt;/id&gt;\n\n\t\t&lt;activation&gt;\n\t\t\t&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;\n\t\t\t&lt;jdk&gt;1.8&lt;/jdk&gt;\n\t\t&lt;/activation&gt;\n\n\t\t&lt;properties&gt;\n\t\t\t&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;\n\t\t\t&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;\n\t\t\t&lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;\n\t\t&lt;/properties&gt;\n\t&lt;/profile&gt;\n&lt;/profiles&gt;\n</code></pre>\n</li>\n</ul>\n<h1 class=\"markdown-h1\">二、创建项目</h1>\n<h2 class=\"markdown-h2\">1.Spring initializr</h2>\n<ul class=\"markdown-list\">\n<li><a href=\"https://start.spring.io/\" target=\"_blank\">官网生成</a></li>\n<li>IDEA</li>\n</ul>\n<h2 class=\"markdown-h2\">2.手动创建</h2>\n<ol class=\"markdown-list\">\n<li>\n<p>创建Maven项目</p>\n</li>\n<li>\n<p>修改pom文件</p>\n<ul class=\"markdown-list\">\n<li>\n<p><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started-first-application-pom\" target=\"_blank\">官方文档地址</a></p>\n</li>\n<li>\n<pre><code class=\"language-xml\">&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n    &lt;version&gt;2.3.3.RELEASE&lt;/version&gt;\n&lt;/parent&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>创建web路由处理类</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-java\">import org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class Testcontroller {\n\n    @RequestMapping(&quot;/&quot;)\n    public String test(){\n        return &quot;Hello Spring Boot&quot;;\n    }\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>创建启动类</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-java\">@SpringBootApplication\npublic class MainApplication {\n    public static void main(String[] args) {\n\t\tSpringApplication.run(MainApplication.class, args);\n    }\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>创建完成</p>\n</li>\n<li>\n<p>运行项目</p>\n</li>\n</ol>\n<h1 class=\"markdown-h1\">三、打包成jar包</h1>\n<p>不同于之前的SSM框架时需要将项目打包成war包，SpringBoot可以直接将项目打包成jar包</p>\n<p>jar包中自带了tomcat服务器，不需要再部署Tomcat服务器</p>\n<ol class=\"markdown-list\">\n<li>\n<p>导入插件</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-xml\">&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;!--将spring boot 项目打包成jar包--&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>Maven工具打包</p>\n<ul class=\"markdown-list\">\n<li>\n<p><img src=\"Spring%20Boot.assets/image-20210820160714925.png\" alt=\"image-20210820160714925\" /></p>\n</li>\n<li>\n<p><img src=\"Spring%20Boot.assets/image-20210820160850313.png\" alt=\"image-20210820160850313\" /></p>\n</li>\n</ul>\n</li>\n<li>\n<p>命令行打包</p>\n<ul class=\"markdown-list\">\n<li>\n<p>执行命令</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-shell\">mvn package#打包主项目\nmvn -f [子项目] clean package#打包子项目\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>在target目录下会生成jar包</p>\n</li>\n</ul>\n</li>\n<li>\n<p>执行jar包</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-shell\">java -jar [包名]\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h1 class=\"markdown-h1\">四、简单自动配置原理</h1>\n<h2 class=\"markdown-h2\">1.依赖管理</h2>\n<p>当我们在项目中引入<code class=\"markdown-linecode\">mysql</code>的依赖时</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>可以看到依赖中并没有指明版本号，这是因为SpringBoot的依赖管理起到了作用</p>\n<p>在项目中的<code class=\"markdown-linecode\">pom.xml</code>中依赖了一个父项目</p>\n<pre><code class=\"language-xml\">&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n    &lt;version&gt;2.3.3.RELEASE&lt;/version&gt;\n&lt;/parent&gt;\n</code></pre>\n<p>在<code class=\"markdown-linecode\">spring-boot-starter-parent</code>又有一个父项目</p>\n<pre><code class=\"language-xml\">&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;\n    &lt;version&gt;2.3.3.RELEASE&lt;/version&gt;\n&lt;/parent&gt;\n</code></pre>\n<p>在<code class=\"markdown-linecode\">spring-boot-dependencies</code>中定义了几乎所有常用的依赖的版本号，下面以mysql为例</p>\n<p><img src=\"Spring%20Boot.assets/image-20210820162107959.png\" alt=\"image-20210820162107959\" /></p>\n<p><img src=\"Spring%20Boot.assets/image-20210820162046182.png\" alt=\"image-20210820162046182\" /></p>\n<p>mysql的版本已经在<code class=\"markdown-linecode\">spring-boot-dependencies</code>中指定了，这里指定的版本被称为SpringBoot的仲裁版本，这种机制被称为<code class=\"markdown-linecode\">SpringBoot自动版本仲裁机制</code></p>\n<p>mysql的版本并不是固定写死的，而是通过配置项的方式写入的</p>\n<p>在我们想要使用指定版本的依赖，不想使用<code class=\"markdown-linecode\">SpringBoot仲裁的版本号</code>时，可以在<code class=\"markdown-linecode\">pom.xml</code>中指定自己想要的版本号</p>\n<pre><code class=\"language-xml\">&lt;properties&gt;\n    &lt;mysql.version&gt;8.0.26&lt;/mysql.version&gt;\n&lt;/properties&gt;\n</code></pre>\n<p><img src=\"Spring%20Boot.assets/image-20210820163030549.png\" alt=\"image-20210820163030549\" /></p>\n<p>==需要注意的是：在我们引入官方未定义的jar包时就必须的声明版本号了==</p>\n<h2 class=\"markdown-h2\">2.场景启动器（starter）</h2>\n<p>在我们启动SpringBoot项目后，我们的<code class=\"markdown-linecode\">pom.xml</code>中并未手动引入<code class=\"markdown-linecode\">SpringMVC</code>相关的依赖，但是我们能够使用它的所有功能，这就受益于SpringBoot的启动器</p>\n<p>在<code class=\"markdown-linecode\">pom.xml</code>中我们引入了这个依赖</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>这个依赖就是SpringBoot的启动器，<code class=\"markdown-linecode\">spring-boot-starter-web</code>这个启动器包含了Web开发中所有常规的依赖，不需要手动引入依赖，SpringBoot已经帮我们引入好了</p>\n<p>SpringBoot有非常多的启动器，官方的启动器都有统一的命名规则:<code class=\"markdown-linecode\">spring-boot-starter-*</code>,其中的<code class=\"markdown-linecode\">*</code>代表的各种开发场景，详细的启动器可以参考官方文档：https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters</p>\n<p>SpringBoot不仅可以使用官方定义的启动器，也可以自定义启动器</p>\n<h2 class=\"markdown-h2\">3.自动配置</h2>\n<h3 class=\"markdown-h3\">功能配置</h3>\n<p>在SpringBoot的<code class=\"markdown-linecode\">spring-boot-starter-web</code>中，项目可以直接运行，无须配置<code class=\"markdown-linecode\">dispatcherServlet</code>来接请求，同时项目是可以直接输出中文的，你可以将<code class=\"markdown-linecode\">Testcontroller</code>类中的返回文本中加入中文，并不会出现乱码问题，这是因为SpringBoot已经将SpringMVC中常用的功能自动配置好了，我们可以通过下面的代码来查看自动配置了哪些功能</p>\n<pre><code class=\"language-java\">@SpringBootApplication\npublic class MainApplication {\n    public static void main(String[] args) {\n        // 获取上下文对象，也就是IOC容器\n        ConfigurableApplicationContext applicationContext = SpringApplication.run(MainApplication.class, args);\n        // 可以通过getBeanDefinitionNames来获取容器里面的组件名\n        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();\n        for (String beanDefinitionName : beanDefinitionNames) {\n            System.out.println(beanDefinitionName);\n        }\n    }\n}\n</code></pre>\n<p>可以在输出结果中搜索<code class=\"markdown-linecode\">dispatcherServlet</code></p>\n<p><img src=\"Spring%20Boot.assets/image-20210821132514870.png\" alt=\"image-20210821132514870\" /></p>\n<p>像<code class=\"markdown-linecode\">characterEncodingFilter</code>等SpringMVC的常用配置也已经存在于IOC容器中，已经由SpringBoot自动配置完成</p>\n<h3 class=\"markdown-h3\">自动包扫描</h3>\n<p>SpringBoot不需要配置包扫描，SpringBoot会自动扫描<code class=\"markdown-linecode\">启动类所在的包及其子包</code></p>\n<pre><code>com\n +- example\n     +- myapplication\n         +- MyApplication.java\n         |\n         +- customer\n         |   +- Customer.java\n         |   +- CustomerController.java\n         |   +- CustomerService.java\n         |   +- CustomerRepository.java\n         |\n         +- order\n             +- Order.java\n             +- OrderController.java\n             +- OrderService.java\n             +- OrderRepository.java\n</code></pre>\n<ul class=\"markdown-list\">\n<li>改变扫描路径<code class=\"markdown-linecode\">@SpringBootApplication(scanBasePackages = {&quot;xyz.pandacode&quot;})</code></li>\n</ul>\n<h1 class=\"markdown-h1\">五、自动装配所需技术</h1>\n<h2 class=\"markdown-h2\">1.配置类</h2>\n<pre><code class=\"language-java\">public class Pet {\n    private String name;\n    public Pet() {\n    }\n    public Pet(String name) {\n        this.name = name;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    @Override\n    public String toString() {\n        return &quot;Pet{&quot; +\n                &quot;name='&quot; + name + '\\'' +\n                '}';\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">/**\n * 注解 @Configuration 用于指明当前类为配置类，相当于之前的beans.xml\n * 其中的 proxyBeanMethods参数 用于指定是否使用代理方式返回配置类对象，默认为true\n * 也就是在调用配置类对象时，调用其中的方法创建的对象也是单实例的\n *\n * proxyBeanMethods用于处理组件依赖问题\n * Full：proxyBeanMethods = true\n * Lite：proxyBeanMethods = false\n */\n@Configuration\npublic class MyConfigClass {\n    /**\n     * 注解 @Bean 表示使用当前方法创建一个Bean\n     * 默认为方法名作为Bean的名字\n     * 可以使用@Bean的默认参数指定Bean名字\n     * @return 返回Bean对象，交给IOC容器，创建的对象时单实例的\n     */\n    @Bean\n    public Pet pet(){\n        return new Pet(&quot;TomCat&quot;);\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">@SpringBootApplication\npublic class MainApplication {\n    public static void main(String[] args) {\n        // 获取上下文对象，也就是IOC容器\n        ConfigurableApplicationContext applicationContext = SpringApplication.run(MainApplication.class, args);\n\n        // 获取配置类配置的Bean\n        Pet pet = applicationContext.getBean(&quot;pet&quot;, Pet.class);\n        System.out.println(&quot;pet Bean：&quot;+pet);\n\n        // 验证配置类的Bean是否为单实例\n        Pet pet1 = applicationContext.getBean(&quot;pet&quot;, Pet.class);\n        Pet pet2 = applicationContext.getBean(&quot;pet&quot;, Pet.class);\n        System.out.println(&quot;是否为单实例：&quot;+(pet1 == pet2));\n\n        // 验证配置类是否为组件\n        MyConfigClass myConfigClass = applicationContext.getBean(MyConfigClass.class);\n        System.out.println(&quot;配置类对象：&quot;+myConfigClass);\n\n        // 验证调用配置类方法是否为单实例对象\n        Pet pet3 = myConfigClass.pet();\n        Pet pet4 = myConfigClass.pet();\n        System.out.println(&quot;配置类创建是否为单实例：&quot;+(pet3 == pet4));\n    }\n}\n</code></pre>\n<h2 class=\"markdown-h2\">2.条件装配</h2>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">@Conditional</code></p>\n<p><img src=\"Spring%20Boot.assets/image-20210821143205214.png\" alt=\"image-20210821143205214\" /></p>\n</blockquote>\n<pre><code class=\"language-java\">@Configuration\npublic class MyConfigClass {\n\n\t// 此处将user方法的@Bean注释，清除IOC中的user组件\n    //@Bean\n    public User user(){\n        return new User(&quot;张三&quot;,18);\n    }\n    \n    // 在类中的顺序也会影响@Conditional的结果\n    @ConditionalOnBean(name = &quot;user&quot;) // 当容器中有name=&quot;user&quot;的组件才加载\n    @Bean\n    public Pet pet(){\n        return new Pet(&quot;TomCat&quot;);\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\">@SpringBootApplication\npublic class MainApplication {\n    public static void main(String[] args) {\n        // 1.获取上下文对象，也就是IOC容器\n        ConfigurableApplicationContext applicationContext = SpringApplication.run(MainApplication.class, args);\n\n        // 验证装配\n        boolean user = applicationContext.containsBean(&quot;user&quot;);\n        boolean pet = applicationContext.containsBean(&quot;pet&quot;);\n        System.out.println(&quot;user:&quot;+user);\n        System.out.println(&quot;pet:&quot;+pet);\n    }\n}\n</code></pre>\n<p>此时的结果为：</p>\n<pre><code>user:false\npet:false\n// 两者皆未装配\n</code></pre>\n<p>将<code class=\"markdown-linecode\">MyConfigClass</code>中的user方法的<code class=\"markdown-linecode\">@Bean</code>注解取消注释后,结果为：</p>\n<pre><code>\n</code></pre>\n<h2 class=\"markdown-h2\">3.将xml配置引入配置类</h2>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;\n    &lt;bean id=&quot;user01&quot; class=&quot;xyz.pandacode.bean.User&quot;&gt;\n        &lt;property name=&quot;name&quot; value=&quot;李四&quot;/&gt;\n        &lt;property name=&quot;age&quot; value=&quot;19&quot;/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n<pre><code class=\"language-java\">package xyz.pandacode.config;\n\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.ImportResource;\nimport xyz.pandacode.bean.Pet;\nimport xyz.pandacode.bean.User;\n\n/**\n * 注解 @Configuration 用于指明当前类为配置类，相当于之前的beans.xml\n * 其中的 proxyBeanMethods参数 用于指定是否使用代理方式返回配置类对象，默认为true\n * 也就是在调用配置类对象时，调用其中的方法创建的对象也是单实例的\n *\n * proxyBeanMethods用于处理组件依赖问题\n * Full：proxyBeanMethods = true\n * Lite：proxyBeanMethods = false\n */\n@Configuration\n@ImportResource(&quot;classpath:beans.xml&quot;)\npublic class MyConfigClass {\n}\n</code></pre>\n<pre><code class=\"language-java\">@SpringBootApplication\npublic class MainApplication {\n    public static void main(String[] args) {\n        // 1.获取上下文对象，也就是IOC容器\n        ConfigurableApplicationContext applicationContext = SpringApplication.run(MainApplication.class, args);\n\n        // 5.验证xml转配置类\n        boolean user01 = applicationContext.containsBean(&quot;user01&quot;);\n        System.out.println(&quot;xml转配置类：&quot;+user01);\n\n    }\n}\n</code></pre>\n<h2 class=\"markdown-h2\">4.配置绑定</h2>\n<p>application.properties</p>\n<pre><code class=\"language-properties\">car.name=BYD\ncar.price=100000\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">@ConfigurationProperties</code></p>\n<p>此注解的value属性和prefix为同一值</p>\n<p>作用都是指明配置在<code class=\"markdown-linecode\">application.properties</code>的前缀</p>\n<p>例如此处前缀就是<code class=\"markdown-linecode\">car</code></p>\n</blockquote>\n<h3 class=\"markdown-h3\">方式一</h3>\n<p>此方法适用于自定义的类</p>\n<pre><code class=\"language-java\">@Component\n@ConfigurationProperties(prefix = &quot;car&quot;)\npublic class Car {\n    private String name;\n    private Integer price;\n\n    public Car() {\n    }\n\n    public Car(String name, int price) {\n        this.name = name;\n        this.price = price;\n    }\n\t...Getter&amp;Setter\n    ...toString\n}\n</code></pre>\n<pre><code class=\"language-java\">@SpringBootApplication\npublic class MainApplication {\n    public static void main(String[] args) {\n        // 1.获取上下文对象，也就是IOC容器\n        ConfigurableApplicationContext applicationContext = SpringApplication.run(MainApplication.class, args);\n\n\n        // 6.验证配置绑定,方式一\n        Car car = applicationContext.getBean(&quot;car&quot;, Car.class);\n        System.out.println(car);\n\n    }\n}\n</code></pre>\n<h3 class=\"markdown-h3\">方式二</h3>\n<p>此方法适用于自定义和第三方类</p>\n<pre><code class=\"language-java\">@Configuration\n@EnableConfigurationProperties(Car.class)\npublic class MyConfigClass {\n}\n</code></pre>\n<pre><code class=\"language-java\">@ConfigurationProperties(prefix = &quot;car&quot;)\npublic class Car {\n    private String name;\n    private Integer price;\n    \n    public Car() {\n    }\n\n    public Car(String name, int price) {\n        this.name = name;\n        this.price = price;\n    }\n\t...Getter&amp;Setter\n    ...toString\n}\n</code></pre>\n<pre><code class=\"language-java\">@SpringBootApplication\npublic class MainApplication {\n    public static void main(String[] args) {\n        // 1.获取上下文对象，也就是IOC容器\n        ConfigurableApplicationContext applicationContext = SpringApplication.run(MainApplication.class, args);\n\n        // 6.验证配置绑定,方式二\n        Car car = applicationContext.getBean(Car.class);\n        System.out.println(car);\n\n    }\n}\n</code></pre>\n<h3 class=\"markdown-h3\">配置注解执行器</h3>\n<p>当你在类上配置了<code class=\"markdown-linecode\">@ConfigurationProperties</code>之后，IDEA会提示一个警告</p>\n<p><img src=\"Spring%20Boot.assets/image-20210822101646502.png\" alt=\"image-20210822101646502\" /></p>\n<p>这行警告不影响程序的运行，意思是<code class=\"markdown-linecode\">Spring Boot配置注解执行器没有配置</code></p>\n<p>配置注解执行器可以在配置文件中提示配置类的信息：</p>\n<p><img src=\"Spring%20Boot.assets/image-20210822101849266.png\" alt=\"image-20210822101849266\" /></p>\n<p>当我们的项目中配置好了配置注解执行器之后，我们的配置绑定的属性也会有提示，配置方法如下：</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>刷新Maven，重构项目即可使用，效果如下</p>\n<p><img src=\"Spring%20Boot.assets/image-20210822102622523.png\" alt=\"image-20210822102622523\" /></p>\n<p>最后，我们需要在打包插件中排除这配置注解执行器，因为它在打包后对功能是没有任何影响的，只是为了在开发时提供便利</p>\n<pre><code class=\"language-xml\">&lt;!--将spring boot 项目打包成jar包--&gt;\n&lt;plugin&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;excludes&gt;\n            &lt;!-- 排除 配置注解执行器 --&gt;\n            &lt;exclude&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\n            &lt;/exclude&gt;\n        &lt;/excludes&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre>\n<p>打包后查看jar包中没有<code class=\"markdown-linecode\">spring-boot-configuration-processor-2.3.3.RELEASE.jar</code>这个包，就说明排除成功了</p>\n<h1 class=\"markdown-h1\">六、底层自动装配原理</h1>\n<h2 class=\"markdown-h2\">1.@SpringBootApplication</h2>\n<p>进入<code class=\"markdown-linecode\">@SpringBootApplication</code>之后，可以看到以下注解</p>\n<pre><code class=\"language-java\">...元注解\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {}\n</code></pre>\n<p>下面对每个注解进行研究</p>\n<h3 class=\"markdown-h3\">@SpringBootConfiguration</h3>\n<pre><code class=\"language-java\">@Configuration\npublic @interface SpringBootConfiguration {}\n</code></pre>\n<p>很明显<code class=\"markdown-linecode\">@Configuration</code>表示这是一个配置类，这也就说明了<code class=\"markdown-linecode\">MainApplication</code>实际上也是一个配置类</p>\n<h3 class=\"markdown-h3\">@EnableAutoConfiguration</h3>\n<p>这个注解是三个中最重要的一个</p>\n<pre><code class=\"language-java\">@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {}\n</code></pre>\n<h4 class=\"markdown-h4\">@AutoConfigurationPackage</h4>\n<p>进入<code class=\"markdown-linecode\">@AutoConfigurationPackage</code>可以看到</p>\n<pre><code class=\"language-java\">@Import(AutoConfigurationPackages.Registrar.class)\npublic @interface AutoConfigurationPackage {}\n</code></pre>\n<p>也就是说实际上<code class=\"markdown-linecode\">@AutoConfigurationPackage</code>引入了一个名为<code class=\"markdown-linecode\">AutoConfigurationPackages.Registrar</code>的内部类组件，我们进入其中</p>\n<pre><code class=\"language-java\">static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {\n\n\t\t@Override\n\t\tpublic void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n\t\t\tregister(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));\n            // new PackageImports(metadata).getPackageNames()\n            // 获取metadata所在的包的包名，metadata标在MainApplication上\n            // 所以此行读取的是MainApplication所在的包的包名\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) {\n\t\t\treturn Collections.singleton(new PackageImports(metadata));\n\t\t}\n\n\t}\n</code></pre>\n<p>可以看到这个类实现的是批量注册的功能</p>\n<p>我们在<code class=\"markdown-linecode\">register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));</code>这一行打下断点，Debug一下</p>\n<p>计算一下<code class=\"markdown-linecode\">new PackageImports(metadata).getPackageNames()</code>的值，得到如下结果</p>\n<p><img src=\"Spring%20Boot.assets/image-20210821153049256.png\" alt=\"image-20210821153049256\" /></p>\n<p>也就是说，这个组件实际功能是将<code class=\"markdown-linecode\">MainApplication</code>所在的包进行注册，这也就解释了为什么默认自动包扫描要求必须在<code class=\"markdown-linecode\">MainApplication所在包及其子包下</code>了</p>\n<h4 class=\"markdown-h4\">@Import(AutoConfigurationImportSelector.class)</h4>\n<p>进入<code class=\"markdown-linecode\">AutoConfigurationImportSelector</code></p>\n<pre><code class=\"language-java\">public String[] selectImports(AnnotationMetadata annotationMetadata) {\n    if (!isEnabled(annotationMetadata)) {\n        return NO_IMPORTS;\n    }\n    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);\n    return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());\n}\n</code></pre>\n<p>其中的<code class=\"markdown-linecode\">getAutoConfigurationEntry(annotationMetadata)</code>是整个方法的核心，进入这个方法</p>\n<pre><code class=\"language-java\">protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {\n\t\tif (!isEnabled(annotationMetadata)) {\n\t\t\treturn EMPTY_ENTRY;\n\t\t}\n\t\tAnnotationAttributes attributes = getAttributes(annotationMetadata);\n\t\tList&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);\n\t\tconfigurations = removeDuplicates(configurations);\n\t\tSet&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);\n\t\tcheckExcludedClasses(configurations, exclusions);\n\t\tconfigurations.removeAll(exclusions);\n\t\tconfigurations = getConfigurationClassFilter().filter(configurations);\n\t\tfireAutoConfigurationImportEvents(configurations, exclusions);\n\t\treturn new AutoConfigurationEntry(configurations, exclusions);\n\t}\n</code></pre>\n<p>我们先在<code class=\"markdown-linecode\">configurations = removeDuplicates(configurations);</code>这一行打个断电并Debug，可以得到下面的结果，显示<code class=\"markdown-linecode\">configurations</code>共计127个，记住这个数字</p>\n<p><img src=\"Spring%20Boot.assets/image-20210821161106658.png\" alt=\"image-20210821161106658\" /></p>\n<p>很明显<code class=\"markdown-linecode\">getCandidateConfigurations(annotationMetadata, attributes);</code>是整段的核心，因为下面操作的所有<code class=\"markdown-linecode\">configurations</code>都是从他这获取的,进入</p>\n<pre><code class=\"language-java\">\tprotected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n\t\tList&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),\n\t\t\t\tgetBeanClassLoader());\n\t\tAssert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;\n\t\t\t\t+ &quot;are using a custom packaging, make sure that file is correct.&quot;);\n\t\treturn configurations;\n\t}\n</code></pre>\n<p><code class=\"markdown-linecode\">SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</code>此处调用了<code class=\"markdown-linecode\">SpringFactoriesLoader</code>,我们进去看看加载了什么</p>\n<pre><code class=\"language-java\">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) {\n    String factoryTypeName = factoryType.getName();\n    return (List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());\n}\n</code></pre>\n<p>进入<code class=\"markdown-linecode\">(List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</code>查看具体加载了什么</p>\n<pre><code class=\"language-java\">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {\n        MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);\n        if (result != null) {\n            return result;\n        } else {\n            try {\n                Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);\n                LinkedMultiValueMap result = new LinkedMultiValueMap();\n\n                while(urls.hasMoreElements()) {\n                    URL url = (URL)urls.nextElement();\n                    UrlResource resource = new UrlResource(url);\n                    Properties properties = PropertiesLoaderUtils.loadProperties(resource);\n                    Iterator var6 = properties.entrySet().iterator();\n\n                    while(var6.hasNext()) {\n                        Entry&lt;?, ?&gt; entry = (Entry)var6.next();\n                        String factoryTypeName = ((String)entry.getKey()).trim();\n                        String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());\n                        int var10 = var9.length;\n\n                        for(int var11 = 0; var11 &lt; var10; ++var11) {\n                            String factoryImplementationName = var9[var11];\n                            result.add(factoryTypeName, factoryImplementationName.trim());\n                        }\n                    }\n                }\n\n                cache.put(classLoader, result);\n                return result;\n            } catch (IOException var13) {\n                throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13);\n            }\n        }\n    }\n</code></pre>\n<p>最终我们找到了SpringBoot到底加载了什么：<code class=\"markdown-linecode\">&quot;META-INF/spring.factories&quot;</code></p>\n<p>当我们想要找到这个文件时，会发现有很多个相同文件</p>\n<p><img src=\"Spring%20Boot.assets/image-20210821160358001.png\" alt=\"image-20210821160358001\" /></p>\n<p><img src=\"Spring%20Boot.assets/image-20210821160625521.png\" alt=\"image-20210821160625521\" /></p>\n<p>其中最核心的就是<code class=\"markdown-linecode\">spring-boot-autoconfigure-2.3.3.RELEASE.jar/META-INF/spring.factories</code>,其中最核心的就是下面的这些</p>\n<pre><code class=\"language-properties\"># Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\\norg.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\\norg.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\\norg.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\\norg.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\\norg.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration\n</code></pre>\n<p>去掉第一行的注释和第二行的键名，总共127(129-2)行，对比上面打断点得到的结果，数量和内容都相同，可以得出结论，SpringBoot在启动时将这127个自动配置类全部加载了</p>\n<p>但是我们去看自动配置时IOC容器内的组件并不是全部包含了上面所有的127个，而是只有其中的几个</p>\n<p>这时我们需要随便挑一个<code class=\"markdown-linecode\">spring-boot-autoconfigure-2.3.3.RELEASE.jar</code>中的我们没有用到的<code class=\"markdown-linecode\">AutoConfiguration</code>类，进去一探究竟，以<code class=\"markdown-linecode\">spring-boot-autoconfigure-2.3.3.RELEASE.jar/org/jdbc/DataSourceAutoConfiguration</code>为例</p>\n<pre><code class=\"language-java\">@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })\n@ConditionalOnMissingBean(type = &quot;io.r2dbc.spi.ConnectionFactory&quot;)\n@EnableConfigurationProperties(DataSourceProperties.class)\n@Import({ DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class })\npublic class DataSourceAutoConfiguration {}\n</code></pre>\n<p><code class=\"markdown-linecode\">@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })</code>这一行注解起到了决定性的作用，<code class=\"markdown-linecode\">ConditionalOnClass</code>保证了只有在IOC中存在了<code class=\"markdown-linecode\">DataSource</code>和<code class=\"markdown-linecode\">EmbeddedDatabaseType</code>类时才加载这个组件，因此虽然引入了JDBC的自动配置类，但实际上因为JDBC并未使用，所以它并未加载</p>\n<p>这就是SpringBoot自动配置的按需开启</p>\n<h2 class=\"markdown-h2\">2.自动装配过程</h2>\n<ol class=\"markdown-list\">\n<li>SpringBoot 加载所有自动配置类，<code class=\"markdown-linecode\">xxxAutoConfiguration</code></li>\n<li>自动配置类按需生效</li>\n<li>生效的自动配置类去<code class=\"markdown-linecode\">xxxProperties</code>类中找默认值，如果有自定义配置优先自定义配置\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">xxxProperties</code>类会优先去找<code class=\"markdown-linecode\">application.properties</code>中的值</li>\n</ul>\n</li>\n<li>配置完成后放入容器中生效，也就有了该功能</li>\n</ol>\n<ul class=\"markdown-list\">\n<li>定制化配置\n<ol class=\"markdown-list\">\n<li>自定义Bean对象替换容器中官方定义的</li>\n<li>查看类中定义的配置项或查官方文档，修改配置文件</li>\n</ol>\n</li>\n</ul>\n<h1 class=\"markdown-h1\">七、yaml 和 配置文件</h1>\n<h2 class=\"markdown-h2\">1.yaml</h2>\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">:</code>后的<code class=\"markdown-linecode\">空格</code>一定不等省</li>\n<li><code class=\"markdown-linecode\">#</code>表示注释</li>\n<li>使用缩进控制层级</li>\n<li>文本类型数据可以不加<code class=\"markdown-linecode\">''</code>或<code class=\"markdown-linecode\">&quot;&quot;</code></li>\n<li><code class=\"markdown-linecode\">''</code>包裹的字符串会作为纯字符串，也就是会取消转义</li>\n<li><code class=\"markdown-linecode\">&quot;&quot;</code>包裹的字符串会进行转义操作，其中的<code class=\"markdown-linecode\">\\n</code>等字符会被转义</li>\n<li>松散匹配，假设属性名为<code class=\"markdown-linecode\">lastName</code>,下面的配置命名方式都是正确的\n<ul class=\"markdown-list\">\n<li>last-name</li>\n<li>last_name</li>\n<li>lastName</li>\n<li>lastname</li>\n<li>LASTNAME</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-yaml\"># 字面量\nname: a # String\nage: 18 # Integer\nbirthday: 1999/01/01 # Date\nisboss: true # Boolean\n\n\n\n# 对象、Map\nstudent1: \n  name: a\n  age: 18\n\t\nstudent2: {name: a,age: 18}\n\n# 数组、Array\npets1:\n  - cat\n  - dog\n\t\npets2: [cat,dog]\n\n# 复杂对象直接利用上面的组合即可\n</code></pre>\n<h2 class=\"markdown-h2\">2.配置文件</h2>\n<ul class=\"markdown-list\">\n<li>官方文档地址：<a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html\" target=\"_blank\">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html</a></li>\n<li>配置文件默认位置为：\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">src/resources/application.properties</code></li>\n<li><code class=\"markdown-linecode\">src/resources/application.yaml</code> 或 <code class=\"markdown-linecode\">src/resources/application.yml</code></li>\n<li>以上两种配置文件是可以共存的</li>\n<li>加载顺序是<strong>yml&gt;yaml&gt;properties</strong></li>\n<li>因为<code class=\"markdown-linecode\">properties</code>最后加载，所以会覆盖前两种，所以<code class=\"markdown-linecode\">properties</code>的优先级最高</li>\n</ul>\n</li>\n<li>banner\n<ul class=\"markdown-list\">\n<li><a href=\"https://www.bootschool.net/ascii\" target=\"_blank\">自定义启动Banner在线生成工具</a></li>\n<li>在配置文件同级目录创建banner.txt</li>\n</ul>\n</li>\n</ul>\n<h1 class=\"markdown-h1\">八、Web核心功能</h1>\n<h2 class=\"markdown-h2\">1.静态资源</h2>\n<p>官方文档地址：https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-web-applications.spring-mvc.static-content</p>\n<p>静态资源配置源代码所在路径：<code class=\"markdown-linecode\">spring-boot-autoconfigure-2.3.3.RELEASE.jar!\\org\\springframework\\boot\\autoconfigure\\web\\servlet\\WebMvcAutoConfiguration</code></p>\n<h3 class=\"markdown-h3\">默认目录</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>静态资源目录默认路径</p>\n<ul class=\"markdown-list\">\n<li>\n<p>注意：下面的路径都是在IDEA中<code class=\"markdown-linecode\">resources</code>目录下</p>\n</li>\n<li>\n<p><code class=\"markdown-linecode\">/static</code></p>\n</li>\n<li>\n<p><code class=\"markdown-linecode\">/resources</code></p>\n</li>\n<li>\n<p><code class=\"markdown-linecode\">/public</code></p>\n</li>\n<li>\n<p><code class=\"markdown-linecode\">/META-INF/resources</code></p>\n</li>\n<li>\n<p>生效优先级</p>\n<ol class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">/META-INF/resources</code></li>\n<li><code class=\"markdown-linecode\">/resources</code></li>\n<li><code class=\"markdown-linecode\">/static</code></li>\n<li><code class=\"markdown-linecode\">/public</code></li>\n</ol>\n<ul class=\"markdown-list\">\n<li>这是我测试得出的，不知道为什么与网上测试结果不同，测试使用的是图片，SpringBoot2.3.3</li>\n</ul>\n</li>\n<li>\n<p>发现</p>\n<ul class=\"markdown-list\">\n<li>项目启动时可能会对已有的静态资源进行扫描</li>\n<li>此时已经有的资源会被加载到内存（删除本地文件后依旧能访问到）</li>\n<li>项目启动后，再向静态资源文件夹中添加的文件是无法被访问的（进一步印证上面的猜想）</li>\n<li>但是这只是猜想，我还并未确定</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 class=\"markdown-h3\">自定义目录</h3>\n<pre><code class=\"language-yaml\">spring:\n  resources:\n    static-locations: classpath:/r/ # 单个路径可以直接写\n    \n# ======================================================\n\nspring:\n  resources:\n    static-locations: [classpath:/r/] # 多个需要数组格式，当然两种数组格式都可以\n</code></pre>\n<p>不如直接进去看看源码</p>\n<pre><code class=\"language-java\">private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { \n    &quot;classpath:/META-INF/resources/&quot;,\n    &quot;classpath:/resources/&quot;, \n    &quot;classpath:/static/&quot;, \n    &quot;classpath:/public/&quot; \n};\npublic void setStaticLocations(String[] staticLocations) {\n    this.staticLocations = appendSlashIfNecessary(staticLocations);\n}\nprivate String[] appendSlashIfNecessary(String[] staticLocations) {\n    String[] normalized = new String[staticLocations.length];\n    for (int i = 0; i &lt; staticLocations.length; i++) {\n        String location = staticLocations[i];\n        normalized[i] = location.endsWith(&quot;/&quot;) ? location : location + &quot;/&quot;;\n    }\n    return normalized;\n}\n</code></pre>\n<p>上面的常量定义了所有静态资源目录，<code class=\"markdown-linecode\">appendSlashIfNecessary</code>函数用于添加自定义的静态资源目录，并且还贴心的帮你做了检查，检查你的结尾是否有<code class=\"markdown-linecode\">/</code>，也就是说其实你的配置中你不写结尾的<code class=\"markdown-linecode\">/</code>也是能识别的，我在<code class=\"markdown-linecode\">this.staticLocations = appendSlashIfNecessary(staticLocations);</code>打了断点，执行后的结果为 <code class=\"markdown-linecode\">this.staticLocations == [&quot;classpath:/r/&quot;]</code>,其实看源码能得到同样的结果</p>\n<p>在这里我得到了和网上教程不同的结果：</p>\n<ul class=\"markdown-list\">\n<li>在自定义静态资源路径后：<code class=\"markdown-linecode\">&quot;/resources/&quot;</code>、<code class=\"markdown-linecode\">&quot;/static/&quot;</code>、<code class=\"markdown-linecode\">&quot;/public/&quot;</code>，这三个路径全部都失效了</li>\n<li>但是和网上教程不同的是，我测试的<code class=\"markdown-linecode\">/META-INF/resources/</code>这个路径并未失效，而是可以和自定义路径同时生效，生效优先级为：<code class=\"markdown-linecode\">自定义 &gt; /META-INF/resources/</code></li>\n</ul>\n<h3 class=\"markdown-h3\">处理过程</h3>\n<p>官方文档中已经指明了web项目的静态资源是处理的<code class=\"markdown-linecode\">/**</code>请求，也就是说请求发来后不论是动态资源还是静态资源都会执行以下步骤</p>\n<ol class=\"markdown-list\">\n<li>将请求交给Controller查看是否为动态资源</li>\n<li>将所有没被Controller处理的请求交给静态资源处理器</li>\n<li>还未匹配，返回404</li>\n</ol>\n<h3 class=\"markdown-h3\">静态资源前缀</h3>\n<p>静态资源前缀在设置拦截器是会非常有用，在配置全局拦截器时拦截的路径是<code class=\"markdown-linecode\">/**</code>，也会拦截到静态资源，所以我们需要区分静态资源和动态资源</p>\n<pre><code class=\"language-yaml\">spring:\n  mvc:\n    static-path-pattern: /res/**\n</code></pre>\n<p><code class=\"markdown-linecode\">static-path-pattern</code>指定了访问静态资源的路径匹配模式，其中<code class=\"markdown-linecode\">res</code>为静态资源路径的前缀，设置后所有的静态资源都需要使用<code class=\"markdown-linecode\">http://localhost:8080/res/xxx.jpg</code>的形式来获取静态资源</p>\n<h3 class=\"markdown-h3\">WebJars</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>WebJars</p>\n<p>WebJars是一种将前端静态资源封装成Jar包的方式</p>\n<p>WebJars官网：https://www.webjars.org/</p>\n</blockquote>\n<pre><code class=\"language-xml\">&lt;!-- WebJars jquery --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.webjars&lt;/groupId&gt;\n    &lt;artifactId&gt;jquery&lt;/artifactId&gt;\n    &lt;version&gt;3.6.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<ul class=\"markdown-list\">\n<li>\n<p>记得导入后重启项目，热部署是无效的</p>\n</li>\n<li>\n<p>通过<code class=\"markdown-linecode\">http://localhost:8080/webjars/静态资源</code>的形式访问路径</p>\n</li>\n<li>\n<p>例如:<code class=\"markdown-linecode\">http://localhost:8080/webjars/jquery/3.6.0/jquery.js</code></p>\n</li>\n<li>\n<p>查看Jar包</p>\n<ul class=\"markdown-list\">\n<li><img src=\"Spring%20Boot.assets/image-20210822173751378.png\" alt=\"image-20210822173751378\" /></li>\n<li>本质是利用了<code class=\"markdown-linecode\">/META-INF/resources/</code>静态资源路径来访问静态资源</li>\n</ul>\n</li>\n</ul>\n<h3 class=\"markdown-h3\">静态资源加载实现源码</h3>\n<pre><code class=\"language-java\">@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n    // 判断是否禁用了静态资源加载\n    if (!this.resourceProperties.isAddMappings()) {\n        logger.debug(&quot;Default resource handling disabled&quot;);\n        return;\n    }\n    // 获取缓存持续时间\n    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();\n    // 获取缓存控制器\n    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();\n    \n    // 处理WebJars，注册资源路径，设置缓存\n    if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) {\n        customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)\n                                             .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n        \n    }\n    // 获取静态资源目录\n    String staticPathPattern = this.mvcProperties.getStaticPathPattern();\n    // 设置静态资源目录，注册目录，添加缓存\n    if (!registry.hasMappingForPattern(staticPathPattern)) {\n        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)\n                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))\n                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n    }\n}\n</code></pre>\n<h2 class=\"markdown-h2\">2.欢迎页&amp;页签图标</h2>\n<h3 class=\"markdown-h3\">欢迎页</h3>\n<p>在静态资源目录中添加一个<code class=\"markdown-linecode\">index.html</code>，这个HTML就会被作为欢迎页面，访问<code class=\"markdown-linecode\">localhost:8080</code>即可查看</p>\n<p>==SpringBoot在此处设置为：==当你设置了静态资源前缀后，欢迎页将失效</p>\n<p>当然也不是没有解决方案，使用动态设置的欢迎页即可，在开启静态资源前缀后使用下面的Controller可以实现相同功能那个</p>\n<pre><code class=\"language-java\">@RequestMapping(&quot;/&quot;)\npublic String index(){\n    return &quot;/res/index.html&quot;;\n}\n</code></pre>\n<h3 class=\"markdown-h3\">欢迎页源码分析</h3>\n<pre><code class=\"language-java\">WelcomePageHandlerMapping(TemplateAvailabilityProviderstemplateAvailabilityProviders,ApplicationContext applicationContext,Optional&lt;Resource&gt; welcomePage,String staticPathPattern) {\n    // 此处做了判断，如果设置了静态资源前缀则欢迎页失效\n    if (welcomePage.isPresent() &amp;&amp; &quot;/**&quot;.equals(staticPathPattern)) {\n        logger.info(&quot;Adding welcome page: &quot; + welcomePage.get());\n        setRootViewName(&quot;forward:index.html&quot;);\n    }\n    else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) {\n        logger.info(&quot;Adding welcome page template: index&quot;);\n        setRootViewName(&quot;index&quot;);\n    }\n}\n</code></pre>\n<h3 class=\"markdown-h3\">页签图标</h3>\n<ul class=\"markdown-list\">\n<li>\n<p>自动配置页签图标</p>\n<ul class=\"markdown-list\">\n<li>需要在静态资源目录中放入<code class=\"markdown-linecode\">favicon.ico</code>这个页签图标文件</li>\n<li>==SpringBoot在此处为：==当你设置了静态资源前缀后，自动配置页签图标功能将失效</li>\n</ul>\n</li>\n<li>\n<p>手动配置页签图标</p>\n<ul class=\"markdown-list\">\n<li>\n<p>在HTML中放入如下代码，即可在配置了静态资源前缀后仍旧能够使用页签图标</p>\n</li>\n<li>\n<pre><code class=\"language-html\">&lt;link rel=&quot;shortcut icon&quot; href=&quot;/res/favicon.ico&quot;/&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">3.请求映射原理</h2>\n<p>请求映射需要从<code class=\"markdown-linecode\">DispatcherServlet</code>开始，通过这个类向下查找，最后找到<code class=\"markdown-linecode\">HttpServlet</code>可以得到如下继承树</p>\n<p><img src=\"Spring%20Boot.assets/image-20210823151055144.png\" alt=\"image-20210823151055144\" /></p>\n<p>在<code class=\"markdown-linecode\">HttpServletBean</code>中并没有<code class=\"markdown-linecode\">doGet</code>、<code class=\"markdown-linecode\">doPost</code>方法，向上查找，可在<code class=\"markdown-linecode\">FrameworkServlet</code>中找到</p>\n<p><img src=\"Spring%20Boot.assets/image-20210823151238075.png\" alt=\"image-20210823151238075\" /></p>\n<p>查看源代码：</p>\n<pre><code class=\"language-java\">@Override\nprotected final void doGet(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    processRequest(request, response);\n}\n</code></pre>\n<pre><code class=\"language-java\">protected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n\t// ...............\n    try {\n        doService(request, response);\n    }\n\t// .................\n}\n</code></pre>\n<p>继续查找<code class=\"markdown-linecode\">doService</code>会发现是一个抽象方法</p>\n<pre><code class=\"language-java\">protected abstract void doService(HttpServletRequest request, HttpServletResponse response)throws Exception;\n</code></pre>\n<p>那就继续向子类查找，可以在<code class=\"markdown-linecode\">DispatcherServlet</code>中找到具体实现</p>\n<pre><code class=\"language-java\">@Override\nprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n   // ...........\n   try {\n      doDispatch(request, response);\n   }\n   // ...........\n}\n</code></pre>\n<p>继续找到<code class=\"markdown-linecode\">doDispatch</code>具体实现：</p>\n<pre><code class=\"language-java\">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t// ........\n            // 决定当前请求由哪个类的哪个方法处理\n            mappedHandler = getHandler(processedRequest);\n            if (mappedHandler == null) {\n                noHandlerFound(processedRequest, response);\n                return;\n            }\n\t// ........\n}\n\n</code></pre>\n<pre><code class=\"language-java\">@Nullable\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    if (this.handlerMappings != null) {\n        for (HandlerMapping mapping : this.handlerMappings) {\n            HandlerExecutionChain handler = mapping.getHandler(request);\n            if (handler != null) {\n                return handler;\n            }\n        }\n    }\n    return null;\n}\n</code></pre>\n<p>在<code class=\"markdown-linecode\">if (this.handlerMappings != null)</code>处，打下断点，可以得到如下结果</p>\n<p><img src=\"Spring%20Boot.assets/image-20210823161027322.png\" alt=\"image-20210823161027322\" /></p>\n<p><img src=\"Spring%20Boot.assets/image-20210823155337651.png\" alt=\"image-20210823155337651\" /></p>\n<p>可以看到在<code class=\"markdown-linecode\">RequestMappingHandlerMapping</code>中保存了所有的路径映射信息，包括映射路径和处理方法</p>\n<ul class=\"markdown-list\">\n<li>执行步骤\n<ol class=\"markdown-list\">\n<li>进入<code class=\"markdown-linecode\">doDispatch</code>，执行<code class=\"markdown-linecode\">getHandler</code>方法</li>\n<li><code class=\"markdown-linecode\">getHandler</code>方法中的<code class=\"markdown-linecode\">handlerMappings </code>属性存储了所有handlerMapping，包括<code class=\"markdown-linecode\">RequestMappingHandlerMapping</code>、SpringBoot内置的欢迎页handlerMapping：<code class=\"markdown-linecode\">WelcomePageHandlerMapping</code>等等</li>\n<li><code class=\"markdown-linecode\">getHandler</code>方法会遍历所有的handlerMapping，找到一个能够匹配请求的</li>\n</ol>\n</li>\n<li>通过查看源码，我们发现我们可以自定义<code class=\"markdown-linecode\">handlerMapping</code>，并将其放入容器中即可生效</li>\n</ul>\n<h2 class=\"markdown-h2\">4.请求处理</h2>\n<h3 class=\"markdown-h3\">Rest风格</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>Rest风格</p>\n<p>之前的请求是以请求路径作为区分动作的类型，这些都是操作同一对象的动作，但是分成了很多个小功能</p>\n<p>例如：</p>\n<ul class=\"markdown-list\">\n<li>/getUser 请求用户</li>\n<li>/delUser 删除用户</li>\n<li>/editUser 修改用户</li>\n<li>/saveUser 增加用户</li>\n</ul>\n<p>Rest风格则是将所有的请求路径都统一，通过HTTP请求的动作来区分操作类型</p>\n<p>例如：</p>\n<ul class=\"markdown-list\">\n<li>/user GET请求 请求用户</li>\n<li>/user POST请求 添加用户</li>\n<li>/user PUT请求 修改用户</li>\n<li>/user DELETE请求 删除用户</li>\n</ul>\n</blockquote>\n<ul class=\"markdown-list\">\n<li>\n<p>开启HTML的Rest风格支持</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code class=\"language-yaml\">spring:\n  mvc:\n    hiddenmethod:\n      filter:\n        enabled: true\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>默认支持原生的Rest风格，不需要开启，但HTML无法发送PUT、DELETE请求，所以需要手动开启</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)\n    @GetMapping(&quot;/user&quot;)\n    public String getUser(){\n        return &quot;GET user，获取用户&quot;;\n    }\n    //@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)\n    @PostMapping(&quot;/user&quot;)\n    public String addUser(){\n        return &quot;POST user，添加用户&quot;;\n    }\n    //@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)\n    @PutMapping(&quot;/user&quot;)\n    public String editUser(){\n        return &quot;PUT user，修改用户&quot;;\n    }\n\n    //@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)\n    @DeleteMapping(&quot;/user&quot;)\n    public String delUser(){\n        return &quot;Delete user，删除用户&quot;;\n    }\n</code></pre>\n<h4 class=\"markdown-h4\">HTML Rest 风格源码</h4>\n<pre><code class=\"language-java\">@Bean\n@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)\n@ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;, matchIfMissing = false)\npublic OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {\n   return new OrderedHiddenHttpMethodFilter();\n}\n\n// =========================\n// 这个过滤器是为了处理HTML无法发送PUT、DELETE等方法的，原生方法不受此过滤器影响\npublic class HiddenHttpMethodFilter extends OncePerRequestFilter {\n    // 支持的请求类型\n    private static final List&lt;String&gt; ALLOWED_METHODS =\n\t\t\tCollections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(),\n\t\t\t\t\tHttpMethod.DELETE.name(), HttpMethod.PATCH.name()));\n\t...........\n\t@Override\n\tprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tHttpServletRequest requestToUse = request;\n\t\t// 指定了必须为POST方法\n\t\tif (&quot;POST&quot;.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) {\n\t\t\tString paramValue = request.getParameter(this.methodParam);\n\t\t\tif (StringUtils.hasLength(paramValue)) {\n                // 自动转为大写，所以前端参数不区分大小写\n\t\t\t\tString method = paramValue.toUpperCase(Locale.ENGLISH);\n                // 判断是否为支持的请求\n\t\t\t\tif (ALLOWED_METHODS.contains(method)) {\n\t\t\t\t\trequestToUse = new HttpMethodRequestWrapper(request, method);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfilterChain.doFilter(requestToUse, response);\n\t}\n\t..........\n}\n\n</code></pre>\n<h4 class=\"markdown-h4\">HTML Rest 前端配置</h4>\n<p>因为HTML表单无法发送put、delete等方法，所以表单提交时需要携带<code class=\"markdown-linecode\">_method</code>参数而且必须使用<code class=\"markdown-linecode\">post</code>方式携带参数，此参数用来区别HTTP请求的方法</p>\n<pre><code class=\"language-html\">&lt;h2&gt;GET&lt;/h2&gt;\n&lt;form action=&quot;/user&quot; method=&quot;get&quot;&gt;\n    &lt;button type=&quot;submit&quot;&gt;获取用户&lt;/button&gt;\n&lt;/form&gt;\n&lt;h2&gt;POST&lt;/h2&gt;\n&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt;\n    &lt;button type=&quot;submit&quot;&gt;添加用户&lt;/button&gt;\n&lt;/form&gt;\n&lt;h2&gt;PUT&lt;/h2&gt;\n&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt;\n    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt;\n    &lt;button type=&quot;submit&quot;&gt;修改用户&lt;/button&gt;\n&lt;/form&gt;\n&lt;h2&gt;DELETE&lt;/h2&gt;\n&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt;\n    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;&gt;\n    &lt;button type=&quot;submit&quot;&gt;删除用户&lt;/button&gt;\n&lt;/form&gt;\n</code></pre>\n<h4 class=\"markdown-h4\">修改Rest默认参数名</h4>\n<ul class=\"markdown-list\">\n<li>配置类中添加如下代码即可</li>\n</ul>\n<pre><code class=\"language-java\">@Bean\npublic HiddenHttpMethodFilter hiddenHttpMethodFilter(){\n    HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();\n    hiddenHttpMethodFilter.setMethodParam(&quot;_m&quot;); // 修改默认的参数名\n    return hiddenHttpMethodFilter;\n}\n</code></pre>\n<h3 class=\"markdown-h3\">请求参数</h3>\n<h4 class=\"markdown-h4\">请求参数</h4>\n<pre><code class=\"language-java\">@GetMapping(&quot;/parameter&quot;)\npublic Map&lt;String,Object&gt; parameter(@RequestParam String name,\n                                    @RequestParam Integer id,\n                                    @RequestParam Map&lt;String,String&gt; kv,\n                                    @RequestParam MultiValueMap&lt;String,String&gt; multiValueMap){\n    // RequestParam有三种获取方式\n    // 1. 直接获取\n    // 2. Map&lt;String,String&gt; , 注意：即使写成Map&lt;String,Object&gt;，取出来的依旧是String类型\n    // 3. MultiValueMap&lt;String,String&gt;\n    HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();\n    map.put(&quot;name&quot;,name);\n    map.put(&quot;id&quot;,id);\n    map.put(&quot;kv&quot;,kv);\n    map.put(&quot;MultiValueMap&quot;,multiValueMap);\n    return map;\n}\n</code></pre>\n<h4 class=\"markdown-h4\">路径参数</h4>\n<blockquote class=\"markdown-blockquote\">\n<p>路径参数一般配合Rest风格使用，也就是使用<code class=\"markdown-linecode\">@RestController</code></p>\n</blockquote>\n<pre><code class=\"language-java\">@GetMapping(&quot;/path/{id}/{name}&quot;)\npublic Map&lt;String, Object&gt; path(@PathVariable(&quot;id&quot;) String id,\n                                @PathVariable(&quot;name&quot;) String name,\n                                @PathVariable Map&lt;String,String&gt; kv){\n    // 两种接收参数的方式，\n    // 一：直接接收，\n    // 二：将所有参数以Map形式存储，要求必须为 Map&lt;String,String&gt;格式\n    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n    map.put(&quot;id&quot;,id);\n    map.put(&quot;name&quot;,name);\n    map.put(&quot;kv&quot;,kv);\n    return map;\n}\n</code></pre>\n<h4 class=\"markdown-h4\">请求头</h4>\n<pre><code class=\"language-java\">@GetMapping(&quot;/headers&quot;)\npublic Map&lt;String,Object&gt; header(@RequestHeader(&quot;User-Agent&quot;) String userAgent,\n                                 @RequestHeader(&quot;Host&quot;)String host,\n                                 @RequestHeader Map&lt;String,String&gt; kv,\n                                 @RequestHeader MultiValueMap&lt;String,String&gt; multiValueMap,\n                                 @RequestHeader HttpHeaders httpHeaders){\n    // RequestHeader共有四种获取方式\n    // 1. 直接获取单个属性\n    // 2. 通过Map&lt;String,String&gt;获取全部键值对\n    // 3. 使用Spring封装的MultiValueMap获取键值对\n    // 4. 直接获取HttpHeaders对象\n    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n    map.put(&quot;userAgent&quot;,userAgent);\n    map.put(&quot;host&quot;,host);\n    map.put(&quot;kv&quot;,kv);\n    \n    map.put(&quot;MultiValueMap&quot;,multiValueMap);\n    map.put(&quot;HttpHeaders&quot;,httpHeaders);\n    return map;\n}\n</code></pre>\n<h4 class=\"markdown-h4\">Cookies</h4>\n<pre><code class=\"language-java\">@GetMapping(&quot;/cookies&quot;)\npublic Map&lt;String,Object&gt; cookies(@CookieValue(&quot;a&quot;) String a,\n                                  @CookieValue(&quot;a&quot;) Integer ai,\n                                  @CookieValue Cookie b){\n    // @CookieValue 获取Cookie的值\n    // 1. 直接获取值，可以是String、Integer等等.\n    // 2. 通过Cookie对象获取，不用指定Cookie名\n        // ## Cookie对象获取，指定名称后会404，原因未知\n        // Cookie对象需要使用javax.servlet.http.Cookie\n    // 获取没有的Cookie会400\n    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n    map.put(&quot;a&quot;,a);\n    map.put(&quot;ai&quot;,ai);\n    map.put(&quot;b&quot;,b);\n    return map;\n}\n</code></pre>\n<h4 class=\"markdown-h4\">请求体</h4>\n<p>获取HTTP请求的请求体，获取的是原始代码，字符编码为URL编码</p>\n<pre><code class=\"language-java\">@PostMapping(&quot;/requestBody&quot;)\npublic Map&lt;String,Object&gt; requestBody(@RequestBody String body){\n    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n    map.put(&quot;body&quot;,body);\n    return map;\n}\n</code></pre>\n<h4 class=\"markdown-h4\">转发参数</h4>\n<pre><code class=\"language-java\">@RequestMapping(&quot;/forward&quot;)\npublic String  forward(HttpServletRequest request){\n    request.setAttribute(&quot;msg&quot;,&quot;成功！&quot;);\n    return &quot;forward:/success&quot;;\n}\n\n@RequestMapping(&quot;/success&quot;)\n@ResponseBody\npublic Map&lt;String,Object&gt; success(@RequestAttribute String msg,\n                                  HttpServletRequest request){\n    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n    map.put(&quot;RequestAttribute&quot;,msg);\n    map.put(&quot;HttpServletRequest&quot;,request.getAttribute(&quot;msg&quot;));\n    return map;\n}\n</code></pre>\n<h4 class=\"markdown-h4\">矩阵变量</h4>\n<blockquote class=\"markdown-blockquote\">\n<p>矩阵变量</p>\n<p>当浏览器能够正常使用Cookie时，服务器使用<code class=\"markdown-linecode\">Session</code>技术生成一个<code class=\"markdown-linecode\">jsessionid</code>，因为每个用户的Session在服务器中是独立的，这样就可以区分他们的身份，所以<code class=\"markdown-linecode\">jsessionid</code>能够进行身份鉴别,服务器会将他存入<code class=\"markdown-linecode\">cookie</code>中，每次请求都会携带，以此来鉴别用户身份</p>\n<p>当浏览器禁用Cookie时，服务器会将<code class=\"markdown-linecode\">jsessionid</code>放在URL中，这种技术被称为URL重写</p>\n<p>但是这种技术存在一个问题，因为放入URL中是以<code class=\"markdown-linecode\">QueryString</code>的形式存在的，很容易与正常的请求参数混淆，矩阵变量可以改善这一问题</p>\n<p>矩阵变量：<code class=\"markdown-linecode\">/matrix/test;name=张三</code></p>\n<p>矩阵变量是以<code class=\"markdown-linecode\">;</code>作为分隔符的，可以与<code class=\"markdown-linecode\">QueryString</code>区分</p>\n<p>而且矩阵参数是和请求路径一体的，也就是说<code class=\"markdown-linecode\">test;name=张三</code>是被视为一个参数的</p>\n<ul class=\"markdown-list\">\n<li>\n<p>==注意：矩阵参数必须和路径参数同时使用，否则无效==</p>\n</li>\n<li>\n<p>开启矩阵变量，需要在配置类中自定义SpringMVC</p>\n</li>\n<li>\n<pre><code class=\"language-java\">@Bean\npublic WebMvcConfigurer webMvcConfigurer(){\n    return new WebMvcConfigurer() {\n        @Override\n        public void configurePathMatch(PathMatchConfigurer configurer) {\n            UrlPathHelper urlPathHelper = new UrlPathHelper();\n            // 关闭移除;后的内容，也就是开启矩阵变量\n            urlPathHelper.setRemoveSemicolonContent(false);\n            configurer.setUrlPathHelper(urlPathHelper);\n        }\n    };\n}\n</code></pre>\n</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-java\">// 请求路径：\n// /matrix/test;name=张三;hobby=抽烟,喝酒,烫头\n// /matrix/test;name=张三;hobby=抽烟;hobby=喝酒;hobby=烫头\n// 以上两种路径等效\n@GetMapping(&quot;/matrix/{path}&quot;)\npublic Map&lt;String,Object&gt; matrix(@PathVariable String path,\n                                 @MatrixVariable(&quot;name&quot;) String name,\n                                 @MatrixVariable(&quot;hobby&quot;)List&lt;String&gt; hobby){\n    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n    map.put(&quot;path&quot;,path);\n    map.put(&quot;name&quot;,name);\n    map.put(&quot;hobby&quot;,hobby);\n    return map;\n}\n</code></pre>\n<pre><code class=\"language-java\">// 这种方式可以处理多个参数同名的问题\n// 请求路径：/matrixm/t1;name=张三/t2;name=李四\n@GetMapping(&quot;/matrixm/{path1}/{path2}&quot;)\npublic Map&lt;String,Object&gt; matrixm(@PathVariable(&quot;path1&quot;) String path1,\n                                  @PathVariable(&quot;path2&quot;) String path2,\n                                  @MatrixVariable(value = &quot;name&quot;,pathVar = &quot;path1&quot;) String name1,\n                                  @MatrixVariable(value = &quot;name&quot;,pathVar = &quot;path2&quot;) String name2\n                                 ){\n    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n    map.put(&quot;path1&quot;,path1);\n    map.put(&quot;path2&quot;,path2);\n    map.put(&quot;name1&quot;,name1);\n    map.put(&quot;name2&quot;,name2);\n\n    return map;\n}\n</code></pre>\n<h4 class=\"markdown-h4\">Servlet API 参数</h4>\n<pre><code class=\"language-java\">@GetMapping(&quot;/sapi&quot;)\npublic String servletApi(Map&lt;String,Object&gt; map,\n                         Model model,\n                         HttpServletRequest request,\n                         HttpServletResponse response){\n    // Servlet API 参数中：\n    // Map、Model、HttpServletRequest都是操作的request域中给的数据\n    // HttpServletResponse\n    map.put(&quot;map&quot;,&quot;map&quot;);\n    model.addAttribute(&quot;model&quot;,&quot;model&quot;);\n    request.setAttribute(&quot;req&quot;,&quot;req&quot;);\n    Cookie cookie = new Cookie(&quot;res&quot;, &quot;res&quot;);\n    response.addCookie(cookie);\n    return &quot;forward:servletApiSuccess&quot;;\n}\n</code></pre>\n<pre><code class=\"language-java\">@GetMapping(&quot;/servletApiSuccess&quot;)\n@ResponseBody\npublic Map&lt;String,Object&gt; servletApiSuccess(HttpServletRequest request){\n    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n    map.put(&quot;map&quot;,request.getAttribute(&quot;map&quot;));\n    map.put(&quot;model&quot;,request.getAttribute(&quot;model&quot;));\n    map.put(&quot;req&quot;,request.getAttribute(&quot;req&quot;));\n    return map;\n}\n</code></pre>\n<h4 class=\"markdown-h4\">对象参数</h4>\n<h4 class=\"markdown-h4\">请求参数原理</h4>\n<pre><code class=\"language-java\">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t// .........\n            // 获取请求适配器处理器.\n            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\t// .........\n    \t\t// 执行请求适配器处理器\n    \t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n}\n</code></pre>\n<h5 class=\"markdown-h5\">getHandlerAdapter</h5>\n<pre><code class=\"language-java\">protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {\n    if (this.handlerAdapters != null) {\n        for (HandlerAdapter adapter : this.handlerAdapters) {\n            if (adapter.supports(handler)) {\n                return adapter;\n            }\n        }\n    }\n    throw new ServletException(&quot;No adapter for handler [&quot; + handler +\n                               &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);\n}\n</code></pre>\n<p>查看属性<code class=\"markdown-linecode\">handlerAdapters</code>，可以得到内置的<code class=\"markdown-linecode\">HandlerAdapter</code>有以下4个</p>\n<p><img src=\"Spring%20Boot.assets/image-20210824084404752.png\" alt=\"image-20210824084404752\" /></p>\n<p>进入<code class=\"markdown-linecode\">adapter.supports(handler)</code></p>\n<pre><code class=\"language-java\">@Override\npublic final boolean supports(Object handler) {\n   return (handler instanceof HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));\n}\n</code></pre>\n<pre><code class=\"language-java\">@Override\nprotected boolean supportsInternal(HandlerMethod handlerMethod) {\n   return true;\n}\n</code></pre>\n<p>也就是说<code class=\"markdown-linecode\">supports</code>方法判断传入的是不是<code class=\"markdown-linecode\">HandlerMethod</code>类型的参数，如果是则返回<code class=\"markdown-linecode\">true</code>，然后<code class=\"markdown-linecode\">getHandlerAdapter</code>返回当前的<code class=\"markdown-linecode\">HandlerAdapter</code></p>\n<h5 class=\"markdown-h5\">handle</h5>\n<pre><code class=\"language-java\">@Override\n@Nullable\npublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n      throws Exception {\n\n   return handleInternal(request, response, (HandlerMethod) handler);\n}\n</code></pre>\n<pre><code class=\"language-java\">@Override\nprotected ModelAndView handleInternal(HttpServletRequest request,\n      HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\t// ............\n    \t// 执行目标方法\n    \tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t// ............\n}\n</code></pre>\n<pre><code class=\"language-java\">@Nullable\nprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n                                           HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n// ...........\n    // 获取要处理的方法\n    ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n    // 设置参数解析器\n    if (this.argumentResolvers != null) {\n        invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n    }\n    // 设置返回值处理器\n    if (this.returnValueHandlers != null) {\n     invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n    }\n// ...........\n\t// 执行并处理方法\n    invocableMethod.invokeAndHandle(webRequest, mavContainer);\n    if (asyncManager.isConcurrentHandlingStarted()) {\n        return null;\n    }\n\n// ............\n}\n</code></pre>\n<p>支持的参数解析器</p>\n<p><img src=\"Spring%20Boot.assets/image-20210824092842456.png\" alt=\"image-20210824092842456\" /></p>\n<p>参数解析器实现的接口</p>\n<p><img src=\"Spring%20Boot.assets/image-20210824093149356.png\" alt=\"image-20210824093149356\" /></p>\n<p>返回值处理器</p>\n<p><img src=\"Spring%20Boot.assets/image-20210824093341820.png\" alt=\"image-20210824093341820\" /></p>\n<p>返回值处理器实现的接口</p>\n<p><img src=\"Spring%20Boot.assets/image-20210824093503917.png\" alt=\"image-20210824093503917\" /></p>\n<p>执行并处理方法过程</p>\n<pre><code class=\"language-java\">public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,Object... providedArgs) throws Exception {\n\t// 执行方法，获得返回值\n    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n    setResponseStatus(webRequest);\n\t// ......\n}\n</code></pre>\n<p>实际执行方法的函数</p>\n<pre><code class=\"language-java\">@Nullable\npublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,Object... providedArgs) throws Exception {\n\t// 获取目标方法所有参数值\n    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\n    /.....\n    // 利用反射执行方法\n    return doInvoke(args);\n}\n</code></pre>\n<pre><code class=\"language-java\">protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,Object... providedArgs) throws Exception {\n\t// 获取方法上参数的详细信息\n    MethodParameter[] parameters = getMethodParameters();\n    // 判断参数是否为空\n    if (ObjectUtils.isEmpty(parameters)) {\n        return EMPTY_ARGS;\n    }\n\t// 按照参数个数创建空的对象数组\n    Object[] args = new Object[parameters.length];\n    // 遍历数组\n    for (int i = 0; i &lt; parameters.length; i++) {\n        // 获取当前位置参数\n        MethodParameter parameter = parameters[i];\n        // .......\n        // 查找支持的解析器\n        if (!this.resolvers.supportsParameter(parameter)) {\n            throw new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;));\n        }\n        // .........\n            // 拆分参数\n            args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\n\t// .........\n    return args;\n}\n</code></pre>\n<p><img src=\"Spring%20Boot.assets/image-20210824095615379.png\" alt=\"image-20210824095615379\" /></p>\n<p>获取参数解析器的过程</p>\n<pre><code class=\"language-java\">@Nullable\nprivate HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {\n    // 获取缓存中是否有该解析器\n    HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);\n    if (result == null) {\n        // 循环所有解析器\n        for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) {\n            // 判断当前解析器是否支持处理该类型的参数\n            if (resolver.supportsParameter(parameter)) {\n                // 支持则将当前解析器作为结果返回\n                result = resolver;\n                // 将当前解析器放入缓存中，方便下次使用\n                this.argumentResolverCache.put(parameter, result);\n                break;\n            }\n        }\n    }\n    return result;\n}\n</code></pre>\n<p>最后得到的结果：</p>\n<p><img src=\"Spring%20Boot.assets/image-20210824102059635.png\" alt=\"image-20210824102059635\" /></p>\n<h1 class=\"markdown-h1\">配置类</h1>\n<h2 class=\"markdown-h2\">自动配置</h2>\n<ul class=\"markdown-list\">\n<li>注解</li>\n</ul>\n<pre><code class=\"language-java\">@ConfigurationProperties(prefix = &quot;person&quot;)\n</code></pre>\n<ul class=\"markdown-list\">\n<li>yaml</li>\n</ul>\n<pre><code class=\"language-yaml\">person:\n  name: 张三\n  age: 18\n  sex: man\n</code></pre>\n<h2 class=\"markdown-h2\">指定配置文件</h2>\n<ul class=\"markdown-list\">\n<li>java</li>\n</ul>\n<pre><code class=\"language-java\">@PropertySource(&quot;classpath:a.properties&quot;)\npublic class Person {\n    @Value(&quot;${name}&quot;)\n    String name;\n    int age;\n    String sex;\n}\n</code></pre>\n<ul class=\"markdown-list\">\n<li>properties</li>\n</ul>\n<pre><code class=\"language-properties\">name=xxx\n</code></pre>\n<h2 class=\"markdown-h2\">静态资源处理</h2>\n<pre><code class=\"language-yaml\">spring:\n  web:\n    resources:\n      static-locations:\n        classpath: /static/**\n</code></pre>\n<h1 class=\"markdown-h1\">jsr303校验</h1>\n<p>https://www.jianshu.com/p/554533f88370</p>\n<ul class=\"markdown-list\">\n<li>开启数据校验注解\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">@Validated</code></li>\n</ul>\n</li>\n</ul>\n<p>| 注解                          | 含义                                                     |\n| ----------------------------- | -------------------------------------------------------- |\n| <code class=\"markdown-linecode\">@Null</code>                       | 被注释的元素必须为 <code class=\"markdown-linecode\">null</code>                                |\n| <code class=\"markdown-linecode\">@NotNull</code>                    | 被注释的元素必须不为 <code class=\"markdown-linecode\">null</code>                              |\n| <code class=\"markdown-linecode\">@AssertTrue</code>                 | 被注释的元素必须为 <code class=\"markdown-linecode\">true</code>                                |\n| <code class=\"markdown-linecode\">@AssertFalse</code>                | 被注释的元素必须为 <code class=\"markdown-linecode\">false</code>                               |\n| <code class=\"markdown-linecode\">@Min(value)</code>                 | 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 |\n| <code class=\"markdown-linecode\">@Max(value)</code>                 | 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 |\n| <code class=\"markdown-linecode\">@DecimalMin(value)</code>          | 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 |\n| <code class=\"markdown-linecode\">@DecimalMax(value)</code>          | 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 |\n| <code class=\"markdown-linecode\">@Size(max, min)</code>             | 被注释的元素的大小必须在指定的范围内                     |\n| <code class=\"markdown-linecode\">@Digits (integer, fraction)</code> | 被注释的元素必须是一个数字，其值必须在可接受的范围内     |\n| <code class=\"markdown-linecode\">@Past</code>                       | 被注释的元素必须是一个过去的日期                         |\n| <code class=\"markdown-linecode\">@Future</code>                     | 被注释的元素必须是一个将来的日期                         |\n| <code class=\"markdown-linecode\">@Pattern(value)</code>             | 被注释的元素必须符合指定的正则表达式                     |\n| <code class=\"markdown-linecode\">@Email</code>                      | 被注释的元素必须是电子邮箱地址                           |\n| <code class=\"markdown-linecode\">@Length</code>                     | 被注释的字符串的大小必须在指定的范围内                   |\n| <code class=\"markdown-linecode\">@NotEmpty</code>                   | 被注释的字符串的必须非空                                 |\n| <code class=\"markdown-linecode\">@Range</code>                      | 被注释的元素必须在合适的范围内                           |</p>\n<h1 class=\"markdown-h1\">多套配置环境</h1>\n<pre><code class=\"language-yaml\">#默认设置\nserver:\n  port: 8080\n\n#选中要使用的配置信息\nspring:\n  profiles:\n    active: dev\n\n---\n#设置端口\nserver:\n  port: 8081\n#命名为dev环境\nspring:\n  profiles: dev\n---\nserver:\n  port: 8082\n#命名为test环境\nspring:\n  profiles: test\n</code></pre>\n<h1 class=\"markdown-h1\">SpringBoot Web</h1>\n<h2 class=\"markdown-h2\">静态资源</h2>\n<h3 class=\"markdown-h3\">1、webjars</h3>\n<p>https://www.webjars.org/</p>\n<ul class=\"markdown-list\">\n<li>访问方式\n<ul class=\"markdown-list\">\n<li>localhost:8080/webjars/xxx</li>\n</ul>\n</li>\n</ul>\n<h3 class=\"markdown-h3\">2、目录</h3>\n<ol class=\"markdown-list\">\n<li>resourse</li>\n<li>static</li>\n<li>public</li>\n<li>/**</li>\n</ol>\n<ul class=\"markdown-list\">\n<li>访问方式\n<ul class=\"markdown-list\">\n<li>localhost:8080/xxx</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">Thymeleaf</h2>\n<h3 class=\"markdown-h3\">导入依赖</h3>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 class=\"markdown-h3\">导入命名空间</h3>\n<pre><code class=\"language-html\">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n</code></pre>\n<h3 class=\"markdown-h3\">使用</h3>\n<pre><code class=\"language-html\">&lt;h1 th:text=&quot;${msg}&quot;&gt;&lt;/h1&gt;\n</code></pre>\n<h3 class=\"markdown-h3\">语法</h3>\n<ul class=\"markdown-list\">\n<li></li>\n</ul>\n<p>| 标记 | 作用      | 示例   |\n| ---- | --------- | ------ |\n| ${}  | 取值      | ${msg} |\n| @{}  | 资源，url |        |\n| #{}  | 国际化    |        |</p>\n<ul class=\"markdown-list\">\n<li>标记</li>\n</ul>\n<p>| 语法       | 意义                     | 示例                                                 |\n| ---------- | ------------------------ | ---------------------------------------------------- |\n| <code class=\"markdown-linecode\">th:text</code>  | 插入文本，不转义html     | <code class=\"markdown-linecode\">&lt;h1 th:text=&quot;${msg}&quot;&gt;&lt;/h1&gt;</code>                         |\n| <code class=\"markdown-linecode\">th:utext</code> | 插入文本，并且转义为html | <code class=\"markdown-linecode\">&lt;h1 th:utext=&quot;${msg}&quot;&gt;&lt;/h1&gt;</code>                        |\n| <code class=\"markdown-linecode\">th:each</code>  | 遍历变量，取出值         | <code class=\"markdown-linecode\">&lt;h3 th:each=&quot;user:${list}&quot; th:text=&quot;${user}&quot;&gt;&lt;/h3&gt;</code> |\n|            |                          |                                                      |</p>\n<h1 class=\"markdown-h1\">Spring boot 基础</h1>\n<h2 class=\"markdown-h2\">Spring boot Stater</h2>\n<ul class=\"markdown-list\">\n<li>启动器</li>\n<li>实际上就是将一些常用的依赖进行了分组整理，能够一次行导入到Maven或Gradle中</li>\n</ul>\n<h2 class=\"markdown-h2\">启动器</h2>\n<ul class=\"markdown-list\">\n<li>只能扫描同级目录或下级目录下的包</li>\n</ul>\n<h1 class=\"markdown-h1\">微服务</h1>\n<p>2014年martin fowler在博客中提出微服务</p>\n<p><a href=\"https://www.martinfowler.com/articles/microservices.html\" target=\"_blank\">英文博文</a></p>\n<p><a href=\"http://blog.cuicc.com/blog/2015/07/22/microservices/\" target=\"_blank\">中文博文</a></p>\n<h1 class=\"markdown-h1\">常用功能</h1>\n<h2 class=\"markdown-h2\">Lombok</h2>\n<ol class=\"markdown-list\">\n<li>引入，SpringBoot中内置了Lombok，不需要写版本号</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n    &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<ol start=\"2\" class=\"markdown-list\">\n<li>在IDEA的插件市场中搜索Lombok插件并安装</li>\n</ol>\n<p>| 注解   | 作用 | 说明                                      |\n| ------ | ---- | ----------------------------------------- |\n| @Slf4j | 日志 | 使用后类内会多一个<code class=\"markdown-linecode\">log</code>对象，用于日志输出 |\n|        |      |                                           |\n|        |      |                                           |</p>\n<h2 class=\"markdown-h2\">项目热更新</h2>\n<h3 class=\"markdown-h3\">官方</h3>\n<ol class=\"markdown-list\">\n<li>导入依赖</li>\n</ol>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre>\n<ol start=\"2\" class=\"markdown-list\">\n<li>修改项目</li>\n<li>热更新\n<ul class=\"markdown-list\">\n<li><img src=\"Spring%20Boot.assets/image-20210822104553677.png\" alt=\"image-20210822104553677\" /></li>\n<li>默认快捷键<code class=\"markdown-linecode\">Ctrl+F9</code></li>\n</ul>\n</li>\n</ol>\n<ul class=\"markdown-list\">\n<li>官方的热更新其实就是自动启动，并没有实现热更新的效果</li>\n</ul>\n<h3 class=\"markdown-h3\">Jrebel</h3>\n<p>真正的热更新，但是是收费的</p>\n<p>https://blog.csdn.net/lianghecai52171314/article/details/105637251</p>\n",
    markdown: "一 、环境配置\n\n## JDK\n\n版本要求：1.8+\n\n## Maven\n\n版本要求：3.3+\n\n配置文件：`maven安装路径/conf/setting.xml`\n\n- 镜像设置为阿里云镜像，加快依赖下载速度\n\n  ```xml\n  <mirrors>\n      <!-- 配置阿里云镜像 -->\n      <mirror>\n          <id>aliyunmaven</id>\n          <mirrorOf>*</mirrorOf>\n          <name>阿里云公共仓库</name>\t             \n          <url>https://maven.aliyun.com/repository/public</url>\n      </mirror>\n  </mirrors>\n  ```\n\n- 配置项目以java1.8编译，因为springboot2.0+要求最低版本java8，固定配置防止错误\n\n  ```xml\n  <profiles>\n  \t<profile>\n  \t\t<id>jdk-1.8</id>\n  \n  \t\t<activation>\n  \t\t\t<activeByDefault>true</activeByDefault>\n  \t\t\t<jdk>1.8</jdk>\n  \t\t</activation>\n  \n  \t\t<properties>\n  \t\t\t<maven.compiler.source>1.8</maven.compiler.source>\n  \t\t\t<maven.compiler.target>1.8</maven.compiler.target>\n  \t\t\t<maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>\n  \t\t</properties>\n  \t</profile>\n  </profiles>\n  ```\n\n  \n\n# 二、创建项目\n\n## 1.Spring initializr\n\n- [官网生成](https://start.spring.io/)\n- IDEA\n\n## 2.手动创建\n\n1. 创建Maven项目\n\n2. 修改pom文件\n\n   - [官方文档地址](https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started-first-application-pom)\n\n   - ```xml\n     <parent>\n         <groupId>org.springframework.boot</groupId>\n         <artifactId>spring-boot-starter-parent</artifactId>\n         <version>2.3.3.RELEASE</version>\n     </parent>\n     \n     <dependencies>\n         <dependency>\n             <groupId>org.springframework.boot</groupId>\n             <artifactId>spring-boot-starter-web</artifactId>\n         </dependency>\n     </dependencies>\n     ```\n\n3. 创建web路由处理类\n\n   - ```java\n     import org.springframework.web.bind.annotation.RequestMapping;\n     import org.springframework.web.bind.annotation.RestController;\n     \n     @RestController\n     public class Testcontroller {\n     \n         @RequestMapping(\"/\")\n         public String test(){\n             return \"Hello Spring Boot\";\n         }\n     }\n     ```\n\n4. 创建启动类\n\n   - ```java\n     @SpringBootApplication\n     public class MainApplication {\n         public static void main(String[] args) {\n     \t\tSpringApplication.run(MainApplication.class, args);\n         }\n     }\n     ```\n\n5. 创建完成\n\n6. 运行项目\n\n\n\n# 三、打包成jar包\n\n不同于之前的SSM框架时需要将项目打包成war包，SpringBoot可以直接将项目打包成jar包\n\njar包中自带了tomcat服务器，不需要再部署Tomcat服务器\n\n1. 导入插件\n\n   - ```xml\n     <build>\n         <plugins>\n             <!--将spring boot 项目打包成jar包-->\n             <plugin>\n                 <groupId>org.springframework.boot</groupId>\n                 <artifactId>spring-boot-maven-plugin</artifactId>\n             </plugin>\n         </plugins>\n     </build>\n     ```\n\n2. Maven工具打包\n\n   - ![image-20210820160714925](Spring%20Boot.assets/image-20210820160714925.png)\n\n   - ![image-20210820160850313](Spring%20Boot.assets/image-20210820160850313.png)\n\n3. 命令行打包\n\n   - 执行命令\n\n     - ```shell\n       mvn package#打包主项目\n       mvn -f [子项目] clean package#打包子项目\n       ```\n\n   - 在target目录下会生成jar包\n\n   \n\n4. 执行jar包\n\n   - ```shell\n     java -jar [包名]\n     ```\n\n     \n\n# 四、简单自动配置原理\n\n## 1.依赖管理\n\n当我们在项目中引入`mysql`的依赖时\n\n```xml\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n</dependency>\n```\n\n可以看到依赖中并没有指明版本号，这是因为SpringBoot的依赖管理起到了作用\n\n在项目中的`pom.xml`中依赖了一个父项目\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.3.3.RELEASE</version>\n</parent>\n```\n\n在`spring-boot-starter-parent`又有一个父项目\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-dependencies</artifactId>\n    <version>2.3.3.RELEASE</version>\n</parent>\n```\n\n在`spring-boot-dependencies`中定义了几乎所有常用的依赖的版本号，下面以mysql为例\n\n\n\n![image-20210820162107959](Spring%20Boot.assets/image-20210820162107959.png)\n\n![image-20210820162046182](Spring%20Boot.assets/image-20210820162046182.png)\n\nmysql的版本已经在`spring-boot-dependencies`中指定了，这里指定的版本被称为SpringBoot的仲裁版本，这种机制被称为`SpringBoot自动版本仲裁机制`\n\nmysql的版本并不是固定写死的，而是通过配置项的方式写入的\n\n在我们想要使用指定版本的依赖，不想使用`SpringBoot仲裁的版本号`时，可以在`pom.xml`中指定自己想要的版本号\n\n```xml\n<properties>\n    <mysql.version>8.0.26</mysql.version>\n</properties>\n```\n\n![image-20210820163030549](Spring%20Boot.assets/image-20210820163030549.png)\n\n\n\n==需要注意的是：在我们引入官方未定义的jar包时就必须的声明版本号了==\n\n## 2.场景启动器（starter）\n\n在我们启动SpringBoot项目后，我们的`pom.xml`中并未手动引入`SpringMVC`相关的依赖，但是我们能够使用它的所有功能，这就受益于SpringBoot的启动器\n\n在`pom.xml`中我们引入了这个依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n这个依赖就是SpringBoot的启动器，`spring-boot-starter-web`这个启动器包含了Web开发中所有常规的依赖，不需要手动引入依赖，SpringBoot已经帮我们引入好了\n\nSpringBoot有非常多的启动器，官方的启动器都有统一的命名规则:`spring-boot-starter-*`,其中的`*`代表的各种开发场景，详细的启动器可以参考官方文档：https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters\n\nSpringBoot不仅可以使用官方定义的启动器，也可以自定义启动器\n\n## 3.自动配置\n\n### 功能配置\n\n在SpringBoot的`spring-boot-starter-web`中，项目可以直接运行，无须配置`dispatcherServlet`来接请求，同时项目是可以直接输出中文的，你可以将`Testcontroller`类中的返回文本中加入中文，并不会出现乱码问题，这是因为SpringBoot已经将SpringMVC中常用的功能自动配置好了，我们可以通过下面的代码来查看自动配置了哪些功能\n\n```java\n@SpringBootApplication\npublic class MainApplication {\n    public static void main(String[] args) {\n        // 获取上下文对象，也就是IOC容器\n        ConfigurableApplicationContext applicationContext = SpringApplication.run(MainApplication.class, args);\n        // 可以通过getBeanDefinitionNames来获取容器里面的组件名\n        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();\n        for (String beanDefinitionName : beanDefinitionNames) {\n            System.out.println(beanDefinitionName);\n        }\n    }\n}\n```\n\n可以在输出结果中搜索`dispatcherServlet`\n\n![image-20210821132514870](Spring%20Boot.assets/image-20210821132514870.png)\n\n像`characterEncodingFilter`等SpringMVC的常用配置也已经存在于IOC容器中，已经由SpringBoot自动配置完成\n\n\n\n### 自动包扫描\n\nSpringBoot不需要配置包扫描，SpringBoot会自动扫描`启动类所在的包及其子包`\n\n```\ncom\n +- example\n     +- myapplication\n         +- MyApplication.java\n         |\n         +- customer\n         |   +- Customer.java\n         |   +- CustomerController.java\n         |   +- CustomerService.java\n         |   +- CustomerRepository.java\n         |\n         +- order\n             +- Order.java\n             +- OrderController.java\n             +- OrderService.java\n             +- OrderRepository.java\n```\n\n- 改变扫描路径`@SpringBootApplication(scanBasePackages = {\"xyz.pandacode\"})`\n\n# 五、自动装配所需技术\n\n## 1.配置类\n\n```java\npublic class Pet {\n    private String name;\n    public Pet() {\n    }\n    public Pet(String name) {\n        this.name = name;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    @Override\n    public String toString() {\n        return \"Pet{\" +\n                \"name='\" + name + '\\'' +\n                '}';\n    }\n}\n```\n\n\n\n```java\n/**\n * 注解 @Configuration 用于指明当前类为配置类，相当于之前的beans.xml\n * 其中的 proxyBeanMethods参数 用于指定是否使用代理方式返回配置类对象，默认为true\n * 也就是在调用配置类对象时，调用其中的方法创建的对象也是单实例的\n *\n * proxyBeanMethods用于处理组件依赖问题\n * Full：proxyBeanMethods = true\n * Lite：proxyBeanMethods = false\n */\n@Configuration\npublic class MyConfigClass {\n    /**\n     * 注解 @Bean 表示使用当前方法创建一个Bean\n     * 默认为方法名作为Bean的名字\n     * 可以使用@Bean的默认参数指定Bean名字\n     * @return 返回Bean对象，交给IOC容器，创建的对象时单实例的\n     */\n    @Bean\n    public Pet pet(){\n        return new Pet(\"TomCat\");\n    }\n}\n```\n\n\n\n```java\n@SpringBootApplication\npublic class MainApplication {\n    public static void main(String[] args) {\n        // 获取上下文对象，也就是IOC容器\n        ConfigurableApplicationContext applicationContext = SpringApplication.run(MainApplication.class, args);\n\n        // 获取配置类配置的Bean\n        Pet pet = applicationContext.getBean(\"pet\", Pet.class);\n        System.out.println(\"pet Bean：\"+pet);\n\n        // 验证配置类的Bean是否为单实例\n        Pet pet1 = applicationContext.getBean(\"pet\", Pet.class);\n        Pet pet2 = applicationContext.getBean(\"pet\", Pet.class);\n        System.out.println(\"是否为单实例：\"+(pet1 == pet2));\n\n        // 验证配置类是否为组件\n        MyConfigClass myConfigClass = applicationContext.getBean(MyConfigClass.class);\n        System.out.println(\"配置类对象：\"+myConfigClass);\n\n        // 验证调用配置类方法是否为单实例对象\n        Pet pet3 = myConfigClass.pet();\n        Pet pet4 = myConfigClass.pet();\n        System.out.println(\"配置类创建是否为单实例：\"+(pet3 == pet4));\n    }\n}\n```\n\n## 2.条件装配\n\n> `@Conditional`\n>\n> ![image-20210821143205214](Spring%20Boot.assets/image-20210821143205214.png)\n>\n> \n\n```java\n@Configuration\npublic class MyConfigClass {\n\n\t// 此处将user方法的@Bean注释，清除IOC中的user组件\n    //@Bean\n    public User user(){\n        return new User(\"张三\",18);\n    }\n    \n    // 在类中的顺序也会影响@Conditional的结果\n    @ConditionalOnBean(name = \"user\") // 当容器中有name=\"user\"的组件才加载\n    @Bean\n    public Pet pet(){\n        return new Pet(\"TomCat\");\n    }\n}\n```\n\n```java\n@SpringBootApplication\npublic class MainApplication {\n    public static void main(String[] args) {\n        // 1.获取上下文对象，也就是IOC容器\n        ConfigurableApplicationContext applicationContext = SpringApplication.run(MainApplication.class, args);\n\n        // 验证装配\n        boolean user = applicationContext.containsBean(\"user\");\n        boolean pet = applicationContext.containsBean(\"pet\");\n        System.out.println(\"user:\"+user);\n        System.out.println(\"pet:\"+pet);\n    }\n}\n```\n\n此时的结果为：\n\n```\nuser:false\npet:false\n// 两者皆未装配\n```\n\n\n\n将`MyConfigClass`中的user方法的`@Bean`注解取消注释后,结果为：\n\n```\n\n```\n\n\n\n## 3.将xml配置引入配置类\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"user01\" class=\"xyz.pandacode.bean.User\">\n        <property name=\"name\" value=\"李四\"/>\n        <property name=\"age\" value=\"19\"/>\n    </bean>\n</beans>\n```\n\n```java\npackage xyz.pandacode.config;\n\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.ImportResource;\nimport xyz.pandacode.bean.Pet;\nimport xyz.pandacode.bean.User;\n\n/**\n * 注解 @Configuration 用于指明当前类为配置类，相当于之前的beans.xml\n * 其中的 proxyBeanMethods参数 用于指定是否使用代理方式返回配置类对象，默认为true\n * 也就是在调用配置类对象时，调用其中的方法创建的对象也是单实例的\n *\n * proxyBeanMethods用于处理组件依赖问题\n * Full：proxyBeanMethods = true\n * Lite：proxyBeanMethods = false\n */\n@Configuration\n@ImportResource(\"classpath:beans.xml\")\npublic class MyConfigClass {\n}\n```\n\n```java\n@SpringBootApplication\npublic class MainApplication {\n    public static void main(String[] args) {\n        // 1.获取上下文对象，也就是IOC容器\n        ConfigurableApplicationContext applicationContext = SpringApplication.run(MainApplication.class, args);\n\n        // 5.验证xml转配置类\n        boolean user01 = applicationContext.containsBean(\"user01\");\n        System.out.println(\"xml转配置类：\"+user01);\n\n    }\n}\n```\n\n## 4.配置绑定\n\napplication.properties\n\n```properties\ncar.name=BYD\ncar.price=100000\n```\n\n> `@ConfigurationProperties`\n>\n> 此注解的value属性和prefix为同一值\n>\n> 作用都是指明配置在`application.properties`的前缀\n>\n> 例如此处前缀就是`car`\n\n### 方式一\n\n此方法适用于自定义的类\n\n```java\n@Component\n@ConfigurationProperties(prefix = \"car\")\npublic class Car {\n    private String name;\n    private Integer price;\n\n    public Car() {\n    }\n\n    public Car(String name, int price) {\n        this.name = name;\n        this.price = price;\n    }\n\t...Getter&Setter\n    ...toString\n}\n```\n\n```java\n@SpringBootApplication\npublic class MainApplication {\n    public static void main(String[] args) {\n        // 1.获取上下文对象，也就是IOC容器\n        ConfigurableApplicationContext applicationContext = SpringApplication.run(MainApplication.class, args);\n\n\n        // 6.验证配置绑定,方式一\n        Car car = applicationContext.getBean(\"car\", Car.class);\n        System.out.println(car);\n\n    }\n}\n```\n\n### 方式二\n\n此方法适用于自定义和第三方类\n\n```java\n@Configuration\n@EnableConfigurationProperties(Car.class)\npublic class MyConfigClass {\n}\n```\n\n```java\n@ConfigurationProperties(prefix = \"car\")\npublic class Car {\n    private String name;\n    private Integer price;\n    \n    public Car() {\n    }\n\n    public Car(String name, int price) {\n        this.name = name;\n        this.price = price;\n    }\n\t...Getter&Setter\n    ...toString\n}\n```\n\n```java\n@SpringBootApplication\npublic class MainApplication {\n    public static void main(String[] args) {\n        // 1.获取上下文对象，也就是IOC容器\n        ConfigurableApplicationContext applicationContext = SpringApplication.run(MainApplication.class, args);\n\n        // 6.验证配置绑定,方式二\n        Car car = applicationContext.getBean(Car.class);\n        System.out.println(car);\n\n    }\n}\n```\n\n### 配置注解执行器\n\n当你在类上配置了`@ConfigurationProperties`之后，IDEA会提示一个警告\n\n![image-20210822101646502](Spring%20Boot.assets/image-20210822101646502.png)\n\n这行警告不影响程序的运行，意思是`Spring Boot配置注解执行器没有配置`\n\n配置注解执行器可以在配置文件中提示配置类的信息：\n\n![image-20210822101849266](Spring%20Boot.assets/image-20210822101849266.png)\n\n当我们的项目中配置好了配置注解执行器之后，我们的配置绑定的属性也会有提示，配置方法如下：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n    <optional>true</optional>\n</dependency>\n```\n\n刷新Maven，重构项目即可使用，效果如下\n\n![image-20210822102622523](Spring%20Boot.assets/image-20210822102622523.png)\n\n最后，我们需要在打包插件中排除这配置注解执行器，因为它在打包后对功能是没有任何影响的，只是为了在开发时提供便利\n\n```xml\n<!--将spring boot 项目打包成jar包-->\n<plugin>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-maven-plugin</artifactId>\n    <configuration>\n        <excludes>\n            <!-- 排除 配置注解执行器 -->\n            <exclude>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-configuration-processor</artifactId>\n            </exclude>\n        </excludes>\n    </configuration>\n</plugin>\n```\n\n打包后查看jar包中没有`spring-boot-configuration-processor-2.3.3.RELEASE.jar`这个包，就说明排除成功了\n\n# 六、底层自动装配原理\n\n## 1.@SpringBootApplication\n\n进入`@SpringBootApplication`之后，可以看到以下注解\n\n```java\n...元注解\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {}\n```\n\n下面对每个注解进行研究\n\n### @SpringBootConfiguration\n\n```java\n@Configuration\npublic @interface SpringBootConfiguration {}\n```\n\n很明显`@Configuration`表示这是一个配置类，这也就说明了`MainApplication`实际上也是一个配置类\n\n### @EnableAutoConfiguration\n\n这个注解是三个中最重要的一个\n\n```java\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {}\n```\n\n#### @AutoConfigurationPackage\n\n进入`@AutoConfigurationPackage`可以看到\n\n```java\n@Import(AutoConfigurationPackages.Registrar.class)\npublic @interface AutoConfigurationPackage {}\n```\n\n也就是说实际上`@AutoConfigurationPackage`引入了一个名为`AutoConfigurationPackages.Registrar`的内部类组件，我们进入其中\n\n```java\nstatic class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {\n\n\t\t@Override\n\t\tpublic void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n\t\t\tregister(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));\n            // new PackageImports(metadata).getPackageNames()\n            // 获取metadata所在的包的包名，metadata标在MainApplication上\n            // 所以此行读取的是MainApplication所在的包的包名\n\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<Object> determineImports(AnnotationMetadata metadata) {\n\t\t\treturn Collections.singleton(new PackageImports(metadata));\n\t\t}\n\n\t}\n```\n\n可以看到这个类实现的是批量注册的功能\n\n我们在`register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));`这一行打下断点，Debug一下\n\n计算一下`new PackageImports(metadata).getPackageNames()`的值，得到如下结果\n\n![image-20210821153049256](Spring%20Boot.assets/image-20210821153049256.png)\n\n也就是说，这个组件实际功能是将`MainApplication`所在的包进行注册，这也就解释了为什么默认自动包扫描要求必须在`MainApplication所在包及其子包下`了\n\n#### @Import(AutoConfigurationImportSelector.class)\n\n进入`AutoConfigurationImportSelector`\n\n```java\npublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n    if (!isEnabled(annotationMetadata)) {\n        return NO_IMPORTS;\n    }\n    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);\n    return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());\n}\n```\n\n其中的`getAutoConfigurationEntry(annotationMetadata)`是整个方法的核心，进入这个方法\n\n```java\nprotected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {\n\t\tif (!isEnabled(annotationMetadata)) {\n\t\t\treturn EMPTY_ENTRY;\n\t\t}\n\t\tAnnotationAttributes attributes = getAttributes(annotationMetadata);\n\t\tList<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);\n\t\tconfigurations = removeDuplicates(configurations);\n\t\tSet<String> exclusions = getExclusions(annotationMetadata, attributes);\n\t\tcheckExcludedClasses(configurations, exclusions);\n\t\tconfigurations.removeAll(exclusions);\n\t\tconfigurations = getConfigurationClassFilter().filter(configurations);\n\t\tfireAutoConfigurationImportEvents(configurations, exclusions);\n\t\treturn new AutoConfigurationEntry(configurations, exclusions);\n\t}\n```\n\n我们先在`configurations = removeDuplicates(configurations);`这一行打个断电并Debug，可以得到下面的结果，显示`configurations`共计127个，记住这个数字\n\n![image-20210821161106658](Spring%20Boot.assets/image-20210821161106658.png)\n\n很明显`getCandidateConfigurations(annotationMetadata, attributes);`是整段的核心，因为下面操作的所有`configurations`都是从他这获取的,进入\n\n```java\n\tprotected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n\t\tList<String> configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),\n\t\t\t\tgetBeanClassLoader());\n\t\tAssert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \"\n\t\t\t\t+ \"are using a custom packaging, make sure that file is correct.\");\n\t\treturn configurations;\n\t}\n```\n\n`SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),\n\t\t\t\tgetBeanClassLoader());`此处调用了`SpringFactoriesLoader`,我们进去看看加载了什么\n\n```java\npublic static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {\n    String factoryTypeName = factoryType.getName();\n    return (List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());\n}\n```\n\n进入`(List)loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());`查看具体加载了什么\n\n```java\nprivate static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {\n        MultiValueMap<String, String> result = (MultiValueMap)cache.get(classLoader);\n        if (result != null) {\n            return result;\n        } else {\n            try {\n                Enumeration<URL> urls = classLoader != null ? classLoader.getResources(\"META-INF/spring.factories\") : ClassLoader.getSystemResources(\"META-INF/spring.factories\");\n                LinkedMultiValueMap result = new LinkedMultiValueMap();\n\n                while(urls.hasMoreElements()) {\n                    URL url = (URL)urls.nextElement();\n                    UrlResource resource = new UrlResource(url);\n                    Properties properties = PropertiesLoaderUtils.loadProperties(resource);\n                    Iterator var6 = properties.entrySet().iterator();\n\n                    while(var6.hasNext()) {\n                        Entry<?, ?> entry = (Entry)var6.next();\n                        String factoryTypeName = ((String)entry.getKey()).trim();\n                        String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());\n                        int var10 = var9.length;\n\n                        for(int var11 = 0; var11 < var10; ++var11) {\n                            String factoryImplementationName = var9[var11];\n                            result.add(factoryTypeName, factoryImplementationName.trim());\n                        }\n                    }\n                }\n\n                cache.put(classLoader, result);\n                return result;\n            } catch (IOException var13) {\n                throw new IllegalArgumentException(\"Unable to load factories from location [META-INF/spring.factories]\", var13);\n            }\n        }\n    }\n```\n\n最终我们找到了SpringBoot到底加载了什么：`\"META-INF/spring.factories\"`\n\n当我们想要找到这个文件时，会发现有很多个相同文件\n\n![image-20210821160358001](Spring%20Boot.assets/image-20210821160358001.png)\n\n![image-20210821160625521](Spring%20Boot.assets/image-20210821160625521.png)\n\n其中最核心的就是`spring-boot-autoconfigure-2.3.3.RELEASE.jar/META-INF/spring.factories`,其中最核心的就是下面的这些\n\n```properties\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\norg.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.r2dbc.R2dbcTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\\norg.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\\norg.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\\norg.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\\norg.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\\norg.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\\norg.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\\norg.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\\norg.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\\norg.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\\norg.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\\norg.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\\norg.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\\norg.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\\norg.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\\norg.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\\norg.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\\norg.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration\n```\n\n去掉第一行的注释和第二行的键名，总共127(129-2)行，对比上面打断点得到的结果，数量和内容都相同，可以得出结论，SpringBoot在启动时将这127个自动配置类全部加载了\n\n但是我们去看自动配置时IOC容器内的组件并不是全部包含了上面所有的127个，而是只有其中的几个\n\n这时我们需要随便挑一个`spring-boot-autoconfigure-2.3.3.RELEASE.jar`中的我们没有用到的`AutoConfiguration`类，进去一探究竟，以`spring-boot-autoconfigure-2.3.3.RELEASE.jar/org/jdbc/DataSourceAutoConfiguration`为例\n\n```java\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })\n@ConditionalOnMissingBean(type = \"io.r2dbc.spi.ConnectionFactory\")\n@EnableConfigurationProperties(DataSourceProperties.class)\n@Import({ DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class })\npublic class DataSourceAutoConfiguration {}\n```\n\n`@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })`这一行注解起到了决定性的作用，`ConditionalOnClass`保证了只有在IOC中存在了`DataSource`和`EmbeddedDatabaseType`类时才加载这个组件，因此虽然引入了JDBC的自动配置类，但实际上因为JDBC并未使用，所以它并未加载\n\n这就是SpringBoot自动配置的按需开启\n\n## 2.自动装配过程\n\n1. SpringBoot 加载所有自动配置类，`xxxAutoConfiguration`\n2. 自动配置类按需生效\n3. 生效的自动配置类去`xxxProperties`类中找默认值，如果有自定义配置优先自定义配置\n   - `xxxProperties`类会优先去找`application.properties`中的值\n4. 配置完成后放入容器中生效，也就有了该功能\n\n\n\n- 定制化配置\n  1. 自定义Bean对象替换容器中官方定义的\n  2. 查看类中定义的配置项或查官方文档，修改配置文件\n\n# 七、yaml 和 配置文件\n\n## 1.yaml\n\n- `:`后的`空格`一定不等省\n- `#`表示注释\n- 使用缩进控制层级\n- 文本类型数据可以不加`''`或`\"\"`\n- `''`包裹的字符串会作为纯字符串，也就是会取消转义\n- `\"\"`包裹的字符串会进行转义操作，其中的`\\n`等字符会被转义\n- 松散匹配，假设属性名为`lastName`,下面的配置命名方式都是正确的\n  - last-name\n  - last_name \n  - lastName\n  - lastname\n  - LASTNAME\n\n```yaml\n# 字面量\nname: a # String\nage: 18 # Integer\nbirthday: 1999/01/01 # Date\nisboss: true # Boolean\n\n\n\n# 对象、Map\nstudent1: \n  name: a\n  age: 18\n\t\nstudent2: {name: a,age: 18}\n\n# 数组、Array\npets1:\n  - cat\n  - dog\n\t\npets2: [cat,dog]\n\n# 复杂对象直接利用上面的组合即可\n```\n\n## 2.配置文件\n\n- 官方文档地址：[https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html](https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html)\n- 配置文件默认位置为：\n  - `src/resources/application.properties`\n  - `src/resources/application.yaml` 或 `src/resources/application.yml`\n  - 以上两种配置文件是可以共存的\n  - 加载顺序是**yml>yaml>properties**\n  - 因为`properties`最后加载，所以会覆盖前两种，所以`properties`的优先级最高\n- banner\n  - [自定义启动Banner在线生成工具](https://www.bootschool.net/ascii)\n  - 在配置文件同级目录创建banner.txt\n\n# 八、Web核心功能\n\n## 1.静态资源\n\n官方文档地址：https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-web-applications.spring-mvc.static-content\n\n静态资源配置源代码所在路径：`spring-boot-autoconfigure-2.3.3.RELEASE.jar!\\org\\springframework\\boot\\autoconfigure\\web\\servlet\\WebMvcAutoConfiguration`\n\n\n\n### 默认目录\n\n> 静态资源目录默认路径\n>\n> - 注意：下面的路径都是在IDEA中`resources`目录下\n>\n> - `/static`\n>\n> - `/resources`\n>\n> - `/public`\n>\n> - `/META-INF/resources`\n>\n> - 生效优先级\n>\n>   1. `/META-INF/resources`\n>   2. `/resources`\n>   3. `/static`\n>   4. `/public`\n>\n>   - 这是我测试得出的，不知道为什么与网上测试结果不同，测试使用的是图片，SpringBoot2.3.3\n>\n> - 发现\n>\n>   - 项目启动时可能会对已有的静态资源进行扫描\n>   - 此时已经有的资源会被加载到内存（删除本地文件后依旧能访问到）\n>   - 项目启动后，再向静态资源文件夹中添加的文件是无法被访问的（进一步印证上面的猜想）\n>   - 但是这只是猜想，我还并未确定\n\n### 自定义目录\n\n```yaml\nspring:\n  resources:\n    static-locations: classpath:/r/ # 单个路径可以直接写\n    \n# ======================================================\n\nspring:\n  resources:\n    static-locations: [classpath:/r/] # 多个需要数组格式，当然两种数组格式都可以\n```\n\n不如直接进去看看源码\n\n```java\nprivate static final String[] CLASSPATH_RESOURCE_LOCATIONS = { \n    \"classpath:/META-INF/resources/\",\n    \"classpath:/resources/\", \n    \"classpath:/static/\", \n    \"classpath:/public/\" \n};\npublic void setStaticLocations(String[] staticLocations) {\n    this.staticLocations = appendSlashIfNecessary(staticLocations);\n}\nprivate String[] appendSlashIfNecessary(String[] staticLocations) {\n    String[] normalized = new String[staticLocations.length];\n    for (int i = 0; i < staticLocations.length; i++) {\n        String location = staticLocations[i];\n        normalized[i] = location.endsWith(\"/\") ? location : location + \"/\";\n    }\n    return normalized;\n}\n```\n\n上面的常量定义了所有静态资源目录，`appendSlashIfNecessary`函数用于添加自定义的静态资源目录，并且还贴心的帮你做了检查，检查你的结尾是否有`/`，也就是说其实你的配置中你不写结尾的`/`也是能识别的，我在`this.staticLocations = appendSlashIfNecessary(staticLocations);`打了断点，执行后的结果为 `this.staticLocations == [\"classpath:/r/\"]`,其实看源码能得到同样的结果\n\n在这里我得到了和网上教程不同的结果：\n\n- 在自定义静态资源路径后：` \"/resources/\" `、`\"/static/\"`、`\"/public/\"`，这三个路径全部都失效了\n- 但是和网上教程不同的是，我测试的`/META-INF/resources/`这个路径并未失效，而是可以和自定义路径同时生效，生效优先级为：`自定义 > /META-INF/resources/`\n\n### 处理过程\n\n官方文档中已经指明了web项目的静态资源是处理的`/**`请求，也就是说请求发来后不论是动态资源还是静态资源都会执行以下步骤\n\n1. 将请求交给Controller查看是否为动态资源\n2. 将所有没被Controller处理的请求交给静态资源处理器\n3. 还未匹配，返回404\n\n### 静态资源前缀\n\n静态资源前缀在设置拦截器是会非常有用，在配置全局拦截器时拦截的路径是`/**`，也会拦截到静态资源，所以我们需要区分静态资源和动态资源\n\n```yaml\nspring:\n  mvc:\n    static-path-pattern: /res/**\n```\n\n`static-path-pattern`指定了访问静态资源的路径匹配模式，其中`res`为静态资源路径的前缀，设置后所有的静态资源都需要使用`http://localhost:8080/res/xxx.jpg`的形式来获取静态资源\n\n### WebJars\n\n> WebJars\n>\n> WebJars是一种将前端静态资源封装成Jar包的方式\n>\n> WebJars官网：https://www.webjars.org/\n\n```xml\n<!-- WebJars jquery -->\n<dependency>\n    <groupId>org.webjars</groupId>\n    <artifactId>jquery</artifactId>\n    <version>3.6.0</version>\n</dependency>\n```\n\n- 记得导入后重启项目，热部署是无效的\n\n- 通过`http://localhost:8080/webjars/静态资源`的形式访问路径\n- 例如:`http://localhost:8080/webjars/jquery/3.6.0/jquery.js`\n- 查看Jar包\n  - ![image-20210822173751378](Spring%20Boot.assets/image-20210822173751378.png)\n  - 本质是利用了`/META-INF/resources/`静态资源路径来访问静态资源\n\n### 静态资源加载实现源码\n\n```java\n@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n    // 判断是否禁用了静态资源加载\n    if (!this.resourceProperties.isAddMappings()) {\n        logger.debug(\"Default resource handling disabled\");\n        return;\n    }\n    // 获取缓存持续时间\n    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();\n    // 获取缓存控制器\n    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();\n    \n    // 处理WebJars，注册资源路径，设置缓存\n    if (!registry.hasMappingForPattern(\"/webjars/**\")) {\n        customizeResourceHandlerRegistration(registry.addResourceHandler(\"/webjars/**\")\n                                             .addResourceLocations(\"classpath:/META-INF/resources/webjars/\")                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n        \n    }\n    // 获取静态资源目录\n    String staticPathPattern = this.mvcProperties.getStaticPathPattern();\n    // 设置静态资源目录，注册目录，添加缓存\n    if (!registry.hasMappingForPattern(staticPathPattern)) {\n        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)\n                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))\n                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n    }\n}\n```\n\n\n\n## 2.欢迎页&页签图标\n\n### 欢迎页\n\n在静态资源目录中添加一个`index.html`，这个HTML就会被作为欢迎页面，访问`localhost:8080`即可查看\n\n==SpringBoot在此处设置为：==当你设置了静态资源前缀后，欢迎页将失效\n\n当然也不是没有解决方案，使用动态设置的欢迎页即可，在开启静态资源前缀后使用下面的Controller可以实现相同功能那个\n\n```java\n@RequestMapping(\"/\")\npublic String index(){\n    return \"/res/index.html\";\n}\n```\n\n### 欢迎页源码分析\n\n```java\nWelcomePageHandlerMapping(TemplateAvailabilityProviderstemplateAvailabilityProviders,ApplicationContext applicationContext,Optional<Resource> welcomePage,String staticPathPattern) {\n    // 此处做了判断，如果设置了静态资源前缀则欢迎页失效\n    if (welcomePage.isPresent() && \"/**\".equals(staticPathPattern)) {\n        logger.info(\"Adding welcome page: \" + welcomePage.get());\n        setRootViewName(\"forward:index.html\");\n    }\n    else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) {\n        logger.info(\"Adding welcome page template: index\");\n        setRootViewName(\"index\");\n    }\n}\n```\n\n### 页签图标\n\n- 自动配置页签图标\n\n  - 需要在静态资源目录中放入`favicon.ico`这个页签图标文件\n  - ==SpringBoot在此处为：==当你设置了静态资源前缀后，自动配置页签图标功能将失效\n\n- 手动配置页签图标\n\n  - 在HTML中放入如下代码，即可在配置了静态资源前缀后仍旧能够使用页签图标\n\n  - ```html\n    <link rel=\"shortcut icon\" href=\"/res/favicon.ico\"/>\n    ```\n\n## 3.请求映射原理\n\n请求映射需要从`DispatcherServlet`开始，通过这个类向下查找，最后找到`HttpServlet`可以得到如下继承树\n\n![image-20210823151055144](Spring%20Boot.assets/image-20210823151055144.png)\n\n在`HttpServletBean`中并没有`doGet`、`doPost`方法，向上查找，可在`FrameworkServlet`中找到\n\n![image-20210823151238075](Spring%20Boot.assets/image-20210823151238075.png)\n\n查看源代码：\n\n```java\n@Override\nprotected final void doGet(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n    processRequest(request, response);\n}\n```\n\n```java\nprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n\t// ...............\n    try {\n        doService(request, response);\n    }\n\t// .................\n}\n```\n\n继续查找`doService`会发现是一个抽象方法\n\n```java\nprotected abstract void doService(HttpServletRequest request, HttpServletResponse response)throws Exception;\n```\n\n那就继续向子类查找，可以在`DispatcherServlet`中找到具体实现\n\n```java\n@Override\nprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n   // ...........\n   try {\n      doDispatch(request, response);\n   }\n   // ...........\n}\n```\n\n继续找到`doDispatch`具体实现：\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t// ........\n            // 决定当前请求由哪个类的哪个方法处理\n            mappedHandler = getHandler(processedRequest);\n            if (mappedHandler == null) {\n                noHandlerFound(processedRequest, response);\n                return;\n            }\n\t// ........\n}\n\n```\n\n```java\n@Nullable\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    if (this.handlerMappings != null) {\n        for (HandlerMapping mapping : this.handlerMappings) {\n            HandlerExecutionChain handler = mapping.getHandler(request);\n            if (handler != null) {\n                return handler;\n            }\n        }\n    }\n    return null;\n}\n```\n\n在`if (this.handlerMappings != null)`处，打下断点，可以得到如下结果\n\n![image-20210823161027322](Spring%20Boot.assets/image-20210823161027322.png)\n\n![image-20210823155337651](Spring%20Boot.assets/image-20210823155337651.png)\n\n可以看到在`RequestMappingHandlerMapping`中保存了所有的路径映射信息，包括映射路径和处理方法\n\n- 执行步骤\n  1. 进入`doDispatch`，执行`getHandler`方法\n  2. `getHandler`方法中的`handlerMappings `属性存储了所有handlerMapping，包括`RequestMappingHandlerMapping`、SpringBoot内置的欢迎页handlerMapping：`WelcomePageHandlerMapping`等等\n  3. `getHandler`方法会遍历所有的handlerMapping，找到一个能够匹配请求的\n- 通过查看源码，我们发现我们可以自定义`handlerMapping`，并将其放入容器中即可生效\n\n\n\n## 4.请求处理\n\n### Rest风格\n\n> Rest风格\n>\n> 之前的请求是以请求路径作为区分动作的类型，这些都是操作同一对象的动作，但是分成了很多个小功能\n>\n> 例如：\n>\n> - /getUser 请求用户\n> - /delUser 删除用户\n> - /editUser 修改用户\n> - /saveUser 增加用户\n>\n> Rest风格则是将所有的请求路径都统一，通过HTTP请求的动作来区分操作类型\n>\n> 例如：\n>\n> - /user GET请求 请求用户\n> - /user POST请求 添加用户\n> - /user PUT请求 修改用户\n> - /user DELETE请求 删除用户\n\n- 开启HTML的Rest风格支持\n\n  - ```yaml\n    spring:\n      mvc:\n        hiddenmethod:\n          filter:\n            enabled: true\n    ```\n\n- 默认支持原生的Rest风格，不需要开启，但HTML无法发送PUT、DELETE请求，所以需要手动开启\n\n\n\n```java\n//@RequestMapping(value = \"/user\",method = RequestMethod.GET)\n    @GetMapping(\"/user\")\n    public String getUser(){\n        return \"GET user，获取用户\";\n    }\n    //@RequestMapping(value = \"/user\",method = RequestMethod.POST)\n    @PostMapping(\"/user\")\n    public String addUser(){\n        return \"POST user，添加用户\";\n    }\n    //@RequestMapping(value = \"/user\",method = RequestMethod.PUT)\n    @PutMapping(\"/user\")\n    public String editUser(){\n        return \"PUT user，修改用户\";\n    }\n\n    //@RequestMapping(value = \"/user\",method = RequestMethod.DELETE)\n    @DeleteMapping(\"/user\")\n    public String delUser(){\n        return \"Delete user，删除用户\";\n    }\n```\n\n#### HTML Rest 风格源码\n\n```java\n@Bean\n@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)\n@ConditionalOnProperty(prefix = \"spring.mvc.hiddenmethod.filter\", name = \"enabled\", matchIfMissing = false)\npublic OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {\n   return new OrderedHiddenHttpMethodFilter();\n}\n\n// =========================\n// 这个过滤器是为了处理HTML无法发送PUT、DELETE等方法的，原生方法不受此过滤器影响\npublic class HiddenHttpMethodFilter extends OncePerRequestFilter {\n    // 支持的请求类型\n    private static final List<String> ALLOWED_METHODS =\n\t\t\tCollections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(),\n\t\t\t\t\tHttpMethod.DELETE.name(), HttpMethod.PATCH.name()));\n\t...........\n\t@Override\n\tprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tHttpServletRequest requestToUse = request;\n\t\t// 指定了必须为POST方法\n\t\tif (\"POST\".equals(request.getMethod()) && request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) {\n\t\t\tString paramValue = request.getParameter(this.methodParam);\n\t\t\tif (StringUtils.hasLength(paramValue)) {\n                // 自动转为大写，所以前端参数不区分大小写\n\t\t\t\tString method = paramValue.toUpperCase(Locale.ENGLISH);\n                // 判断是否为支持的请求\n\t\t\t\tif (ALLOWED_METHODS.contains(method)) {\n\t\t\t\t\trequestToUse = new HttpMethodRequestWrapper(request, method);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfilterChain.doFilter(requestToUse, response);\n\t}\n\t..........\n}\n\n```\n\n#### HTML Rest 前端配置\n\n因为HTML表单无法发送put、delete等方法，所以表单提交时需要携带`_method`参数而且必须使用`post`方式携带参数，此参数用来区别HTTP请求的方法\n\n```html\n<h2>GET</h2>\n<form action=\"/user\" method=\"get\">\n    <button type=\"submit\">获取用户</button>\n</form>\n<h2>POST</h2>\n<form action=\"/user\" method=\"post\">\n    <button type=\"submit\">添加用户</button>\n</form>\n<h2>PUT</h2>\n<form action=\"/user\" method=\"post\">\n    <input type=\"hidden\" name=\"_method\" value=\"put\">\n    <button type=\"submit\">修改用户</button>\n</form>\n<h2>DELETE</h2>\n<form action=\"/user\" method=\"post\">\n    <input type=\"hidden\" name=\"_method\" value=\"delete\">\n    <button type=\"submit\">删除用户</button>\n</form>\n```\n\n#### 修改Rest默认参数名\n\n- 配置类中添加如下代码即可\n\n```java\n@Bean\npublic HiddenHttpMethodFilter hiddenHttpMethodFilter(){\n    HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();\n    hiddenHttpMethodFilter.setMethodParam(\"_m\"); // 修改默认的参数名\n    return hiddenHttpMethodFilter;\n}\n```\n\n### 请求参数\n\n#### 请求参数\n\n```java\n@GetMapping(\"/parameter\")\npublic Map<String,Object> parameter(@RequestParam String name,\n                                    @RequestParam Integer id,\n                                    @RequestParam Map<String,String> kv,\n                                    @RequestParam MultiValueMap<String,String> multiValueMap){\n    // RequestParam有三种获取方式\n    // 1. 直接获取\n    // 2. Map<String,String> , 注意：即使写成Map<String,Object>，取出来的依旧是String类型\n    // 3. MultiValueMap<String,String>\n    HashMap<String, Object> map = new HashMap<String, Object>();\n    map.put(\"name\",name);\n    map.put(\"id\",id);\n    map.put(\"kv\",kv);\n    map.put(\"MultiValueMap\",multiValueMap);\n    return map;\n}\n```\n\n#### 路径参数\n\n> 路径参数一般配合Rest风格使用，也就是使用`@RestController`\n\n```java\n@GetMapping(\"/path/{id}/{name}\")\npublic Map<String, Object> path(@PathVariable(\"id\") String id,\n                                @PathVariable(\"name\") String name,\n                                @PathVariable Map<String,String> kv){\n    // 两种接收参数的方式，\n    // 一：直接接收，\n    // 二：将所有参数以Map形式存储，要求必须为 Map<String,String>格式\n    HashMap<String, Object> map = new HashMap<>();\n    map.put(\"id\",id);\n    map.put(\"name\",name);\n    map.put(\"kv\",kv);\n    return map;\n}\n```\n\n#### 请求头\n\n```java\n@GetMapping(\"/headers\")\npublic Map<String,Object> header(@RequestHeader(\"User-Agent\") String userAgent,\n                                 @RequestHeader(\"Host\")String host,\n                                 @RequestHeader Map<String,String> kv,\n                                 @RequestHeader MultiValueMap<String,String> multiValueMap,\n                                 @RequestHeader HttpHeaders httpHeaders){\n    // RequestHeader共有四种获取方式\n    // 1. 直接获取单个属性\n    // 2. 通过Map<String,String>获取全部键值对\n    // 3. 使用Spring封装的MultiValueMap获取键值对\n    // 4. 直接获取HttpHeaders对象\n    HashMap<String, Object> map = new HashMap<>();\n    map.put(\"userAgent\",userAgent);\n    map.put(\"host\",host);\n    map.put(\"kv\",kv);\n    \n    map.put(\"MultiValueMap\",multiValueMap);\n    map.put(\"HttpHeaders\",httpHeaders);\n    return map;\n}\n```\n\n#### Cookies\n\n```java\n@GetMapping(\"/cookies\")\npublic Map<String,Object> cookies(@CookieValue(\"a\") String a,\n                                  @CookieValue(\"a\") Integer ai,\n                                  @CookieValue Cookie b){\n    // @CookieValue 获取Cookie的值\n    // 1. 直接获取值，可以是String、Integer等等.\n    // 2. 通过Cookie对象获取，不用指定Cookie名\n        // ## Cookie对象获取，指定名称后会404，原因未知\n        // Cookie对象需要使用javax.servlet.http.Cookie\n    // 获取没有的Cookie会400\n    HashMap<String, Object> map = new HashMap<>();\n    map.put(\"a\",a);\n    map.put(\"ai\",ai);\n    map.put(\"b\",b);\n    return map;\n}\n```\n\n#### 请求体\n\n获取HTTP请求的请求体，获取的是原始代码，字符编码为URL编码\n\n```java\n@PostMapping(\"/requestBody\")\npublic Map<String,Object> requestBody(@RequestBody String body){\n    HashMap<String, Object> map = new HashMap<>();\n    map.put(\"body\",body);\n    return map;\n}\n```\n\n#### 转发参数\n\n```java\n@RequestMapping(\"/forward\")\npublic String  forward(HttpServletRequest request){\n    request.setAttribute(\"msg\",\"成功！\");\n    return \"forward:/success\";\n}\n\n@RequestMapping(\"/success\")\n@ResponseBody\npublic Map<String,Object> success(@RequestAttribute String msg,\n                                  HttpServletRequest request){\n    HashMap<String, Object> map = new HashMap<>();\n    map.put(\"RequestAttribute\",msg);\n    map.put(\"HttpServletRequest\",request.getAttribute(\"msg\"));\n    return map;\n}\n```\n\n#### 矩阵变量\n\n> 矩阵变量\n>\n> 当浏览器能够正常使用Cookie时，服务器使用`Session`技术生成一个`jsessionid`，因为每个用户的Session在服务器中是独立的，这样就可以区分他们的身份，所以`jsessionid`能够进行身份鉴别,服务器会将他存入`cookie`中，每次请求都会携带，以此来鉴别用户身份\n>\n> 当浏览器禁用Cookie时，服务器会将`jsessionid`放在URL中，这种技术被称为URL重写\n>\n> 但是这种技术存在一个问题，因为放入URL中是以`QueryString`的形式存在的，很容易与正常的请求参数混淆，矩阵变量可以改善这一问题\n>\n> \n>\n> 矩阵变量：`/matrix/test;name=张三`\n>\n> 矩阵变量是以`;`作为分隔符的，可以与`QueryString`区分\n>\n> 而且矩阵参数是和请求路径一体的，也就是说`test;name=张三`是被视为一个参数的\n>\n> - ==注意：矩阵参数必须和路径参数同时使用，否则无效==\n>\n> - 开启矩阵变量，需要在配置类中自定义SpringMVC\n>\n> - ```java\n>   @Bean\n>   public WebMvcConfigurer webMvcConfigurer(){\n>       return new WebMvcConfigurer() {\n>           @Override\n>           public void configurePathMatch(PathMatchConfigurer configurer) {\n>               UrlPathHelper urlPathHelper = new UrlPathHelper();\n>               // 关闭移除;后的内容，也就是开启矩阵变量\n>               urlPathHelper.setRemoveSemicolonContent(false);\n>               configurer.setUrlPathHelper(urlPathHelper);\n>           }\n>       };\n>   }\n>   ```\n\n\n\n\n\n```java\n// 请求路径：\n// /matrix/test;name=张三;hobby=抽烟,喝酒,烫头\n// /matrix/test;name=张三;hobby=抽烟;hobby=喝酒;hobby=烫头\n// 以上两种路径等效\n@GetMapping(\"/matrix/{path}\")\npublic Map<String,Object> matrix(@PathVariable String path,\n                                 @MatrixVariable(\"name\") String name,\n                                 @MatrixVariable(\"hobby\")List<String> hobby){\n    HashMap<String, Object> map = new HashMap<>();\n    map.put(\"path\",path);\n    map.put(\"name\",name);\n    map.put(\"hobby\",hobby);\n    return map;\n}\n```\n\n```java\n// 这种方式可以处理多个参数同名的问题\n// 请求路径：/matrixm/t1;name=张三/t2;name=李四\n@GetMapping(\"/matrixm/{path1}/{path2}\")\npublic Map<String,Object> matrixm(@PathVariable(\"path1\") String path1,\n                                  @PathVariable(\"path2\") String path2,\n                                  @MatrixVariable(value = \"name\",pathVar = \"path1\") String name1,\n                                  @MatrixVariable(value = \"name\",pathVar = \"path2\") String name2\n                                 ){\n    HashMap<String, Object> map = new HashMap<>();\n    map.put(\"path1\",path1);\n    map.put(\"path2\",path2);\n    map.put(\"name1\",name1);\n    map.put(\"name2\",name2);\n\n    return map;\n}\n```\n\n#### Servlet API 参数\n\n```java\n@GetMapping(\"/sapi\")\npublic String servletApi(Map<String,Object> map,\n                         Model model,\n                         HttpServletRequest request,\n                         HttpServletResponse response){\n    // Servlet API 参数中：\n    // Map、Model、HttpServletRequest都是操作的request域中给的数据\n    // HttpServletResponse\n    map.put(\"map\",\"map\");\n    model.addAttribute(\"model\",\"model\");\n    request.setAttribute(\"req\",\"req\");\n    Cookie cookie = new Cookie(\"res\", \"res\");\n    response.addCookie(cookie);\n    return \"forward:servletApiSuccess\";\n}\n```\n\n```java\n@GetMapping(\"/servletApiSuccess\")\n@ResponseBody\npublic Map<String,Object> servletApiSuccess(HttpServletRequest request){\n    HashMap<String, Object> map = new HashMap<>();\n    map.put(\"map\",request.getAttribute(\"map\"));\n    map.put(\"model\",request.getAttribute(\"model\"));\n    map.put(\"req\",request.getAttribute(\"req\"));\n    return map;\n}\n```\n\n#### 对象参数\n\n\n\n#### 请求参数原理\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t// .........\n            // 获取请求适配器处理器.\n            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\t// .........\n    \t\t// 执行请求适配器处理器\n    \t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n}\n```\n\n##### getHandlerAdapter\n\n```java\nprotected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {\n    if (this.handlerAdapters != null) {\n        for (HandlerAdapter adapter : this.handlerAdapters) {\n            if (adapter.supports(handler)) {\n                return adapter;\n            }\n        }\n    }\n    throw new ServletException(\"No adapter for handler [\" + handler +\n                               \"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\");\n}\n```\n\n查看属性`handlerAdapters`，可以得到内置的`HandlerAdapter`有以下4个\n\n![image-20210824084404752](Spring%20Boot.assets/image-20210824084404752.png)\n\n进入`adapter.supports(handler)`\n\n```java\n@Override\npublic final boolean supports(Object handler) {\n   return (handler instanceof HandlerMethod && supportsInternal((HandlerMethod) handler));\n}\n```\n\n```java\n@Override\nprotected boolean supportsInternal(HandlerMethod handlerMethod) {\n   return true;\n}\n```\n\n也就是说`supports`方法判断传入的是不是`HandlerMethod`类型的参数，如果是则返回`true`，然后`getHandlerAdapter`返回当前的`HandlerAdapter`\n\n##### handle\n\n```java\n@Override\n@Nullable\npublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n      throws Exception {\n\n   return handleInternal(request, response, (HandlerMethod) handler);\n}\n```\n\n```java\n@Override\nprotected ModelAndView handleInternal(HttpServletRequest request,\n      HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\t// ............\n    \t// 执行目标方法\n    \tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t// ............\n}\n```\n\n```java\n@Nullable\nprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n                                           HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n// ...........\n    // 获取要处理的方法\n    ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n    // 设置参数解析器\n    if (this.argumentResolvers != null) {\n        invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n    }\n    // 设置返回值处理器\n    if (this.returnValueHandlers != null) {\n     invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n    }\n// ...........\n\t// 执行并处理方法\n    invocableMethod.invokeAndHandle(webRequest, mavContainer);\n    if (asyncManager.isConcurrentHandlingStarted()) {\n        return null;\n    }\n\n// ............\n}\n```\n\n支持的参数解析器\n\n![image-20210824092842456](Spring%20Boot.assets/image-20210824092842456.png)\n\n参数解析器实现的接口\n\n![image-20210824093149356](Spring%20Boot.assets/image-20210824093149356.png)\n\n返回值处理器\n\n![image-20210824093341820](Spring%20Boot.assets/image-20210824093341820.png)\n\n返回值处理器实现的接口\n\n![image-20210824093503917](Spring%20Boot.assets/image-20210824093503917.png)\n\n执行并处理方法过程\n\n```java\npublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,Object... providedArgs) throws Exception {\n\t// 执行方法，获得返回值\n    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n    setResponseStatus(webRequest);\n\t// ......\n}\n```\n\n实际执行方法的函数\n\n```java\n@Nullable\npublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,Object... providedArgs) throws Exception {\n\t// 获取目标方法所有参数值\n    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\n    /.....\n    // 利用反射执行方法\n    return doInvoke(args);\n}\n```\n\n\n\n```java\nprotected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,Object... providedArgs) throws Exception {\n\t// 获取方法上参数的详细信息\n    MethodParameter[] parameters = getMethodParameters();\n    // 判断参数是否为空\n    if (ObjectUtils.isEmpty(parameters)) {\n        return EMPTY_ARGS;\n    }\n\t// 按照参数个数创建空的对象数组\n    Object[] args = new Object[parameters.length];\n    // 遍历数组\n    for (int i = 0; i < parameters.length; i++) {\n        // 获取当前位置参数\n        MethodParameter parameter = parameters[i];\n        // .......\n        // 查找支持的解析器\n        if (!this.resolvers.supportsParameter(parameter)) {\n            throw new IllegalStateException(formatArgumentError(parameter, \"No suitable resolver\"));\n        }\n        // .........\n            // 拆分参数\n            args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\n\t// .........\n    return args;\n}\n```\n\n\n\n![image-20210824095615379](Spring%20Boot.assets/image-20210824095615379.png)\n\n获取参数解析器的过程\n\n```java\n@Nullable\nprivate HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {\n    // 获取缓存中是否有该解析器\n    HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);\n    if (result == null) {\n        // 循环所有解析器\n        for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) {\n            // 判断当前解析器是否支持处理该类型的参数\n            if (resolver.supportsParameter(parameter)) {\n                // 支持则将当前解析器作为结果返回\n                result = resolver;\n                // 将当前解析器放入缓存中，方便下次使用\n                this.argumentResolverCache.put(parameter, result);\n                break;\n            }\n        }\n    }\n    return result;\n}\n```\n\n最后得到的结果：\n\n![image-20210824102059635](Spring%20Boot.assets/image-20210824102059635.png)\n\n# 配置类\n\n## 自动配置\n\n- 注解\n\n```java\n@ConfigurationProperties(prefix = \"person\")\n```\n\n- yaml\n\n```yaml\nperson:\n  name: 张三\n  age: 18\n  sex: man\n```\n\n## 指定配置文件\n\n- java\n\n```java\n@PropertySource(\"classpath:a.properties\")\npublic class Person {\n    @Value(\"${name}\")\n    String name;\n    int age;\n    String sex;\n}\n```\n\n- properties\n\n```properties\nname=xxx\n```\n\n## 静态资源处理\n\n```yaml\nspring:\n  web:\n    resources:\n      static-locations:\n        classpath: /static/**\n```\n\n\n\n# jsr303校验\n\nhttps://www.jianshu.com/p/554533f88370\n\n\n\n- 开启数据校验注解\n  - `@Validated`\n\n| 注解                          | 含义                                                     |\n| ----------------------------- | -------------------------------------------------------- |\n| `@Null`                       | 被注释的元素必须为 `null`                                |\n| `@NotNull`                    | 被注释的元素必须不为 `null`                              |\n| `@AssertTrue`                 | 被注释的元素必须为 `true`                                |\n| `@AssertFalse`                | 被注释的元素必须为 `false`                               |\n| `@Min(value)`                 | 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 |\n| `@Max(value)`                 | 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 |\n| `@DecimalMin(value)`          | 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 |\n| `@DecimalMax(value)`          | 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 |\n| `@Size(max, min)`             | 被注释的元素的大小必须在指定的范围内                     |\n| `@Digits (integer, fraction)` | 被注释的元素必须是一个数字，其值必须在可接受的范围内     |\n| `@Past`                       | 被注释的元素必须是一个过去的日期                         |\n| `@Future`                     | 被注释的元素必须是一个将来的日期                         |\n| `@Pattern(value)`             | 被注释的元素必须符合指定的正则表达式                     |\n| `@Email`                      | 被注释的元素必须是电子邮箱地址                           |\n| `@Length`                     | 被注释的字符串的大小必须在指定的范围内                   |\n| `@NotEmpty`                   | 被注释的字符串的必须非空                                 |\n| `@Range`                      | 被注释的元素必须在合适的范围内                           |\n\n# 多套配置环境\n\n```yaml\n#默认设置\nserver:\n  port: 8080\n\n#选中要使用的配置信息\nspring:\n  profiles:\n    active: dev\n\n---\n#设置端口\nserver:\n  port: 8081\n#命名为dev环境\nspring:\n  profiles: dev\n---\nserver:\n  port: 8082\n#命名为test环境\nspring:\n  profiles: test\n```\n\n# SpringBoot Web\n\n## 静态资源\n\n### 1、webjars\n\nhttps://www.webjars.org/\n\n\n\n- 访问方式\n  - localhost:8080/webjars/xxx\n\n### 2、目录\n\n1. resourse\n2. static\n3. public\n4. /**\n\n\n\n- 访问方式\n  - localhost:8080/xxx\n\n## Thymeleaf\n\n### 导入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n```\n\n### 导入命名空间\n\n```html\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n```\n\n### 使用\n\n```html\n<h1 th:text=\"${msg}\"></h1>\n```\n\n\n\n### 语法\n\n- \n\n| 标记 | 作用      | 示例   |\n| ---- | --------- | ------ |\n| ${}  | 取值      | ${msg} |\n| @{}  | 资源，url |        |\n| #{}  | 国际化    |        |\n\n\n\n- 标记\n\n| 语法       | 意义                     | 示例                                                 |\n| ---------- | ------------------------ | ---------------------------------------------------- |\n| `th:text`  | 插入文本，不转义html     | `<h1 th:text=\"${msg}\"></h1>`                         |\n| `th:utext` | 插入文本，并且转义为html | `<h1 th:utext=\"${msg}\"></h1>`                        |\n| `th:each`  | 遍历变量，取出值         | `<h3 th:each=\"user:${list}\" th:text=\"${user}\"></h3>` |\n|            |                          |                                                      |\n\n# Spring boot 基础\n\n## Spring boot Stater\n\n- 启动器\n- 实际上就是将一些常用的依赖进行了分组整理，能够一次行导入到Maven或Gradle中\n\n## 启动器\n\n- 只能扫描同级目录或下级目录下的包\n\n\n\n\n\n# 微服务\n\n2014年martin fowler在博客中提出微服务\n\n[英文博文](https://www.martinfowler.com/articles/microservices.html)\n\n[中文博文](http://blog.cuicc.com/blog/2015/07/22/microservices/)\n\n# 常用功能\n\n## Lombok\n\n1. 引入，SpringBoot中内置了Lombok，不需要写版本号\n\n```xml\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n</dependency>\n```\n\n2. 在IDEA的插件市场中搜索Lombok插件并安装\n\n| 注解   | 作用 | 说明                                      |\n| ------ | ---- | ----------------------------------------- |\n| @Slf4j | 日志 | 使用后类内会多一个`log`对象，用于日志输出 |\n|        |      |                                           |\n|        |      |                                           |\n\n## 项目热更新\n\n### 官方\n\n1. 导入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <optional>true</optional>\n</dependency>\n```\n\n2. 修改项目\n3. 热更新\n   - ![image-20210822104553677](Spring%20Boot.assets/image-20210822104553677.png)\n   - 默认快捷键`Ctrl+F9`\n\n- 官方的热更新其实就是自动启动，并没有实现热更新的效果\n\n\n\n### Jrebel\n\n真正的热更新，但是是收费的\n\nhttps://blog.csdn.net/lianghecai52171314/article/details/105637251",
    type: "Java",
    tag: [
        "SpringBoot"
    ],
    hit: NumberLong("1"),
    createDate: ISODate("2022-05-11T10:32:19.928Z"),
    modifyDate: ISODate("2022-05-11T10:32:19.928Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627b90da1947aa32e2a4beba"),
    title: "Spring Boot HTTPS",
    content: "<h1 class=\"markdown-h1\">keytool生成本地HTTPS</h1>\n<p>此种方式生成的证书不受信任</p>\n<ul class=\"markdown-list\">\n<li>生成秘钥文件</li>\n</ul>\n<pre><code>keytool -importkeystore -srckeystore key.p12 -destkeystore key.p12 -deststoretype pkcs12\n</code></pre>\n<ul class=\"markdown-list\">\n<li>生成证书</li>\n</ul>\n<pre><code>keytool -export -alias tomcat -keystore key.p12 -file key.cer\n</code></pre>\n<ul class=\"markdown-list\">\n<li>放入<code class=\"markdown-linecode\">resource</code>文件夹中</li>\n<li>更改配置文件</li>\n</ul>\n<pre><code class=\"language-yaml\">server:\n  port: 8443\n  ssl:\n    key-store: classpath:key.p12\n    key-store-password: 123456\n    key-store-type: PKCS12\n</code></pre>\n<h1 class=\"markdown-h1\">mkcert 生成本地HTTPS</h1>\n<ul class=\"markdown-list\">\n<li>\n<p>此方式生成的证书本地受信</p>\n</li>\n<li>\n<p>mkcert下载地址：https://github.com/FiloSottile/mkcert/releases/latest</p>\n</li>\n<li>\n<p>openssl下载地址：http://slproweb.com/products/Win32OpenSSL.html</p>\n</li>\n</ul>\n<ol class=\"markdown-list\">\n<li>\n<pre><code class=\"language-sh\"># 安装证书\nmkcert -install \n</code></pre>\n</li>\n<li>\n<pre><code class=\"language-sh\"># 添加域名，可以添加多个,添加后生成pem格式证书\nmkcert localhost \n</code></pre>\n</li>\n<li>\n<pre><code class=\"language-sh\"># pem格式证书转为p12格式，此处需要输入密码\nopenssl pkcs12 -export -out key.p12 -in .\\localhost.pem -inkey .\\localhost-key.pem \n</code></pre>\n</li>\n</ol>\n<pre><code class=\"language-yaml\">server:\n  port: 8443\n  ssl:\n    key-store: key.p12  # 此处尝试多次，放入根目录下才能使用\n    key-store-password: 123456\n    key-store-type: PKCS12\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>参考资料</p>\n<ul class=\"markdown-list\">\n<li>https://springboot.io/t/topic/1408</li>\n</ul>\n</blockquote>\n<h1 class=\"markdown-h1\">HTTP 与 HTTPS 共存</h1>\n<pre><code class=\"language-java\">@Value(&quot;${server.http.port}&quot;)\nprivate int httpPort;\n\n@Bean\npublic ServletWebServerFactory servletContainer(){\n    TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory();\n    tomcat.addAdditionalTomcatConnectors(createStandardConnector()); // 添加http\n    return tomcat;\n}\n\nprivate Connector createStandardConnector() {\n    Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);\n    connector.setPort(httpPort);\n    return connector;\n}\n</code></pre>\n<pre><code class=\"language-yaml\">server:\n  port: 8443\n  ssl:\n    key-store: classpath:store.pfx\n    key-store-password: 4CFjt3X5\n    key-store-type: PKCS12\n\t#key-alias: tomcat\n  http:\n    port: 8080\n</code></pre>\n<h1 class=\"markdown-h1\">配置HTTPS后提示端口被占用问题</h1>\n<p>这个问题很玄学，每次解决的方法都不一样</p>\n<h2 class=\"markdown-h2\">解决方式一</h2>\n<p>配置文件问题，将配置文件中的<code class=\"markdown-linecode\">key-alias</code>注释即可解决</p>\n<pre><code class=\"language-yaml\">server:\n  port: 8443\n  ssl:\n    key-store: classpath:store.pfx\n    key-store-password: 4CFjt3X5\n    key-store-type: PKCS12\n\t#key-alias: tomcat  # 注释此行\n  http:\n    port: 8080\n</code></pre>\n<h2 class=\"markdown-h2\">解决方式二</h2>\n<ol class=\"markdown-list\">\n<li>\n<p>将证书文件移动到根目录，也就是与pom.xml平级</p>\n</li>\n<li>\n<pre><code class=\"language-yaml\">server:\n  port: 8443\n  ssl:\n    key-store: key.p12  # 此处尝试多次，放入根目录下才能使用\n    key-store-password: 123456\n    key-store-type: PKCS12\n</code></pre>\n</li>\n</ol>\n<h2 class=\"markdown-h2\">解决方式三</h2>\n<pre><code class=\"language-xml\">&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;\n    &lt;version&gt;3.1.0&lt;/version&gt;\n&lt;/plugin&gt;\n</code></pre>\n<pre><code class=\"language-xml\"> &lt;resources&gt;\n     &lt;resource&gt;\n         &lt;directory&gt;src/main/resources&lt;/directory&gt;\n         &lt;filtering&gt;true&lt;/filtering&gt;\n         &lt;excludes&gt;\n             &lt;exclude&gt;*.pfx&lt;/exclude&gt;\n         &lt;/excludes&gt;\n     &lt;/resource&gt;\n     &lt;resource&gt;\n         &lt;directory&gt;src/main/resources&lt;/directory&gt;\n         &lt;filtering&gt;false&lt;/filtering&gt;\n         &lt;includes&gt;\n             &lt;include&gt;*.pfx&lt;/include&gt;\n         &lt;/includes&gt;\n     &lt;/resource&gt;\n     &lt;resource&gt;\n         &lt;directory&gt;src/main/resources&lt;/directory&gt;\n         &lt;filtering&gt;true&lt;/filtering&gt;\n         &lt;excludes&gt;\n             &lt;exclude&gt;*.p12&lt;/exclude&gt;\n         &lt;/excludes&gt;\n     &lt;/resource&gt;\n     &lt;resource&gt;\n         &lt;directory&gt;src/main/resources&lt;/directory&gt;\n         &lt;filtering&gt;false&lt;/filtering&gt;\n         &lt;includes&gt;\n             &lt;include&gt;*.p12&lt;/include&gt;\n         &lt;/includes&gt;\n     &lt;/resource&gt;\n&lt;/resources&gt;\n</code></pre>\n",
    markdown: "# keytool生成本地HTTPS\n\n此种方式生成的证书不受信任\n\n- 生成秘钥文件\n\n```\nkeytool -importkeystore -srckeystore key.p12 -destkeystore key.p12 -deststoretype pkcs12\n```\n\n- 生成证书\n\n```\nkeytool -export -alias tomcat -keystore key.p12 -file key.cer\n```\n\n- 放入`resource`文件夹中\n- 更改配置文件\n\n```yaml\nserver:\n  port: 8443\n  ssl:\n    key-store: classpath:key.p12\n    key-store-password: 123456\n    key-store-type: PKCS12\n```\n\n\n\n# mkcert 生成本地HTTPS\n\n- 此方式生成的证书本地受信\n\n- mkcert下载地址：https://github.com/FiloSottile/mkcert/releases/latest\n- openssl下载地址：http://slproweb.com/products/Win32OpenSSL.html\n\n1. ```sh\n   # 安装证书\n   mkcert -install \n   ```\n\n2. ```sh\n   # 添加域名，可以添加多个,添加后生成pem格式证书\n   mkcert localhost \n   ```\n\n3. ```sh\n   # pem格式证书转为p12格式，此处需要输入密码\n   openssl pkcs12 -export -out key.p12 -in .\\localhost.pem -inkey .\\localhost-key.pem \n   ```\n\n```yaml\nserver:\n  port: 8443\n  ssl:\n    key-store: key.p12  # 此处尝试多次，放入根目录下才能使用\n    key-store-password: 123456\n    key-store-type: PKCS12\n```\n\n> 参考资料\n>\n> - https://springboot.io/t/topic/1408\n\n# HTTP 与 HTTPS 共存\n\n```java\n@Value(\"${server.http.port}\")\nprivate int httpPort;\n\n@Bean\npublic ServletWebServerFactory servletContainer(){\n    TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory();\n    tomcat.addAdditionalTomcatConnectors(createStandardConnector()); // 添加http\n    return tomcat;\n}\n\nprivate Connector createStandardConnector() {\n    Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\");\n    connector.setPort(httpPort);\n    return connector;\n}\n```\n\n```yaml\nserver:\n  port: 8443\n  ssl:\n    key-store: classpath:store.pfx\n    key-store-password: 4CFjt3X5\n    key-store-type: PKCS12\n\t#key-alias: tomcat\n  http:\n    port: 8080\n```\n\n# 配置HTTPS后提示端口被占用问题\n\n这个问题很玄学，每次解决的方法都不一样\n\n## 解决方式一\n\n配置文件问题，将配置文件中的`key-alias`注释即可解决\n\n```yaml\nserver:\n  port: 8443\n  ssl:\n    key-store: classpath:store.pfx\n    key-store-password: 4CFjt3X5\n    key-store-type: PKCS12\n\t#key-alias: tomcat  # 注释此行\n  http:\n    port: 8080\n```\n\n## 解决方式二\n\n1. 将证书文件移动到根目录，也就是与pom.xml平级\n\n2. ```yaml\n   server:\n     port: 8443\n     ssl:\n       key-store: key.p12  # 此处尝试多次，放入根目录下才能使用\n       key-store-password: 123456\n       key-store-type: PKCS12\n   ```\n\n## 解决方式三\n\n\n\n```xml\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-resources-plugin</artifactId>\n    <version>3.1.0</version>\n</plugin>\n```\n\n```xml\n <resources>\n     <resource>\n         <directory>src/main/resources</directory>\n         <filtering>true</filtering>\n         <excludes>\n             <exclude>*.pfx</exclude>\n         </excludes>\n     </resource>\n     <resource>\n         <directory>src/main/resources</directory>\n         <filtering>false</filtering>\n         <includes>\n             <include>*.pfx</include>\n         </includes>\n     </resource>\n     <resource>\n         <directory>src/main/resources</directory>\n         <filtering>true</filtering>\n         <excludes>\n             <exclude>*.p12</exclude>\n         </excludes>\n     </resource>\n     <resource>\n         <directory>src/main/resources</directory>\n         <filtering>false</filtering>\n         <includes>\n             <include>*.p12</include>\n         </includes>\n     </resource>\n</resources>\n```\n\n",
    type: "Java",
    tag: [
        "SpringBoot"
    ],
    hit: NumberLong("1"),
    createDate: ISODate("2022-05-11T10:32:58.188Z"),
    modifyDate: ISODate("2022-05-11T10:32:58.188Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627b91071947aa32e2a4bebb"),
    title: "Spring Boot 自定义序列化",
    content: "<pre><code class=\"language-java\">@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {\n        MappingJackson2HttpMessageConverter jackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter();\n        ObjectMapper objectMapper = new ObjectMapper();\n        SimpleModule simpleModule = new SimpleModule();\n\n        // 自定义序列化ObjectId类的方式\n        simpleModule.addSerializer(ObjectId.class,new ObjectIdSerialize());\n        \n        objectMapper.registerModule(simpleModule);\n        jackson2HttpMessageConverter.setObjectMapper(objectMapper);\n        converters.add(jackson2HttpMessageConverter);\n    }\n}\n\n/**\n * 序列化ObjectId的具体方法\n */\nclass ObjectIdSerialize extends JsonSerializer&lt;ObjectId&gt; {\n @Override\n public void serialize(ObjectId objectId, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {\n     if (objectId != null){\n         jsonGenerator.writeString(objectId.toString());\n     }\n }\n}\n</code></pre>\n",
    markdown: "```java\n@Configuration\n@EnableWebMvc\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        MappingJackson2HttpMessageConverter jackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter();\n        ObjectMapper objectMapper = new ObjectMapper();\n        SimpleModule simpleModule = new SimpleModule();\n\n        // 自定义序列化ObjectId类的方式\n        simpleModule.addSerializer(ObjectId.class,new ObjectIdSerialize());\n        \n        objectMapper.registerModule(simpleModule);\n        jackson2HttpMessageConverter.setObjectMapper(objectMapper);\n        converters.add(jackson2HttpMessageConverter);\n    }\n}\n\n/**\n * 序列化ObjectId的具体方法\n */\nclass ObjectIdSerialize extends JsonSerializer<ObjectId> {\n @Override\n public void serialize(ObjectId objectId, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {\n     if (objectId != null){\n         jsonGenerator.writeString(objectId.toString());\n     }\n }\n}\n```\n\n",
    type: "Java",
    tag: [
        "SpringBoot"
    ],
    hit: NumberLong("2"),
    createDate: ISODate("2022-05-11T10:33:43.865Z"),
    modifyDate: ISODate("2022-05-11T10:33:43.865Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627b91ab1947aa32e2a4bebe"),
    title: "MySQL",
    content: "<p>mysql 命令选项</p>\n<pre><code class=\"language-sh\">-h \t\t\t连接地址\n-P \t\t\t端口号\n-u \t\t\t用户名\n-p \t\t\t密码\n\t\t\t\t隐藏输入(不跟参数即可)\n\t\t\t\t显式输入(-p和密码之间不能有空格)\n-V,--version\t版本号\n</code></pre>\n<h1 class=\"markdown-h1\">MySQL</h1>\n<h2 class=\"markdown-h2\">语法规范</h2>\n<ul class=\"markdown-list\">\n<li>\n<p>不区分大小写，建议关键字大写，表名列名大写</p>\n</li>\n<li>\n<p>语句以<code class=\"markdown-linecode\">;</code>或者<code class=\"markdown-linecode\">\\g</code>结尾</p>\n</li>\n<li>\n<p>换行缩进不影响执行结果，建议关键字单独一行</p>\n</li>\n<li>\n<p>注释</p>\n<ul class=\"markdown-list\">\n<li>单行注释\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">#注释文字</code></li>\n<li><code class=\"markdown-linecode\">-- 注释文字</code>，==注意：-- 与 注释文字之间要有空格==</li>\n</ul>\n</li>\n<li>多行注释\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">/* 注释文字 */</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>字符串</p>\n<ul class=\"markdown-list\">\n<li>当前字段名与关键字冲突时可以使用单引号<kbd>'</kbd>、双引号<kbd>&quot;</kbd>、反引号<kbd>`</kbd> 来区分</li>\n<li>当需要输入文本型数字是使用上述符号来改变类型</li>\n<li>当需要输入的文本有空格时</li>\n</ul>\n<pre><code class=\"language-sql\">SELECT USER() `user`;\n</code></pre>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">系统操作</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>查询当前数据库版本</p>\n</blockquote>\n<pre><code class=\"language-sql\">SELECT VERSION();\n\n\n# 输出信息\n+-----------+\n| version() |\n+-----------+\n| 8.0.18    |\n+-----------+\n1 row in set (0.00 sec)\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>查询当前用户</p>\n</blockquote>\n<pre><code class=\"language-sql\">SELECT USER();\n\n+----------------+\n| USER()         |\n+----------------+\n| root@localhost |\n+----------------+\n1 row in set (0.00 sec)\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>退出数据库</p>\n</blockquote>\n<pre><code class=\"language-sql\">exit\n\n# 输出信息\nBye\n</code></pre>\n<h2 class=\"markdown-h2\">数据库操作</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>展示所有数据库</p>\n</blockquote>\n<pre><code class=\"language-sql\">SHOW DATABASE;\n\n# 输出信息\n+--------------------+\n| Database           |\n+--------------------+\n| information_schema | # 原信息库\n| mysql              | # 配置相关库\n| performance_schema | # 性能相关库\n| test               | # 测试用库，默认我空\n+--------------------+\n4 rows in set (0.01 sec)  # 结果数量和执行消耗时间\n</code></pre>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>切换数据库</p>\n</blockquote>\n<pre><code class=\"language-sql\">USE test;\n\n\n# 输出信息\nDatabase changed\n</code></pre>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>查询当前所在数据库名</p>\n</blockquote>\n<pre><code class=\"language-sql\">SELECT DATABASE();\n\n\n# 输出信息\n+------------+\n| database() |\n+------------+\n| test       |\n+------------+\n1 row in set (0.00 sec)\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>创建数据库</p>\n<p><code class=\"markdown-linecode\">CREATE DATABASE</code> [IF NOT EXISTS] 数据库名</p>\n</blockquote>\n<pre><code class=\"language-sql\">CREATE DATABASE a;\n\n# 数据库不存在才创建\nCREATE DATABASE IF NOT EXISTS a;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>修改数据库</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 修改数据库字符集\nALTER DATABASE a CHARACTER SET utf8;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>删除数据库</p>\n</blockquote>\n<pre><code class=\"language-sql\">DROP DATABASE a;\n\n# 数据库存在才删除\nDROP DATABASE IF EXISTS a;\n</code></pre>\n<h2 class=\"markdown-h2\">表操作</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>展示所有表</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 展示当前库所有表\nSHOW TABLES;\n\n# 展示指定库所有表\nSHOW TABLES FROM test;\n\n\n# 输出信息\n+----------------+\n| Tables_in_test |\n+----------------+\n| user           |\n+----------------+\n1 row in set (0.00 sec)\n\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>展示表结构</p>\n</blockquote>\n<pre><code class=\"language-sql\">DESC `user`;\nSHOW COLUMNS FROM `user`;\n\n# 输出信息\n+----------+--------------+------+-----+---------+-------+\n| Field    | Type         | Null | Key | Default | Extra |\n+----------+--------------+------+-----+---------+-------+\n| username | varchar(255) | NO   | PRI | NULL    |       |\n| password | varchar(255) | NO   |     | NULL    |       |\n+----------+--------------+------+-----+---------+-------+\n2 rows in set (0.00 sec)\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>创建表</p>\n</blockquote>\n<pre><code class=\"language-sql\">CREATE TABLE 表名(\n\t字段名 字段类型,\t# 必须参数\n    字段名 字段类型[(字段长度)] [约束]\n);\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>修改表</p>\n<ul class=\"markdown-list\">\n<li>修改列名（也可以实现修改类型）\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">ALTER TABLE 表名 CHANGE COLUMN 旧列名 新列名 数据类型;</code></li>\n</ul>\n</li>\n<li>修改列类型\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">ALTER TABLE 表名 MODIFY COLUMN 列名 类型;</code></li>\n</ul>\n</li>\n<li>增加列\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">ALTER TABLE 表名 ADD COLUMN 列名 类型;</code></li>\n</ul>\n</li>\n<li>删除列\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">ALTER TABLE 表名 DROP COLUMN 列名;</code></li>\n</ul>\n</li>\n<li>修改表名\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">ALTER TABLE 旧表名 RENAME TO 新表明;</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\"># 修改表\n-- 修改列名\nALTER TABLE book CHANGE COLUMN page b_page INT;\n-- 修改列类型\nALTER TABLE book MODIFY COLUMN page VARCHAR(20);\n-- 添加列\nALTER TABLE book ADD COLUMN pubdate DATE;\n-- 删除列\nALTER TABLE book DROP COLUMN pubdate;\n-- 修改表名\nALTER TABLE book_s RENAME TO book;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>删除表</p>\n<p><code class=\"markdown-linecode\">DROP TABLE 表名;</code></p>\n</blockquote>\n<pre><code class=\"language-sql\">-- 删除表\nDROP TABLE book;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>复制表</p>\n<ul class=\"markdown-list\">\n<li>只复制结构\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">CREATE TABLE 新表 LIKE 原表;</code></li>\n</ul>\n</li>\n<li>复制结构和数据（复制部分更改SELECT语句即可）\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">CREATE TABLE 新表 SELECT * FROM 原表;</code></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\">-- 复制表结构\nCREATE TABLE book_copy LIKE book;\n-- 复制表结构和内容\nCREATE TABLE book_copy\nSELECT * FROM book;\n</code></pre>\n<h2 class=\"markdown-h2\">查询</h2>\n<h3 class=\"markdown-h3\">SELECT</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>SELECT 用法</p>\n</blockquote>\n<ol class=\"markdown-list\">\n<li>\n<p>查询定值</p>\n<pre><code class=\"language-sql\">SELECT 1;\n\n+---+\n| 1 |\n+---+\n| 1 |\n+---+\n1 row in set (0.10 sec)\n</code></pre>\n</li>\n<li>\n<p>查询表达式</p>\n<pre><code class=\"language-sql\">SELECT 1+1;\n\n+-----+\n| 1+1 |\n+-----+\n|   2 |\n+-----+\n1 row in set (0.00 sec)\n</code></pre>\n</li>\n<li>\n<p>查询函数</p>\n<pre><code class=\"language-sql\">SELECT DATABASE();\n</code></pre>\n</li>\n<li>\n<p>查询表中数据</p>\n<pre><code class=\"language-sql\">SELECT * FROM 表名;\nSELECT 字段1[,字段2....] FROM 表1[,表2....] [WHERE 条件]\n</code></pre>\n</li>\n</ol>\n<h3 class=\"markdown-h3\">条件查询</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>普通条件查询</p>\n<p>使用：<a href=\"#关系运算符\">关系运算符</a>，进行自定义查询</p>\n<ul class=\"markdown-list\">\n<li>注意：</li>\n<li><code class=\"markdown-linecode\">WHERE</code>关键字，不能使用别名进行条件筛选</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询工资大于20000的员工信息\nSELECT * FROM employees WHERE salary &gt; 20000;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>in</p>\n<p>查询满足其中一个条件的记录，与<code class=\"markdown-linecode\">or</code>关键字类似</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询部门号为30/60/90的员工信息\nSELECT * FROM employees WHERE department_id IN(30,60,90)\n\n# 上面的语句完全等价于下面的语句，性能相同，这是语法表现不同\nSELECT * \nFROM employees \nWHERE department_id = 30\nOR department_id = 60\nOR department_id = 90;\n\n\n# 查询部门号不为30/60/90的员工信息\nSELECT * FROM employees WHERE department_id NOT IN(30,60,90)\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>between ... and ...</p>\n<p>区间查询</p>\n<p>需要注意：第一个参数要比第二个参数小</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询部门号在30-90之间的员工信息\nSELECT * FROM employees WHERE department_id BETWEEN 30 AND 90;\n\n# 上面的语句完全等价于下面的语句，性能相同，这是语法表现不同\nSELECT * \nFROM employees\nWHERE department_id &gt;= 30\nAND department_id &lt;= 90;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>空值查询</p>\n<p><code class=\"markdown-linecode\">IS NULL</code></p>\n<p><code class=\"markdown-linecode\">IS NOT NULL</code></p>\n<ul class=\"markdown-list\">\n<li>注意：</li>\n<li><code class=\"markdown-linecode\">=</code>关键字，只能判断普通类型，无法判断<code class=\"markdown-linecode\">NULL</code>类型</li>\n<li><code class=\"markdown-linecode\">IS</code> 关键字 只能判断<code class=\"markdown-linecode\">NULL</code>类型</li>\n<li><code class=\"markdown-linecode\">&lt;=&gt;</code> 关键字(安全等于)，即能判断<code class=\"markdown-linecode\">NULL</code>类型，也能判断普通类型</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询没有年终奖的员工\nSELECT * FROM employees WHERE commission_pct IS NULL;\nSELECT * FROM employees WHERE commission_pct &lt;=&gt; NULL;\n\n# 查询有年终奖的员工\nSELECT * FROM employees WHERE commission_pct IS NOT NULL;\n</code></pre>\n<h3 class=\"markdown-h3\">模糊查询</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>通配符</p>\n<p><code class=\"markdown-linecode\">_</code>：任意一个字符</p>\n<p><code class=\"markdown-linecode\">%</code>：0个或多个字符</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询last_name中包含a的员工信息\nSELECT * FROM employees WHERE last_name LIKE '%a%';\n# 查询last_name中第三个字符是a的员工信息\nSELECT * FROM employees WHERE last_name LIKE '__a%';\n# 查询last_name中第二个字符是_的员工信息\nSELECT * FROM employees WHERE last_name LIKE '_\\_%';\n# 查询last_name中第二个字符是_的员工信息，自定义转义字符$\nSELECT * FROM employees WHERE last_name LIKE '_$_%' ESCAPE '$';\n</code></pre>\n<h3 class=\"markdown-h3\">排序查询</h3>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">ORDER BY</code></p>\n<ul class=\"markdown-list\">\n<li>\n<p>升序:<code class=\"markdown-linecode\">asc</code>,默认</p>\n</li>\n<li>\n<p>降序:<code class=\"markdown-linecode\">desc</code></p>\n</li>\n<li>\n<p>可以使用别名进行排序</p>\n</li>\n<li>\n<p>可以根据函数值进行排序</p>\n</li>\n<li>\n<p>可以多字段排序</p>\n</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\"># 员工信息按照工资升序排列\nSELECT * FROM employees ORDER BY salary;\nSELECT * FROM employees ORDER BY 7; # salary 在表中是 第7列\n\n# 员工信息按照工资降序排列\nSELECT * FROM employees ORDER BY salary DESC;\n\n# 查询有奖金的员工信息，计算年薪并按年薪进行降序排序\nSELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪\nFROM employees\nWHERE commission_pct IS NOT NULL\nORDER BY 年薪 DESC;\n\n# 查询员工信息，按照员工last_name 的长度进行升序排序\nSELECT * FROM employees ORDER BY LENGTH(last_name);\n\n# 查询员工信息，先按照薪资升序，再按照部门降序\nSELECT * \nFROM employees\nORDER BY salary ASC,department_id DESC;\n</code></pre>\n<h3 class=\"markdown-h3\">分组查询</h3>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">GROUP BY</code></p>\n<p>配合统计函数一块使用</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 统计每个部门的平均薪资\nSELECT department_id &quot;部门&quot;,AVG(salary) &quot;平均薪资&quot;\nFROM employees\nGROUP BY department_id;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>分组条件查询</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询部门成员大于5 的部门\nSELECT department_id &quot;部门号&quot;, COUNT(*) &quot;个数&quot;\nFROM employees\nGROUP BY department_id\nHAVING   COUNT(*) &gt; 5;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>分组条件排序查询</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询所有工种中没有奖金，最高工资&gt;6000的工种信息，按照最高工资升序显示\nSELECT job_id,MAX(salary) 最高工资\nFROM employees\nWHERE commission_pct IS  NULL\nGROUP BY job_id\nHAVING MAX(salary) &gt; 6000\nORDER BY 最高工资;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>多分组查询</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询每个工种在每个部门中的最低工资，按照最低工资升序排序\nSELECT job_id,department_id,MIN(salary) 最低工资\nFROM employees\nGROUP BY job_id,department_id\nORDER BY 最低工资;\n</code></pre>\n<h3 class=\"markdown-h3\">常用功能</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>字符串拼接</p>\n<ul class=\"markdown-list\">\n<li>\n<p>CONCAT的参数中有<code class=\"markdown-linecode\">NULL</code>时返回<code class=\"markdown-linecode\">NULL</code></p>\n</li>\n<li>\n<p>需要注意如果参数有可能为<code class=\"markdown-linecode\">NULL</code>时，使用<code class=\"markdown-linecode\">IFNULL()</code>来过滤</p>\n</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\">SELECT CONCAT(first_name,last_name) `姓名` FROM employees;\n</code></pre>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>去重</p>\n</blockquote>\n<pre><code class=\"language-sql\">SELECT DISTINCT department_id FROM employees\n</code></pre>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>别名</p>\n<p>当前表名过长或者容易混淆时可以使用别名来区分表</p>\n</blockquote>\n<ol class=\"markdown-list\">\n<li>\n<p><code class=\"markdown-linecode\">as</code>关键字</p>\n<pre><code class=\"language-sql\">SELECT USER() as `user`;\n\n\n+----------------+\n| user           |\n+----------------+\n| root@localhost |\n+----------------+\n1 row in set (0.00 sec)\n</code></pre>\n</li>\n<li>\n<p>空格</p>\n<pre><code class=\"language-sql\">SELECT USER() `user`;\n\n\n+----------------+\n| user           |\n+----------------+\n| root@localhost |\n+----------------+\n1 row in set (0.00 sec)\n</code></pre>\n</li>\n</ol>\n<h3 class=\"markdown-h3\">查询执行顺序</h3>\n<ol class=\"markdown-list\">\n<li>FROM</li>\n<li>WHERE</li>\n<li>GROUP BY</li>\n<li>HAVING</li>\n<li>SELECT</li>\n<li>ORDER BY</li>\n</ol>\n<h3 class=\"markdown-h3\">连接查询(多表查询)</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>笛卡尔积</p>\n<p>可以将两个表变成一个表</p>\n<p>A有N行，B有M行，A和B的笛卡尔积就有N*M行</p>\n<p>笛卡尔积是连接查询的基础</p>\n</blockquote>\n<ul class=\"markdown-list\">\n<li>A</li>\n</ul>\n<p><img src=\"MySQL%20-%20%E5%89%AF%E6%9C%AC.assets/image-20211005132636716.png\" alt=\"\" /></p>\n<ul class=\"markdown-list\">\n<li>B</li>\n</ul>\n<p><img src=\"MySQL%20-%20%E5%89%AF%E6%9C%AC.assets/image-20211005132735478.png\" alt=\"\" /></p>\n<ul class=\"markdown-list\">\n<li>A*B</li>\n</ul>\n<p><img src=\"MySQL%20-%20%E5%89%AF%E6%9C%AC.assets/image-20211005132819726.png\" alt=\"\" /></p>\n<blockquote class=\"markdown-blockquote\">\n<p>多表查询类型</p>\n</blockquote>\n<p><strong>按照功能分类</strong></p>\n<ul class=\"markdown-list\">\n<li>内连接\n<ul class=\"markdown-list\">\n<li>等值连接</li>\n<li>非等值连接</li>\n<li>自连接</li>\n</ul>\n</li>\n<li>外连接\n<ul class=\"markdown-list\">\n<li>左外连接</li>\n<li>右外连接</li>\n<li>全外连接</li>\n</ul>\n</li>\n<li>交叉连接(笛卡尔积)</li>\n</ul>\n<p><strong>按照标准分类</strong></p>\n<ul class=\"markdown-list\">\n<li>SQL92标准</li>\n<li>SQL99标准</li>\n</ul>\n<blockquote class=\"markdown-blockquote\">\n<p>外连接</p>\n<p>外连接一般应用于查找一个表中有另一个表没有的数据</p>\n<p>外连接可以实现类似集合计算中的交并补的功能</p>\n</blockquote>\n<h4 class=\"markdown-h4\">SQL92</h4>\n<blockquote class=\"markdown-blockquote\">\n<p>等值连接</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询员工名和对应的部门名\nSELECT last_name,department_name\nFROM employees,departments\nWHERE employees.department_id = departments.department_id;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>非等值连接</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询员工名及其对应的工资标准\nSELECT e.last_name,j.grade\nFROM employees e,jobs_grade j\nWHERE e.salary BETWEEN j.min_salary AND j.max_salary;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>自连接</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询员工姓名工资，及其对应的上级员工姓名\nSELECT e.last_name,e.salary,em.last_name 上级姓名\nFROM employees e,employees em\nWHERE e.manager_id = em.employee_id;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>交叉连接</p>\n</blockquote>\n<pre><code class=\"language-sql\"># A表和B表的笛卡尔积\nSELECT * FROM a,b;\n</code></pre>\n<h4 class=\"markdown-h4\">SQL99</h4>\n<blockquote class=\"markdown-blockquote\">\n<p>等值连接</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询员工名和对应的部门名\nSELECT e.last_name,d.department_name\nFROM employees e\nINNER JOIN departments d\nON e.department_id = d.department_id;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>非等值连接</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询员工名及其对应的工资标准\nSELECT e.last_name,j.grade\nFROM employees e\nINNER JOIN jobs_grade j\nON e.salary BETWEEN j.min_salary AND j.max_salary;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>自连接</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询员工姓名工资，及其对应的上级员工姓名\nSELECT e.last_name,e.salary,em.last_name 上级姓名\nFROM employees e\nINNER JOIN employees em\nON e.manager_id = em.employee_id;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>左外连接</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 找出e表中没有对应部门的员工\nSELECT *\nFROM employees e\nLEFT OUTER JOIN departments d \nON d.department_id = e.department_id\nWHERE d.department_id IS NULL;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>右外连接</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 找出e表中没有对应部门的员工\nSELECT *\nFROM departments d \nRIGHT OUTER JOIN employees e\nON d.department_id = e.department_id\nWHERE d.department_id IS NULL;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>全外连接</p>\n<p>MySQL不支持全外连接</p>\n</blockquote>\n<pre><code class=\"language-sql\">SELECT *\nFROM a\nFULL JOIN b\nON a.id=b.id;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>交叉连接</p>\n</blockquote>\n<pre><code class=\"language-sql\"># A表和B表的笛卡尔积\nSELECT *\nFROM a\nCROSS JOIN b;\n</code></pre>\n<h3 class=\"markdown-h3\">子查询</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>分类</p>\n</blockquote>\n<ul class=\"markdown-list\">\n<li>标量子查询\n<ul class=\"markdown-list\">\n<li>一行一列</li>\n</ul>\n</li>\n<li>行子查询\n<ul class=\"markdown-list\">\n<li>一行多列</li>\n</ul>\n</li>\n<li>列子查询\n<ul class=\"markdown-list\">\n<li>一列多行</li>\n</ul>\n</li>\n<li>表子查询\n<ul class=\"markdown-list\">\n<li>多行多列</li>\n</ul>\n</li>\n</ul>\n<blockquote class=\"markdown-blockquote\">\n<p>各个关键字支持的子查询类型</p>\n</blockquote>\n<ul class=\"markdown-list\">\n<li>SELECT后\n<ul class=\"markdown-list\">\n<li>标量子查询</li>\n</ul>\n</li>\n<li>FROM后\n<ul class=\"markdown-list\">\n<li>表子查询</li>\n</ul>\n</li>\n<li>WHERE或HAVING后\n<ul class=\"markdown-list\">\n<li>标量子查询</li>\n<li>列子查询</li>\n<li>行子查询</li>\n</ul>\n</li>\n<li>EXISTS后\n<ul class=\"markdown-list\">\n<li>表子查询</li>\n</ul>\n</li>\n</ul>\n<blockquote class=\"markdown-blockquote\">\n<p>SELECT</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询每个部门的员工个数，追加到部门表的显示信息后面\nSELECT d.*,(\n\tSELECT COUNT(*)\n\tFROM employees e\n\tWHERE e.department_id = d.department_id\n) 员工个数\nFROM departments d;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>FROM</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 根据员工表计算每个部门的平均工资，并按照工资等级表划分等级\nSELECT edg.*,g.grade\nFROM (\n\tSELECT department_id 部门号,AVG(salary) 平均工资\n\tFROM employees\n\tGROUP BY department_id\n) edg\nINNER JOIN jobs_grade g\nON edg.平均工资 BETWEEN g.min_salary AND g.max_salary; \n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>WHERE&amp;HAVING</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 标量子查询\n# 找出工种和141号员工相同，工资比143号员工高的员工信息\nselect last_name,job_id,salary\nFROM employees\nWHERE job_id = (\n\tSELECT job_id\n\tFROM employees\n\tWHERE employee_id = 141\n)\nAND salary &gt; (\n\tSELECT salary\n\tFROM employees\n\tWHERE employee_id = 143\n);\n# 列子查询\n# 查询部门在1400和1700地区的员工信息\nSELECT last_name\nFROM employees\nWHERE department_id IN(\n\tSELECT DISTINCT department_id\n\tFROM departments\n\tWHERE location_id IN(1400,1700)\n);\n\n# 行子查询\n# 查询工号最小，工资最高的员工信息\nSELECT * \nFROM employees\nWHERE (employee_id,salary) = (\n\tSELECT MIN(employee_id),MAX(salary)\n\tFROM employees\n);\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>EXISTS</p>\n<p>查询顺序是先查主查询，然后在执行EXISTS的查询</p>\n<p>判断是否存在，存在返回1，不存在返回0</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查询有员工的部门名\nSELECT d.department_name\nFROM departments d\nWHERE EXISTS(\n\tSELECT *\n\tFROM employees e\n\tWHERE e.department_id = d.department_id\n)\n</code></pre>\n<h3 class=\"markdown-h3\">联合查询</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>UNION</p>\n<ul class=\"markdown-list\">\n<li>将一条很长的SQL语句分割成多条较短的SQL</li>\n<li>如果两个表的部分或全部内容含义相同，但是不在同一表中可以使用UNION将两个查询的结果拼接到一起\n<ul class=\"markdown-list\">\n<li>字段类型必须相同</li>\n<li>字段个数必须相同</li>\n<li>位置必须一一对应</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\"># 原查询语句\nSELECT * FROM employees WHERE email LIKE '%a%' or department_id &gt; 90;\n\n# 使用UNION分割\nSELECT * FROM employees WHERE email LIKE '%a%'\nUNION\nSELECT * FROM employees WHERE department_id &gt; 90;\n\n# 使用UNION拼接表\nSELECT * FROM a\nUNION\nSELECT * FROM b;\n</code></pre>\n<h2 class=\"markdown-h2\">插入</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>方式一</p>\n<ul class=\"markdown-list\">\n<li>支持多行插入</li>\n<li>支持子查询</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\">INSERT INTO b(b2) VALUES(&quot;bb&quot;);\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>方式二</p>\n<ul class=\"markdown-list\">\n<li>仅支持单行插入</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\">INSERT INTO b SET a2=&quot;aa&quot;,b2=&quot;bb&quot;\n</code></pre>\n<h2 class=\"markdown-h2\">更新</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>UPADTE</p>\n<ul class=\"markdown-list\">\n<li>支持级联更新\n<ul class=\"markdown-list\">\n<li>92和99两种语法格式</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\"># 单表更新\nUPDATE a SET a1=&quot;11&quot; WHERE b1=&quot;bb&quot;;\n\n# 级联更新\nUPDATE a\nINNER JOIN b on a.bid = b.id\nset a.a1 = &quot;123&quot;\nWHERE b.a2 = &quot;123&quot;\n</code></pre>\n<h2 class=\"markdown-h2\">删除</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>删除记录</p>\n<ul class=\"markdown-list\">\n<li>支持级联删除\n<ul class=\"markdown-list\">\n<li>92和99两种语法</li>\n</ul>\n</li>\n<li>清空表，自增不会重置而是会继续自增</li>\n<li><strong>事务中删除后可以回滚</strong></li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\"># 单表删除\nDELETE FROM a WHERE a1=&quot;11&quot;;\n\n# 级联删除\nDELETE FROM a,b WHERE a.a1=&quot;11&quot; AND a.id=b.id;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>清空表</p>\n<ul class=\"markdown-list\">\n<li>不能添加WHERE条件</li>\n<li>清空后会重置自增计数器</li>\n<li><strong>事务中删除后无法回滚</strong></li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\">TRUNCATE a;\n</code></pre>\n<h2 class=\"markdown-h2\">约束</h2>\n<h3 class=\"markdown-h3\">六大约束</h3>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">NOT NULL</code></p>\n<p>非空约束，保证字段不为空</p>\n<p>示例：姓名</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">DEFAULT</code></p>\n<p>默认约束，当没有传入值是设置一个默认值</p>\n<p>示例：性别</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">PRIMARY KEY</code></p>\n<p>主键约束，保证字段非空且具有唯一性</p>\n<p>示例：学号</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">UNIQUE</code></p>\n<p>唯一约束，保证字段唯一性，字段可以为空(==仅支持一个为空，多个不行==)</p>\n<p>示例：座位号</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">CHACK</code></p>\n<p>检查约束</p>\n<p><strong>MySQL 8.15 及其之前版本不支持</strong></p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">FOREIGN KEY</code></p>\n<p>外键约束，该字段值必须在另一张表中存在</p>\n<p>设置在从表中</p>\n<p>用于限制两张表的关系</p>\n<ul class=\"markdown-list\">\n<li>要求两个表的类型相同或者兼容</li>\n<li>要求主表中被引用的列必须是KEY（主键、唯一键）</li>\n</ul>\n</blockquote>\n<hr />\n<h3 class=\"markdown-h3\">约束分类</h3>\n<ul class=\"markdown-list\">\n<li>\n<p>列级约束：直接在列后添加约束</p>\n<ul class=\"markdown-list\">\n<li>六大约束都可以是列级约束</li>\n<li>==<strong>MySQL 8.15 及其之前版本不支持</strong>==</li>\n<li>==外键约束在列级约束位置不报错，但是不生效==</li>\n</ul>\n<pre><code class=\"language-sql\">CREATE TABLE stu(\n\tid INT PRIMARY KEY, # 主键约束\n\t`name` VARCHAR(20) NOT NULL, # 非空约束\n\tgender CHAR(1) CHECK(gender=&quot;男&quot; OR gender=&quot;女&quot;), # 检查约束\n\tseat INT UNIQUE, # 唯一约束\n\tage INT DEFAULT 18, # 默认约束\n\tmajor_id INT  REFERENCES majoy(id) # 外键约束\n);\n</code></pre>\n</li>\n<li>\n<p>表级约束：在表最后添加</p>\n<ul class=\"markdown-list\">\n<li>除了非空和默认，其他都支持</li>\n<li><code class=\"markdown-linecode\">CONSTRAINT 约束名</code>，可选项，不加会自动生成约束名</li>\n</ul>\n<pre><code class=\"language-sql\">CREATE TABLE stu(\n\tid INT, \n\t`name` VARCHAR(20) NOT NULL, # 非空约束\n\tgender CHAR(1) , \n\tseat INT, \n\tage INT DEFAULT 18, # 默认约束\n\tmajor_id INT,\n\tPRIMARY KEY(id),# 主键约束\n\tCHECK(gender=&quot;男&quot; OR gender=&quot;女&quot;),# 检查约束\n\tUNIQUE(seat),# 唯一约束\n\tFOREIGN KEY(major_id) REFERENCES majoy(id) # 外键约束\n);\n</code></pre>\n</li>\n<li>\n<p>通用写法：</p>\n<ul class=\"markdown-list\">\n<li>外键放在表级约束位置，其他放在列级位置</li>\n</ul>\n</li>\n</ul>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>主键约束和唯一约束对比</p>\n</blockquote>\n<p>|              | 保证唯一性 | 存在个数 | 是否允许为空 | 是否允许组合 |\n| ------------ | ---------- | -------- | ------------ | ------------ |\n| <strong>主键约束</strong> | 是         | 一个     | 否           | 是           |\n| <strong>唯一约束</strong> | 是         | 多个     | 是           | 是           |</p>\n<h3 class=\"markdown-h3\">修改约束</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>修改列级约束</p>\n</blockquote>\n<pre><code class=\"language-sql\">ALTER TABLE 表名 MODIFY COLUMN 表名 类型 列级约束;\nALTER TABLE stu MODIFY COLUMN `name` VARCHAR(20) NULL;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>修改表级约束</p>\n</blockquote>\n<pre><code class=\"language-sql\">ALTER TABLE stu ADD 表级约束;\nALTER TABLE stu ADD UNIQUE(`name`);\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>删除列级约束</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 也就是修改时不加约束即可\nALTER TABLE 表名 MODIFY COLUMN 表名 类型;\nALTER TABLE stu MODIFY COLUMN `name` VARCHAR(20);\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>删除表级约束</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 删除主键约束\nALTER TABLE 表名 DROP PRIMARY KEY;\n\n# 删除其他约束\nSHOW INDEX FROM 表名; -- 查询所有索引\nALTER TABLE 表名 DROP INDEX 索引名; -- 删除指定索引\nALTER TABLE stu DROP INDEX `name`;\n</code></pre>\n<h3 class=\"markdown-h3\">自增长列</h3>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">AUTO_INCREMEN</code></p>\n<p>插入数据时无需指定，会自动增长</p>\n<ul class=\"markdown-list\">\n<li>必须配合KEY使用(主键、唯一键)</li>\n<li>每张表中只能有唯一自增列</li>\n<li>类型必须为数值类型</li>\n</ul>\n<p>默认初始值：1</p>\n<p>默认递增值：1</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>修改<code class=\"markdown-linecode\">AUTO_INCREMEN</code>默认值</p>\n<p>查看：<code class=\"markdown-linecode\">SHOW VARIABLES LIKE '%auto_increment%';</code></p>\n<p>修改递增值：<code class=\"markdown-linecode\">SET auto_increment_increment = 递增值;</code></p>\n<p>MySQL修改初始值无效，但是可以在插入是手动指定</p>\n</blockquote>\n<h2 class=\"markdown-h2\">运算符</h2>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">+</code></p>\n</blockquote>\n<ul class=\"markdown-list\">\n<li>如果两边都是数值则直接进行加法运算</li>\n</ul>\n<pre><code class=\"language-sql\">SELECT 1+1;\n\n+-----+\n| 1+1 |\n+-----+\n|   2 |\n+-----+\n1 row in set (0.00 sec)\n</code></pre>\n<ul class=\"markdown-list\">\n<li>如果两边有字符型，则将字符型转换成整数型进行加法运算</li>\n</ul>\n<pre><code class=\"language-sql\">SELECT 1+'1';\n\n+-------+\n| 1+'1' |\n+-------+\n|     2 |\n+-------+\n1 row in set (0.00 sec)\n</code></pre>\n<ul class=\"markdown-list\">\n<li>如果两边有字符型，且字符型无法强转为整数时，设置为0</li>\n</ul>\n<pre><code class=\"language-sql\">SELECT 1+'一';\n\n+--------+\n| 1+'一' |\n+--------+\n|      1 |\n+--------+\n1 row in set, 1 warning (0.00 sec)\n</code></pre>\n<ul class=\"markdown-list\">\n<li>当其中有<code class=\"markdown-linecode\">NULL</code>类型时，结果永远为<code class=\"markdown-linecode\">NULL</code></li>\n</ul>\n<pre><code class=\"language-sql\">SELECT 1+null;\n\n+--------+\n| 1+null |\n+--------+\n|   NULL |\n+--------+\n1 row in set (0.00 sec)\n\n---------------------------\nSELECT null+null;\n\n+-----------+\n| null+null |\n+-----------+\n|      NULL |\n+-----------+\n1 row in set (0.00 sec)\n</code></pre>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><a name=\"关系运算符\"></a>关系运算符</p>\n</blockquote>\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">&gt;</code> 大于</li>\n<li><code class=\"markdown-linecode\">&lt;</code> 小于</li>\n<li><code class=\"markdown-linecode\">&gt;=</code> 大于等于</li>\n<li><code class=\"markdown-linecode\">&lt;=</code> 小于等于</li>\n<li><code class=\"markdown-linecode\">=</code> 等于</li>\n<li><code class=\"markdown-linecode\">!=</code> 、<code class=\"markdown-linecode\">&lt;&gt;</code> 不等于\n<ul class=\"markdown-list\">\n<li>建议使用<code class=\"markdown-linecode\">&lt;&gt;</code></li>\n</ul>\n</li>\n<li><code class=\"markdown-linecode\">like</code> 模糊查询</li>\n<li><code class=\"markdown-linecode\">between and</code>  区间</li>\n<li><code class=\"markdown-linecode\">in</code> 属于</li>\n</ul>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>逻辑运算符</p>\n</blockquote>\n<ul class=\"markdown-list\">\n<li>\n<p><code class=\"markdown-linecode\">||</code>、<code class=\"markdown-linecode\">or</code> 逻辑或</p>\n</li>\n<li>\n<p><code class=\"markdown-linecode\">&amp;&amp;</code>、<code class=\"markdown-linecode\">and</code> 逻辑与</p>\n</li>\n<li>\n<p><code class=\"markdown-linecode\">!</code>、<code class=\"markdown-linecode\">not</code> 逻辑非</p>\n</li>\n<li>\n<p>推荐使用：<code class=\"markdown-linecode\">or</code>、<code class=\"markdown-linecode\">and</code>、<code class=\"markdown-linecode\">not</code></p>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">常用函数</h2>\n<h3 class=\"markdown-h3\">字符相关</h3>\n<p>| 函数                     | 作用                                                         |\n| ------------------------ | ------------------------------------------------------------ |\n| CONCAT(str1,str2,...)    | 拼接字符串,如果参数中有<code class=\"markdown-linecode\">NULL</code>则结果为<code class=\"markdown-linecode\">NULL</code>                  |\n| LENGTH(str)              | 获取字节长度                                                 |\n| CHAR_LENGTH(str)         | 获取文字个数                                                 |\n| SUBSTR(str,start,len)    | 获取子串，起始下标从1开始，获取指定个数                      |\n| SUBSTR(str,start)        | 获取子串，从start位置到字符串结束                            |\n| SUBSTRING(str,start,len) | SUBSTR的全名函数                                             |\n| INSTR(str1,str2)         | 在str1中查找str2第一次出现的位置                             |\n| TRIM([x FROM ]str)       | 去除str中前后的x，中间x不去除，默认x为空格                   |\n| LPAD(str,len,padstr)     | 左填充，将str使用padstr填充到len指定的长度，如果len小于str的长度则截取str的长度到len |\n| RPAD(str,len,padstr)     | 右填充，将str使用padstr填充到len指定的长度，如果len小于str的长度则截取str的长度到len |\n| UPPER(str)               | 将str转换为大写                                              |\n| LOWER(str)               | 将str转化为小写                                              |\n| STRCMP(str1,str2)        | 比较str1和str2，1：str1大，-1：str2大，0：相等               |\n| LEFT(str,len)            | 将str左侧数len个字符截取出来                                 |\n| RIGHT(str,len)           | 将str右侧数len个字符截取出来                                 |</p>\n<h3 class=\"markdown-h3\">数学函数</h3>\n<p>| 函数          | 作用                                     |\n| ------------- | ---------------------------------------- |\n| ABS(X)        | 取X的绝对值                              |\n| CEIL(X)       | X向上取整                                |\n| FLOOR(X)      | X向下取整                                |\n| ROUND(X[,D])  | X四舍五入,保留小数点后D位(默认为0)       |\n| TRUNCATE(X,D) | 直接将X从小数点后D位截取，不考虑四舍五入 |\n| MOD(N,M)      | N取余M                                   |\n| RAND()        | 生成0-1直接的小数                        |</p>\n<h3 class=\"markdown-h3\">日期函数</h3>\n<p>| 函数                  | 作用                           |\n| --------------------- | ------------------------------ |\n| NOW()                 | 获取当前日期时间               |\n| CURRENT_DATE()        | 获取当前日期                   |\n| CURRENT_TIME()        | 获取当前时间                   |\n| DATEDIFF(date1,date2) | 获取date1-date2得到的天数      |\n| DATE_FORMAT(date,fmt) | 将date转换为fmt格式            |\n| STR_TO_DATE(str,fmt)  | 将str按照fmt格式解析为日期类型 |</p>\n<blockquote class=\"markdown-blockquote\">\n<p>format 格式字符串</p>\n</blockquote>\n<p>| 格式 | 描述                                           |\n| :--- | :--------------------------------------------- |\n| %a   | 缩写星期名                                     |\n| %b   | 缩写月名                                       |\n| %c   | 月，数值                                       |\n| %D   | 带有英文前缀的月中的天                         |\n| %d   | 月的天，数值(00-31)                            |\n| %e   | 月的天，数值(0-31)                             |\n| %f   | 微秒                                           |\n| %H   | 小时 (00-23)                                   |\n| %h   | 小时 (01-12)                                   |\n| %I   | 小时 (01-12)                                   |\n| %i   | 分钟，数值(00-59)                              |\n| %j   | 年的天 (001-366)                               |\n| %k   | 小时 (0-23)                                    |\n| %l   | 小时 (1-12)                                    |\n| %M   | 月名                                           |\n| %m   | 月，数值(00-12)                                |\n| %p   | AM 或 PM                                       |\n| %r   | 时间，12-小时（hh:mm:ss AM 或 PM）             |\n| %S   | 秒(00-59)                                      |\n| %s   | 秒(00-59)                                      |\n| %T   | 时间, 24-小时 (hh:mm:ss)                       |\n| %U   | 周 (00-53) 星期日是一周的第一天                |\n| %u   | 周 (00-53) 星期一是一周的第一天                |\n| %V   | 周 (01-53) 星期日是一周的第一天，与 %X 使用    |\n| %v   | 周 (01-53) 星期一是一周的第一天，与 %x 使用    |\n| %W   | 星期名                                         |\n| %w   | 周的天 （0=星期日, 6=星期六）                  |\n| %X   | 年，其中的星期日是周的第一天，4 位，与 %V 使用 |\n| %x   | 年，其中的星期一是周的第一天，4 位，与 %v 使用 |\n| %Y   | 年，4 位                                       |\n| %y   | 年，2 位                                       |</p>\n<h3 class=\"markdown-h3\">流程控制</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>IFNULL(可能为null的参数,为null显示的值)</p>\n<p>如果参数一为null，则替换为参数二</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p>IF 分支</p>\n</blockquote>\n<pre><code class=\"language-sql\">IF(E,S,F)   E成立输出S，不成立输出F\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>CASE 分支</p>\n<p>类似于 java中的 switch</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 实现switch功能\nCASE 表达式\n\tWHEN 值1 THEN &quot;结果1&quot;\n\tWHEN 值2 THEN &quot;结果2&quot;\n\t...\n\tELSE\n\t\t&quot;没有能满足的值返回结果&quot;\nEND\n\n\n# 实现多重IF功能\nCASE \n\tWHEN 条件 THEN\n\t\t&quot;满足条件返回结果&quot;\n\t...\n\tELSE\n\t\t&quot;没有能满足的条件返回结果&quot;\nEND\n</code></pre>\n<pre><code class=\"language-sql\"># 根据工资划分等级\nSELECT last_name,\nCASE \n\tWHEN salary BETWEEN 5000 and 10000 THEN\n\t\t&quot;C&quot;\n\tWHEN salary BETWEEN 10000 and 20000 THEN\n\t\t&quot;B&quot;\n\tWHEN salary&gt;20000 THEN\n\t\t&quot;A&quot;\n\tELSE\n\t\t&quot;D&quot;\nEND as &quot;等级&quot;\nFROM employees;\n</code></pre>\n<h3 class=\"markdown-h3\">统计函数</h3>\n<p>| 函数        | 作用         |\n| ----------- | ------------ |\n| SUM(字段)   | 求和         |\n| MAX(字段)   | 最大值       |\n| MIN(字段)   | 最小值       |\n| AVG(字段)   | 平均值       |\n| COUNT(字段) | 统计非空个数 |</p>\n<blockquote class=\"markdown-blockquote\">\n<p>count</p>\n<ul class=\"markdown-list\">\n<li>统计行数：<code class=\"markdown-linecode\">COUNT(*)</code> 或者 <code class=\"markdown-linecode\">COUNT(1)</code></li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\"># 统计有人的部门个数\nSELECT COUNT(DISTINCT department_id) 部门个数 FROM employees;\n</code></pre>\n<h2 class=\"markdown-h2\">数据类型</h2>\n<h3 class=\"markdown-h3\">数值类型</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>整型</p>\n<p>在整型数据类型后加<code class=\"markdown-linecode\">UNSIGNED</code>,表示无符号整型</p>\n<ul class=\"markdown-list\">\n<li>超出数据类型范围后会报<code class=\"markdown-linecode\">out of range</code>异常</li>\n<li>超出范围后取范围内最接近的值</li>\n<li>整型的长度\n<ul class=\"markdown-list\">\n<li>整型数据类型都有自己的默认长度</li>\n<li>==表示的不是范围，数值范围已经由数据类型决定了==</li>\n<li>作用是当数值长度不足指定长度时补零（只有当加了<code class=\"markdown-linecode\">ZEROFILL</code>关键字才起效，而且<code class=\"markdown-linecode\">ZEROFILL</code>不支持负数）</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>| 类型         | 大小  | 范围                                                   |\n| ------------ | ----- | ------------------------------------------------------ |\n| TINYINT      | 1字节 | 有符号：-128~127<br />无符号：0~255                    |\n| SMALLINT     | 2字节 | 无符号：-32768~32767<br />有符号：0~65535              |\n| MEDIUMINT    | 3字节 | 无符号：-8388608~8388607<br />有符号：0~1677215        |\n| INT、INTEGER | 4字节 | 无符号：-214783648~214783647<br />有符号：0~4294967295 |\n| BIGINT       | 8字节 |                                                        |</p>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>浮点型</p>\n<p>更节省空间</p>\n<p>M：总位数</p>\n<p>D：小数点后位数</p>\n<p>当M和D没有指定时，会根据插入的数值决定</p>\n</blockquote>\n<p>| 类型        | 大小  |\n| ----------- | ----- |\n| FLOAT(M,D)  | 4字节 |\n| DOUBLE(M,D) | 8字节 |</p>\n<blockquote class=\"markdown-blockquote\">\n<p>定点型</p>\n<p>精确度较高</p>\n<p>M：总位数，默认为10</p>\n<p>D：小数点后位数，默认为0</p>\n</blockquote>\n<p>| 类型         | 大小 |\n| ------------ | ---- |\n| DEC(M,D)     |      |\n| DECIMAL(M,D) |      |</p>\n<h3 class=\"markdown-h3\">字符串</h3>\n<blockquote class=\"markdown-blockquote\">\n<ul class=\"markdown-list\">\n<li>CHAR：固定长度字符，不论存入的是几个字符都按照固定长度存储\n<ul class=\"markdown-list\">\n<li>可以不指定长度，默认为1</li>\n<li>如果M设置为10，存入<code class=\"markdown-linecode\">中国</code>，实际占据的存储空间是10个字符的空间</li>\n<li>存储结构简单，查询效率更高、更占据空间</li>\n</ul>\n</li>\n<li>VARCHAR：可变长度字符，根据实际插入的字符分配存储空间\n<ul class=\"markdown-list\">\n<li>必须指定长度</li>\n<li>如果M设置为10，存入<code class=\"markdown-linecode\">中国</code>，实际占据的存储空间是2个字符的空间</li>\n<li>存储结构复杂，查询效率低、更节省空间</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>| 类型       | M范围   |\n| ---------- | ------- |\n| CHAR(M)    | 0~255   |\n| VARCHAR(M) | 0-65535 |\n| TEXT       |         |</p>\n<h3 class=\"markdown-h3\">日期时间</h3>\n<p>| 类型      | 长度  | 作用     | 最小值               | 最大值                     |\n| --------- | ----- | -------- | -------------------- | -------------------------- |\n| DATE      | 4字节 | 日期     | 1000-01-01           | 9999-12-31                 |\n| TIME      | 4字节 | 时间     | -838:59:59           | 838:59:59                  |\n| DATETIME  | 8字节 | 日期时间 | 1000-01-01 00:00:00  | 9999-12-31 23:59:59        |\n| TIMESTAMP | 4字节 | 时间戳   | 1970010108001(UTC+8) | 2038-01-19 11:14:07(UTC+8) |\n| YEAR      | 1字节 | 年份     | 1901                 | 2155                       |</p>\n<h3 class=\"markdown-h3\">二进制</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>二进制</p>\n</blockquote>\n<p>| 类型      | 范围 | 作用                                   |\n| --------- | ---- | -------------------------------------- |\n| BINARY    |      | 保存短二进制数据，根据指定长度分配空间 |\n| VARBINARY |      | 保存短二进制数据，根据实际数据分配空间 |\n| BLOB      |      | 保存长二进制数据                       |</p>\n<h3 class=\"markdown-h3\">特殊类型</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>ENUM</p>\n<p>枚举类型</p>\n<p><code class=\"markdown-linecode\">ENUM(枚举值1,枚举值2...)</code></p>\n<ul class=\"markdown-list\">\n<li>\n<p>最多65535个成员</p>\n<ul class=\"markdown-list\">\n<li>1-255：占1个字节</li>\n<li>256~65535：占2个字节</li>\n</ul>\n</li>\n<li>\n<p>只有符合枚举值要求的数值才能插入成功，否则插入空值</p>\n</li>\n<li>\n<p>只能选择其中一个</p>\n</li>\n<li>\n<p>不区分大小写</p>\n</li>\n</ul>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p>SET</p>\n<p>集合类型</p>\n<p><code class=\"markdown-linecode\">SET(集合值1,集合值2...)</code></p>\n<ul class=\"markdown-list\">\n<li>\n<p>最多64个成员</p>\n</li>\n<li>\n<p>只有符合集合值要求的数值才能插入成功，否则插入空值</p>\n</li>\n<li>\n<p>可以选取多个</p>\n</li>\n<li>\n<p>不区分大小写</p>\n</li>\n</ul>\n</blockquote>\n<h2 class=\"markdown-h2\">事务</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>事务</p>\n<p>一组SQL语句，我们希望他要么都执行，要么都不执行</p>\n<p>事务特点(ACID)</p>\n<ul class=\"markdown-list\">\n<li>原子性(Atomicty)：这组SQL被视为不可分割的最小单元，要么都执行，要么都不执行</li>\n<li>一致性(Consistency)：事务必须是从一个一致性状态转移到另一个一致性状态。例如：转账，总金额1000，转账前后总金额都应该是1000，不能增多减少</li>\n<li>隔离性(Isolation)：单个事务的执行不受其他事务的影响，各个事务之间互不干扰</li>\n<li>持久性(Durability)：事务一旦提交，对数据库的修改是永久性的</li>\n</ul>\n</blockquote>\n<h3 class=\"markdown-h3\">创建事务</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>隐式事务</p>\n<p>在MySQL中，<code class=\"markdown-linecode\">INSERT</code>、<code class=\"markdown-linecode\">UPDATE</code>、<code class=\"markdown-linecode\">DELETE</code>都是隐式开启事务的</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p>显示事务</p>\n</blockquote>\n<pre><code class=\"language-sql\">-- 1.关闭自动提交，开启事务\nSET autocommit = 0;\n-- 1.2 开启事务，可以不写，上面关闭自动提交默认就开启了事务\nSTART TRANSACTION;\n\n-- 2.执行SQL,模拟转账\nUPDATE t SET money = money - 500 WHERE id = 1;\nUPDATE t SET money = money + 500 WHERE id = 2;\n\n-- 3-1 执行成功,提交事务\nCOMMIT;\n\n-- 3-2 执行失败,回滚事务\nROLLBACK;\n</code></pre>\n<h3 class=\"markdown-h3\">事务隔离</h3>\n<h4 class=\"markdown-h4\">事务存在的问题</h4>\n<blockquote class=\"markdown-blockquote\">\n<p>脏读</p>\n<p>A在事务中修改了数据但是还没提交，B读到了这个数据，但是A出现错误回滚了，那么B读到的数据就是错误的数据，这种现象就是脏读</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p>不可重复读</p>\n<p>A读取了数据，然后B更新了这个数据，然后A再次读取该数据时与上次读取的结果不同，这种现象叫做不可重复读</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p>幻读</p>\n<p>A读取某个表中的一个字段，然后B向这个表中添加了新的数据，A再次读取这个表时与上次读取的行数不同，这种现象叫做幻读</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 触发脏读和不可重复读\n\n# 查看当前事务隔离级别，tx_isolation在MySQL 5.7.20后被弃用\nSELECT @@transaction_isolation;\n-- ------------------命令行1中执行----------------------\n# 修改事务隔离级别为最低级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n# 开启事务\nSET autocommit=0;\n# 切换数据库\nUSE test;\n# 更新数据\nUPDATE t SET name='张三1' WHERE id=1;\n# 不提交数据\n\n-- ------------------命令行2中执行----------------------\n# 修改事务隔离级别为最低级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n# 开启事务\nSET autocommit=0;\n# 切换数据库\nUSE test;\n# 查看数据\nSELECT * from t;\n+------+-------+\n| id   | name  |\n+------+-------+\n|    1 | 张三1 |\n|    2 | 李四  |\n+------+-------+\n2 rows in set (0.00 sec)\n# 此时读取的数据已经被修改，触发脏读\n\n-- ------------------命令行1中执行----------------------\n# 回滚数据\nROLLBACK;\n-- ------------------命令行2中执行----------------------\n# 再次查看数据\nSELECT * FROM t;\n+------+------+\n| id   | name |\n+------+------+\n|    1 | 张三 |\n|    2 | 李四 |\n+------+------+\n2 rows in set (0.00 sec)\n# 触发不可重复读\n</code></pre>\n<pre><code class=\"language-sql\"># 触发幻读\n-- ------------------命令行1中执行----------------------\n# 修改事务隔离级别为最低级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n# 开启事务\nSET autocommit=0;\n# 切换数据库\nUSE test;\n# 查询当前数据\nselect * from t;\n+------+------+\n| id   | name |\n+------+------+\n|    1 | 张三 |\n|    2 | 李四 |\n+------+------+\n2 rows in set (0.00 sec)\n\n-- ------------------命令行2中执行----------------------\n# 修改事务隔离级别为最低级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n# 开启事务\nSET autocommit=0;\n# 切换数据库\nUSE test;\n# 添加数据\nINSERT INTO t VALUES(3,'王五');\n# 查看数据\nSELECT * FROM t;\n+------+------+\n| id   | name |\n+------+------+\n|    1 | 张三 |\n|    2 | 李四 |\n|    3 | 王五 |\n+------+------+\n3 rows in set (0.00 sec)\n# 提交\nCOMMIT;\n-- ------------------命令行1中执行----------------------\nUPDATE t SET name=CONCAT(name,&quot;1&quot;);\nQuery OK, 3 rows affected (0.00 sec)\nRows matched: 3  Changed: 3  Warnings: 0\n# 触发幻读，之前命令行1读取的结果为2两行，但是更新却是更新了3行\n</code></pre>\n<h4 class=\"markdown-h4\">事务隔离级别</h4>\n<blockquote class=\"markdown-blockquote\">\n<p>事务级别</p>\n<p><strong><code class=\"markdown-linecode\">tx_isolation</code>在MySQL 5.7.20后被弃用,改用<code class=\"markdown-linecode\">transaction_isolation</code></strong></p>\n<ul class=\"markdown-list\">\n<li>查看：<code class=\"markdown-linecode\">SELECT @@transaction_isolation;</code></li>\n<li>修改：<code class=\"markdown-linecode\">SET SESSION TRANSACTION ISOLATION LEVEL 隔离级别;</code></li>\n</ul>\n</blockquote>\n<p>| 隔离级别                         | 功能                           |                                              |\n| -------------------------------- | ------------------------------ | -------------------------------------------- |\n| READ UNCOMMITTED（读未提交数据） | 脏读、幻读、不可重复读都会触发 |                                              |\n| READ COMMITTED（读已提交数据）   | 可以避免脏读                   | 只允许读其他事务已经提交的数据               |\n| REPEATABLE READ（可重复读）      | 可以避免脏读和不可重复读       | 默认，禁止其他其他事务更新                   |\n| SERIALIZABLE READ（串行化）      | 可以避免所有问题               | 性能极低，禁止其他事务的所有插入、更新、删除 |</p>\n<h2 class=\"markdown-h2\">视图</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>视图使用场景</p>\n<ul class=\"markdown-list\">\n<li>实现某个功能需要多条复杂语句</li>\n<li>该语句需要多次使用</li>\n</ul>\n</blockquote>\n<h3 class=\"markdown-h3\">创建</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>创建视图</p>\n<p><code class=\"markdown-linecode\">CREATE VIEW 视图名 AS 查询;</code></p>\n</blockquote>\n<pre><code class=\"language-sql\">CREATE VIEW tv\nAS\nSELECT e.last_name,d.department_name,j.job_title\nFROM employees e\nINNER JOIN departments d ON d.department_id = e.department_id\nINNER JOIN jobs j ON j.job_id = e.job_id;\n</code></pre>\n<h3 class=\"markdown-h3\">查询</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>查询视图</p>\n<p>查询视图时将视图视为一张表即可,可以进行所有的查询操作</p>\n</blockquote>\n<pre><code class=\"language-sql\">SELECT * FROM tv WHERE last_name = 'Gietz';\n</code></pre>\n<h3 class=\"markdown-h3\">修改</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>修改视图</p>\n<ul class=\"markdown-list\">\n<li>方式一：存在就修改，不存在就创建</li>\n</ul>\n<p><code class=\"markdown-linecode\">CREATE OR REPLACE  VIEW 视图名 AS 查询;</code></p>\n<ul class=\"markdown-list\">\n<li>方式二：直接修改</li>\n</ul>\n<p><code class=\"markdown-linecode\">ALTER VIEW 视图名 AS 查询;</code></p>\n</blockquote>\n<pre><code class=\"language-sql\">-- 方式一\nCREATE OR REPLACE VIEW tv\nAS\nSELECT e.employee_id,e.last_name,d.department_name,j.job_title\nFROM employees e\nINNER JOIN departments d ON d.department_id = e.department_id\nINNER JOIN jobs j ON j.job_id = e.job_id;\n\n-- 方式二\nALTER VIEW tv\nAS\nSELECT e.employee_id,e.last_name,d.department_name,j.job_title\nFROM employees e\nINNER JOIN departments d ON d.department_id = e.department_id\nINNER JOIN jobs j ON j.job_id = e.job_id;\n</code></pre>\n<h3 class=\"markdown-h3\">删除</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>删除视图</p>\n<p><code class=\"markdown-linecode\">DROP VIEW 视图名;</code></p>\n</blockquote>\n<pre><code class=\"language-sql\">DROP VIEW tv;\n</code></pre>\n<h3 class=\"markdown-h3\">更新</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>包含以下特点的视图是不允许更新的：</p>\n<ul class=\"markdown-list\">\n<li>有分组函数</li>\n<li><code class=\"markdown-linecode\">DISTINCT</code></li>\n<li><code class=\"markdown-linecode\">GROUP BY</code></li>\n<li><code class=\"markdown-linecode\">HAVING</code></li>\n<li><code class=\"markdown-linecode\">UNION</code></li>\n<li><code class=\"markdown-linecode\">UNION ALL</code></li>\n<li><code class=\"markdown-linecode\">SELECT</code>中有子查询</li>\n<li><code class=\"markdown-linecode\">JOIN</code></li>\n<li>依赖于不可更新的视图</li>\n<li><code class=\"markdown-linecode\">WHERE</code>中引用了子查询中的表</li>\n<li>常量视图</li>\n</ul>\n</blockquote>\n<h2 class=\"markdown-h2\">变量</h2>\n<h3 class=\"markdown-h3\">系统变量</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>系统变量</p>\n<p>用于控制系统中的各种功能</p>\n<ul class=\"markdown-list\">\n<li>系统会话变量：仅针对当前会话生效</li>\n<li>系统全局变量：针对所有会话生效的默认值</li>\n</ul>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p>查看系统变量</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查看全部系统会话变量\nSHOW VARIABLES; \nSHOW SESSION VARIABLES; \n\n# 查看全部系统全局变量\nSHOW GLOBAL VARIABLES; \n\n# 查看某些系统变量\nSHOW VARIABLES LIKE &quot;%auto%&quot;;\n\n# 查看指定系统会话变量\nSELECT @@autocommit; \n\n# 查看指定系统全局变量\nSELECT @@global.autocommit; \n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>修改系统变量</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 设置系统会话变量\nSET autocommit = 0;\nSET @@autocommit = 1;\n\n# 设置系统全局变量\nSET GLOBAL autocommit = 0;\nSET @@global.autocommit = 1;\n</code></pre>\n<h3 class=\"markdown-h3\">自定义变量</h3>\n<h4 class=\"markdown-h4\">用户变量</h4>\n<blockquote class=\"markdown-blockquote\">\n<p>用户变量</p>\n<p>当前会话连接有效，会话关闭后会被清除</p>\n<p>用户变量前面必须加一个<code class=\"markdown-linecode\">@</code>符号</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p>创建</p>\n<p>为了避免歧义，建议使用<code class=\"markdown-linecode\">:=</code>赋值</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 创建变量并赋值，以下三种方式都可以\nSET @test=1;\nSET @test:=2;\nSELECT @test:=3;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>更新</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 方式一\nSET @test=1;\nSET @test:=2;\nSELECT @test:=3;\n# 方式二\nSELECT 字段 INTO 变量名 FROM 表;\nSELECT COUNT(*) INTO @test FROM employees;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>查看</p>\n</blockquote>\n<pre><code class=\"language-sql\">SELECT 变量名;\nSELECT @test;\n</code></pre>\n<h4 class=\"markdown-h4\">局部变量</h4>\n<blockquote class=\"markdown-blockquote\">\n<p>局部变量</p>\n<p>仅仅在定义他的<code class=\"markdown-linecode\">BEGIN END</code>中有效</p>\n<p>修改与查看方法和用户变量相同</p>\n<p>除了使用<code class=\"markdown-linecode\">SELECT @test:=3;</code>方法赋值需要加<code class=\"markdown-linecode\">@</code>之外，其他都不需要加<code class=\"markdown-linecode\">@</code></p>\n</blockquote>\n<pre><code class=\"language-sql\">CREATE PROCEDURE myp4()\nBEGIN\n\tDECLARE c INT;\n\tSELECT COUNT(*) INTO c FROM employees;\n\tSELECT c;\nEND\n\nCALL myp4;\n</code></pre>\n<h2 class=\"markdown-h2\">存储过程</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>创建</p>\n<ul class=\"markdown-list\">\n<li>结束符：因为SQL语句中每句都要求以<code class=\"markdown-linecode\">;</code>为结尾，但是在命令行定义存储过程时使用<code class=\"markdown-linecode\">;</code>来结束存储过程时会报语法错误，此时就需要使用<code class=\"markdown-linecode\">DELIMITER</code>关键字来改变结束符，通常使用<code class=\"markdown-linecode\">DELIMITER $</code>更改结束符，更改之后所有结束位置都需要加上<code class=\"markdown-linecode\">$</code>才行，在使用图形化界面时一般没有这个限制</li>\n<li>参数\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">IN</code>：输入模式，也就是正常的输入参数</li>\n<li><code class=\"markdown-linecode\">OUT</code>：输出模式，该参数可以作为存储过程的返回值，可以向参数中写入内容</li>\n<li><code class=\"markdown-linecode\">INOUT</code>：输入输出模式，既可以输入也可以输出</li>\n</ul>\n</li>\n<li>特点\n<ul class=\"markdown-list\">\n<li>可以有0到多个返回值</li>\n<li>适用于批量增删改</li>\n<li>使用<code class=\"markdown-linecode\">CALL</code>调用</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\"># 无参\n-- 创建\nCREATE PROCEDURE myp2()\nBEGIN\n\tINSERT INTO a VALUES(&quot;2&quot;,&quot;2&quot;);\nEND\n-- 调用\nCALL myp2;\n\n\n\n# IN参数\n-- 创建\nCREATE PROCEDURE mypin(IN id INT)\nBEGIN\n\tSELECT * FROM employees e WHERE e.employee_id = id;\nEND\n-- 调用\nCALL mypin(200);\n\n# OUT模式\nCREATE PROCEDURE mypout(IN id INT,OUT c INT)\nBEGIN\n\tSELECT count(*) INTO c FROM employees e WHERE e.employee_id = id;\nEND\n\nCALL mypout(200,@c);\nSELECT @c;\n\n-- INOUT模式\nCREATE PROCEDURE mypinout(INOUT a INT)\nBEGIN\n\tSET a:=a*2;\nEND\n\nSET @a=10;\nCALL mypinout(@a);\nSELECT @a;\n\n-- --------------命令行写法----------------\nDELIMITER $\nCREATE PROCEDURE myp1()\nBEGIN\n\tINSERT INTO a VALUES(&quot;1&quot;,&quot;1&quot;);\nEND $\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>修改</p>\n<p>MySQL中不支持直接修改存储过程的内容，可以删除原存储过程后重新创建</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p>删除</p>\n</blockquote>\n<pre><code class=\"language-sql\">DROP PROCEDURE 存储过程名;\nDROP PROCEDURE myp1;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>查看结构</p>\n</blockquote>\n<pre><code class=\"language-sql\">SHOW CREATE PROCEDURE 存储过程名;\nSHOW CREATE PROCEDURE myp2;\n</code></pre>\n<h2 class=\"markdown-h2\">自定义函数</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>与存储过程功能类似</p>\n<ul class=\"markdown-list\">\n<li>特点：\n<ul class=\"markdown-list\">\n<li>有且仅有一个返回值</li>\n<li>适用于查询并返回结果</li>\n<li>使用<code class=\"markdown-linecode\">SELECT</code>调用</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\"># 无参\n-- 创建\nCREATE FUNCTION myf1() RETURNS INT\nBEGIN\n\tDECLARE c1 INT DEFAULT 0;\n\tSELECT COUNT(*) INTO c1 FROM employees;\n\tRETURN c1;\nEND\n\n-- 调用\nSELECT myf1();\n\n# 有参\n-- 创建\nCREATE FUNCTION myf2(id INT) RETURNS VARCHAR(20)\nBEGIN\n\tDECLARE n VARCHAR(20) DEFAULT 0;\n\tSELECT last_name INTO n FROM employees e WHERE e.employee_id = id;\n\tRETURN n;\nEND\n-- 调用\nSELECT myf2(100);\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you <em>might</em> want to use the less safe log_bin_trust_function_creators variable)</p>\n<ul class=\"markdown-list\">\n<li>解决方法：<code class=\"markdown-linecode\">set global log_bin_trust_function_creators=TRUE;</code></li>\n</ul>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p>修改</p>\n<p>MySQL中不支持直接修改自定义函数的内容，可以删除原自定义函数后重新创建</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p>查看与删除</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 查看函数结构\nSHOW CREATE FUNCTION myf2;\n# 删除方法\nDROP FUNCTION myf2;\n</code></pre>\n<h2 class=\"markdown-h2\">分支结构</h2>\n<h3 class=\"markdown-h3\">IF</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>IF函数</p>\n<p>可以放在任何位置</p>\n</blockquote>\n<pre><code class=\"language-sql\">IF(E,S,F)   E成立输出S，不成立输出F\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>IF结构</p>\n<p>只能放在<code class=\"markdown-linecode\">BEGIN END</code>中</p>\n</blockquote>\n<pre><code class=\"language-sql\">IF(条件表达式1) THEN 语句1;\nELSEIF(条件表达式2) THEN 语句2;\nEND IF;\n</code></pre>\n<h3 class=\"markdown-h3\">CASE</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>使用方式一</p>\n<p>可以放在任意位置</p>\n</blockquote>\n<pre><code class=\"language-sql\"># 实现switch功能\nCASE 表达式\n\tWHEN 值1 THEN &quot;结果1&quot;\n\tWHEN 值2 THEN &quot;结果2&quot;\n\t...\n\tELSE\n\t\t&quot;没有能满足的值返回结果&quot;\nEND\n\n\n# 实现多重IF功能\nCASE \n\tWHEN 条件 THEN\n\t\t&quot;满足条件返回结果&quot;\n\t...\n\tELSE\n\t\t&quot;没有能满足的条件返回结果&quot;\nEND\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>使用方式二</p>\n<p>只能放在<code class=\"markdown-linecode\">BEGIN END</code>中</p>\n<p><code class=\"markdown-linecode\">ELSE</code>没写且<code class=\"markdown-linecode\">WHEN</code>中没有匹配值则返回<code class=\"markdown-linecode\">NULL</code></p>\n</blockquote>\n<pre><code class=\"language-sql\">CASE 表达式\n\tWHEN 值1 THEN 语句1;\n\tWHEN 值2 THEN 语句2;\n\tELSE 语句3;\nEND CASE;\n</code></pre>\n<h3 class=\"markdown-h3\">循环结构</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>MySQL中有三种循环控制语句</p>\n<p><code class=\"markdown-linecode\">WHILE</code>、<code class=\"markdown-linecode\">LOOP</code>、<code class=\"markdown-linecode\">REPEAT</code></p>\n<p>循环控制，需要配合标签使用，使用方式参考下方的<code class=\"markdown-linecode\">LOOP结构</code></p>\n<ul class=\"markdown-list\">\n<li>\n<p><code class=\"markdown-linecode\">ITERATE</code>：跳出本次循环</p>\n</li>\n<li>\n<p><code class=\"markdown-linecode\">LEAVE</code>：结束循环</p>\n</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-sql\">WHILE 循环条件 DO\n\t循环体\nEND WHILE;\n\n标签: LOOP\n\t循环体\n\tIF 结束条件 THEN\n\t\tLEAVE 标签; \n\tEND IF; \nEND LOOP 标签;\n\nREPEAT\n\t循环体\nUNTIL 循环结束条件 END REPEAT;\n</code></pre>\n<h1 class=\"markdown-h1\">图形用户界面</h1>\n<h2 class=\"markdown-h2\">Navicat</h2>\n<p><img src=\"MySQL.assets/image-20210930160337409.png\" alt=\"image-20210930160337409\" /></p>\n<h2 class=\"markdown-h2\">SQLyog</h2>\n<p><img src=\"MySQL.assets/image-20210930160419560.png\" alt=\"image-20210930160419560\" /></p>\n",
    markdown: "mysql 命令选项\n\n```sh\n-h \t\t\t连接地址\n-P \t\t\t端口号\n-u \t\t\t用户名\n-p \t\t\t密码\n\t\t\t\t隐藏输入(不跟参数即可)\n\t\t\t\t显式输入(-p和密码之间不能有空格)\n-V,--version\t版本号\n```\n\n# MySQL\n\n## 语法规范\n\n- 不区分大小写，建议关键字大写，表名列名大写\n\n- 语句以`;`或者`\\g`结尾\n\n- 换行缩进不影响执行结果，建议关键字单独一行\n\n- 注释\n\n  - 单行注释\n    - `#注释文字`\n    - `-- 注释文字`，==注意：-- 与 注释文字之间要有空格==\n  - 多行注释\n    - `/* 注释文字 */`\n\n- 字符串\n\n  - 当前字段名与关键字冲突时可以使用单引号<kbd>'</kbd>、双引号<kbd>\"</kbd>、反引号<kbd>`</kbd> 来区分\n  - 当需要输入文本型数字是使用上述符号来改变类型\n  - 当需要输入的文本有空格时\n\n  ```sql\n  SELECT USER() `user`;\n  ```\n\n  \n\n## 系统操作\n\n> 查询当前数据库版本\n\n```sql\nSELECT VERSION();\n\n\n# 输出信息\n+-----------+\n| version() |\n+-----------+\n| 8.0.18    |\n+-----------+\n1 row in set (0.00 sec)\n```\n\n> 查询当前用户\n\n```sql\nSELECT USER();\n\n+----------------+\n| USER()         |\n+----------------+\n| root@localhost |\n+----------------+\n1 row in set (0.00 sec)\n```\n\n\n\n> 退出数据库\n\n```sql\nexit\n\n# 输出信息\nBye\n```\n\n\n\n## 数据库操作\n\n> 展示所有数据库\n\n```sql\nSHOW DATABASE;\n\n# 输出信息\n+--------------------+\n| Database           |\n+--------------------+\n| information_schema | # 原信息库\n| mysql              | # 配置相关库\n| performance_schema | # 性能相关库\n| test               | # 测试用库，默认我空\n+--------------------+\n4 rows in set (0.01 sec)  # 结果数量和执行消耗时间\n```\n\n---\n\n> 切换数据库\n\n```sql\nUSE test;\n\n\n# 输出信息\nDatabase changed\n```\n\n---\n\n> 查询当前所在数据库名\n\n```sql\nSELECT DATABASE();\n\n\n# 输出信息\n+------------+\n| database() |\n+------------+\n| test       |\n+------------+\n1 row in set (0.00 sec)\n```\n\n> 创建数据库\n>\n> `CREATE DATABASE` [IF NOT EXISTS] 数据库名\n\n```sql\nCREATE DATABASE a;\n\n# 数据库不存在才创建\nCREATE DATABASE IF NOT EXISTS a;\n```\n\n> 修改数据库\n\n```sql\n# 修改数据库字符集\nALTER DATABASE a CHARACTER SET utf8;\n```\n\n> 删除数据库\n\n```sql\nDROP DATABASE a;\n\n# 数据库存在才删除\nDROP DATABASE IF EXISTS a;\n```\n\n\n\n## 表操作\n\n> 展示所有表\n\n```sql\n# 展示当前库所有表\nSHOW TABLES;\n\n# 展示指定库所有表\nSHOW TABLES FROM test;\n\n\n# 输出信息\n+----------------+\n| Tables_in_test |\n+----------------+\n| user           |\n+----------------+\n1 row in set (0.00 sec)\n\n```\n\n> 展示表结构\n\n```sql\nDESC `user`;\nSHOW COLUMNS FROM `user`;\n\n# 输出信息\n+----------+--------------+------+-----+---------+-------+\n| Field    | Type         | Null | Key | Default | Extra |\n+----------+--------------+------+-----+---------+-------+\n| username | varchar(255) | NO   | PRI | NULL    |       |\n| password | varchar(255) | NO   |     | NULL    |       |\n+----------+--------------+------+-----+---------+-------+\n2 rows in set (0.00 sec)\n```\n\n> 创建表\n\n```sql\nCREATE TABLE 表名(\n\t字段名 字段类型,\t# 必须参数\n    字段名 字段类型[(字段长度)] [约束]\n);\n```\n\n> 修改表\n>\n> - 修改列名（也可以实现修改类型）\n>   - `ALTER TABLE 表名 CHANGE COLUMN 旧列名 新列名 数据类型;`\n> - 修改列类型\n>   - `ALTER TABLE 表名 MODIFY COLUMN 列名 类型;`\n> - 增加列\n>   - `ALTER TABLE 表名 ADD COLUMN 列名 类型;`\n> - 删除列\n>   - `ALTER TABLE 表名 DROP COLUMN 列名;`\n> - 修改表名\n>   - `ALTER TABLE 旧表名 RENAME TO 新表明;`\n\n```sql\n# 修改表\n-- 修改列名\nALTER TABLE book CHANGE COLUMN page b_page INT;\n-- 修改列类型\nALTER TABLE book MODIFY COLUMN page VARCHAR(20);\n-- 添加列\nALTER TABLE book ADD COLUMN pubdate DATE;\n-- 删除列\nALTER TABLE book DROP COLUMN pubdate;\n-- 修改表名\nALTER TABLE book_s RENAME TO book;\n```\n\n> 删除表\n>\n> `DROP TABLE 表名;`\n\n```sql\n-- 删除表\nDROP TABLE book;\n```\n\n> 复制表\n>\n> - 只复制结构\n>   - `CREATE TABLE 新表 LIKE 原表;`\n> - 复制结构和数据（复制部分更改SELECT语句即可）\n>   - `CREATE TABLE 新表 SELECT * FROM 原表;`\n\n```sql\n-- 复制表结构\nCREATE TABLE book_copy LIKE book;\n-- 复制表结构和内容\nCREATE TABLE book_copy\nSELECT * FROM book;\n```\n\n\n\n## 查询\n\n### SELECT\n\n> SELECT 用法\n\n1. 查询定值\n\n   ```sql\n   SELECT 1;\n   \n   +---+\n   | 1 |\n   +---+\n   | 1 |\n   +---+\n   1 row in set (0.10 sec)\n   ```\n\n2. 查询表达式\n\n   ```sql\n   SELECT 1+1;\n   \n   +-----+\n   | 1+1 |\n   +-----+\n   |   2 |\n   +-----+\n   1 row in set (0.00 sec)\n   ```\n\n3. 查询函数\n\n   ```sql\n   SELECT DATABASE();\n   ```\n\n4. 查询表中数据\n\n   ```sql\n   SELECT * FROM 表名;\n   SELECT 字段1[,字段2....] FROM 表1[,表2....] [WHERE 条件]\n   ```\n\n### 条件查询\n\n> 普通条件查询\n>\n> 使用：<a href=\"#关系运算符\">关系运算符</a>，进行自定义查询\n>\n> - 注意：\n> - `WHERE`关键字，不能使用别名进行条件筛选\n\n\n\n```sql\n# 查询工资大于20000的员工信息\nSELECT * FROM employees WHERE salary > 20000;\n```\n\n> in\n>\n> 查询满足其中一个条件的记录，与`or`关键字类似\n\n```sql\n# 查询部门号为30/60/90的员工信息\nSELECT * FROM employees WHERE department_id IN(30,60,90)\n\n# 上面的语句完全等价于下面的语句，性能相同，这是语法表现不同\nSELECT * \nFROM employees \nWHERE department_id = 30\nOR department_id = 60\nOR department_id = 90;\n\n\n# 查询部门号不为30/60/90的员工信息\nSELECT * FROM employees WHERE department_id NOT IN(30,60,90)\n```\n\n> between ... and ...\n>\n> 区间查询\n>\n> 需要注意：第一个参数要比第二个参数小\n\n```sql\n# 查询部门号在30-90之间的员工信息\nSELECT * FROM employees WHERE department_id BETWEEN 30 AND 90;\n\n# 上面的语句完全等价于下面的语句，性能相同，这是语法表现不同\nSELECT * \nFROM employees\nWHERE department_id >= 30\nAND department_id <= 90;\n```\n\n> 空值查询\n>\n> `IS NULL`\n>\n> `IS NOT NULL`\n>\n> - 注意：\n> - `=`关键字，只能判断普通类型，无法判断`NULL`类型\n> - `IS` 关键字 只能判断`NULL`类型\n> - `<=>` 关键字(安全等于)，即能判断`NULL`类型，也能判断普通类型\n\n```sql\n# 查询没有年终奖的员工\nSELECT * FROM employees WHERE commission_pct IS NULL;\nSELECT * FROM employees WHERE commission_pct <=> NULL;\n\n# 查询有年终奖的员工\nSELECT * FROM employees WHERE commission_pct IS NOT NULL;\n```\n\n\n\n### 模糊查询\n\n> 通配符\n>\n> `_`：任意一个字符\n>\n> `%`：0个或多个字符\n\n```sql\n# 查询last_name中包含a的员工信息\nSELECT * FROM employees WHERE last_name LIKE '%a%';\n# 查询last_name中第三个字符是a的员工信息\nSELECT * FROM employees WHERE last_name LIKE '__a%';\n# 查询last_name中第二个字符是_的员工信息\nSELECT * FROM employees WHERE last_name LIKE '_\\_%';\n# 查询last_name中第二个字符是_的员工信息，自定义转义字符$\nSELECT * FROM employees WHERE last_name LIKE '_$_%' ESCAPE '$';\n```\n\n### 排序查询\n\n> `ORDER BY`\n>\n> - 升序:`asc`,默认\n> - 降序:`desc`\n>\n> - 可以使用别名进行排序\n> - 可以根据函数值进行排序\n> - 可以多字段排序\n\n```sql\n# 员工信息按照工资升序排列\nSELECT * FROM employees ORDER BY salary;\nSELECT * FROM employees ORDER BY 7; # salary 在表中是 第7列\n\n# 员工信息按照工资降序排列\nSELECT * FROM employees ORDER BY salary DESC;\n\n# 查询有奖金的员工信息，计算年薪并按年薪进行降序排序\nSELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪\nFROM employees\nWHERE commission_pct IS NOT NULL\nORDER BY 年薪 DESC;\n\n# 查询员工信息，按照员工last_name 的长度进行升序排序\nSELECT * FROM employees ORDER BY LENGTH(last_name);\n\n# 查询员工信息，先按照薪资升序，再按照部门降序\nSELECT * \nFROM employees\nORDER BY salary ASC,department_id DESC;\n```\n\n### 分组查询\n\n> `GROUP BY`\n>\n> 配合统计函数一块使用\n\n```sql\n# 统计每个部门的平均薪资\nSELECT department_id \"部门\",AVG(salary) \"平均薪资\"\nFROM employees\nGROUP BY department_id;\n```\n\n> 分组条件查询\n\n```sql\n# 查询部门成员大于5 的部门\nSELECT department_id \"部门号\", COUNT(*) \"个数\"\nFROM employees\nGROUP BY department_id\nHAVING   COUNT(*) > 5;\n```\n\n> 分组条件排序查询\n\n```sql\n# 查询所有工种中没有奖金，最高工资>6000的工种信息，按照最高工资升序显示\nSELECT job_id,MAX(salary) 最高工资\nFROM employees\nWHERE commission_pct IS  NULL\nGROUP BY job_id\nHAVING MAX(salary) > 6000\nORDER BY 最高工资;\n```\n\n> 多分组查询\n\n```sql\n# 查询每个工种在每个部门中的最低工资，按照最低工资升序排序\nSELECT job_id,department_id,MIN(salary) 最低工资\nFROM employees\nGROUP BY job_id,department_id\nORDER BY 最低工资;\n```\n\n\n\n### 常用功能\n\n> 字符串拼接\n>\n> - CONCAT的参数中有`NULL`时返回`NULL`\n>\n> - 需要注意如果参数有可能为`NULL`时，使用`IFNULL()`来过滤\n\n```sql\nSELECT CONCAT(first_name,last_name) `姓名` FROM employees;\n```\n\n---\n\n> 去重\n\n```sql\nSELECT DISTINCT department_id FROM employees\n```\n\n---\n\n> 别名\n>\n> 当前表名过长或者容易混淆时可以使用别名来区分表\n\n1. `as`关键字\n\n   ```sql\n   SELECT USER() as `user`;\n   \n   \n   +----------------+\n   | user           |\n   +----------------+\n   | root@localhost |\n   +----------------+\n   1 row in set (0.00 sec)\n   ```\n\n2. 空格\n\n   ```sql\n   SELECT USER() `user`;\n   \n   \n   +----------------+\n   | user           |\n   +----------------+\n   | root@localhost |\n   +----------------+\n   1 row in set (0.00 sec)\n   ```\n\n###  查询执行顺序\n\n1. FROM\n2. WHERE\n3. GROUP BY\n4. HAVING\n5. SELECT\n6. ORDER BY\n\n\n\n### 连接查询(多表查询)\n\n> 笛卡尔积\n>\n> 可以将两个表变成一个表\n>\n> A有N行，B有M行，A和B的笛卡尔积就有N*M行\n>\n> 笛卡尔积是连接查询的基础\n\n- A\n\n![](MySQL%20-%20%E5%89%AF%E6%9C%AC.assets/image-20211005132636716.png)\n\n- B\n\n![](MySQL%20-%20%E5%89%AF%E6%9C%AC.assets/image-20211005132735478.png)\n\n- A*B\n\n![](MySQL%20-%20%E5%89%AF%E6%9C%AC.assets/image-20211005132819726.png)\n\n> 多表查询类型\n\n**按照功能分类**\n\n- 内连接\n  - 等值连接\n  - 非等值连接\n  - 自连接\n- 外连接\n  - 左外连接\n  - 右外连接\n  - 全外连接\n- 交叉连接(笛卡尔积)\n\n**按照标准分类**\n\n- SQL92标准\n- SQL99标准\n\n> 外连接\n>\n> 外连接一般应用于查找一个表中有另一个表没有的数据\n>\n> 外连接可以实现类似集合计算中的交并补的功能\n\n#### SQL92\n\n> 等值连接\n\n```sql\n# 查询员工名和对应的部门名\nSELECT last_name,department_name\nFROM employees,departments\nWHERE employees.department_id = departments.department_id;\n```\n\n> 非等值连接\n\n```sql\n# 查询员工名及其对应的工资标准\nSELECT e.last_name,j.grade\nFROM employees e,jobs_grade j\nWHERE e.salary BETWEEN j.min_salary AND j.max_salary;\n```\n\n> 自连接\n\n```sql\n# 查询员工姓名工资，及其对应的上级员工姓名\nSELECT e.last_name,e.salary,em.last_name 上级姓名\nFROM employees e,employees em\nWHERE e.manager_id = em.employee_id;\n```\n\n> 交叉连接\n\n```sql\n# A表和B表的笛卡尔积\nSELECT * FROM a,b;\n```\n\n\n\n#### SQL99\n\n> 等值连接\n\n```sql\n# 查询员工名和对应的部门名\nSELECT e.last_name,d.department_name\nFROM employees e\nINNER JOIN departments d\nON e.department_id = d.department_id;\n```\n\n> 非等值连接\n\n```sql\n# 查询员工名及其对应的工资标准\nSELECT e.last_name,j.grade\nFROM employees e\nINNER JOIN jobs_grade j\nON e.salary BETWEEN j.min_salary AND j.max_salary;\n```\n\n> 自连接\n\n```sql\n# 查询员工姓名工资，及其对应的上级员工姓名\nSELECT e.last_name,e.salary,em.last_name 上级姓名\nFROM employees e\nINNER JOIN employees em\nON e.manager_id = em.employee_id;\n```\n\n> 左外连接\n\n```sql\n# 找出e表中没有对应部门的员工\nSELECT *\nFROM employees e\nLEFT OUTER JOIN departments d \nON d.department_id = e.department_id\nWHERE d.department_id IS NULL;\n```\n\n> 右外连接\n\n```sql\n# 找出e表中没有对应部门的员工\nSELECT *\nFROM departments d \nRIGHT OUTER JOIN employees e\nON d.department_id = e.department_id\nWHERE d.department_id IS NULL;\n```\n\n> 全外连接\n>\n> MySQL不支持全外连接\n\n```sql\nSELECT *\nFROM a\nFULL JOIN b\nON a.id=b.id;\n```\n\n> 交叉连接\n\n```sql\n# A表和B表的笛卡尔积\nSELECT *\nFROM a\nCROSS JOIN b;\n```\n\n### 子查询\n\n> 分类\n\n- 标量子查询\n  - 一行一列\n- 行子查询\n  - 一行多列\n- 列子查询\n  - 一列多行\n- 表子查询\n  - 多行多列\n\n> 各个关键字支持的子查询类型\n\n- SELECT后\n  - 标量子查询\n- FROM后\n  - 表子查询\n- WHERE或HAVING后\n  - 标量子查询\n  - 列子查询\n  - 行子查询\n- EXISTS后\n  - 表子查询\n\n> SELECT\n\n```sql\n# 查询每个部门的员工个数，追加到部门表的显示信息后面\nSELECT d.*,(\n\tSELECT COUNT(*)\n\tFROM employees e\n\tWHERE e.department_id = d.department_id\n) 员工个数\nFROM departments d;\n```\n\n> FROM\n\n```sql\n# 根据员工表计算每个部门的平均工资，并按照工资等级表划分等级\nSELECT edg.*,g.grade\nFROM (\n\tSELECT department_id 部门号,AVG(salary) 平均工资\n\tFROM employees\n\tGROUP BY department_id\n) edg\nINNER JOIN jobs_grade g\nON edg.平均工资 BETWEEN g.min_salary AND g.max_salary; \n```\n\n> WHERE&HAVING\n\n```sql\n# 标量子查询\n# 找出工种和141号员工相同，工资比143号员工高的员工信息\nselect last_name,job_id,salary\nFROM employees\nWHERE job_id = (\n\tSELECT job_id\n\tFROM employees\n\tWHERE employee_id = 141\n)\nAND salary > (\n\tSELECT salary\n\tFROM employees\n\tWHERE employee_id = 143\n);\n# 列子查询\n# 查询部门在1400和1700地区的员工信息\nSELECT last_name\nFROM employees\nWHERE department_id IN(\n\tSELECT DISTINCT department_id\n\tFROM departments\n\tWHERE location_id IN(1400,1700)\n);\n\n# 行子查询\n# 查询工号最小，工资最高的员工信息\nSELECT * \nFROM employees\nWHERE (employee_id,salary) = (\n\tSELECT MIN(employee_id),MAX(salary)\n\tFROM employees\n);\n```\n\n> EXISTS\n>\n> 查询顺序是先查主查询，然后在执行EXISTS的查询\n>\n> 判断是否存在，存在返回1，不存在返回0\n\n```sql\n# 查询有员工的部门名\nSELECT d.department_name\nFROM departments d\nWHERE EXISTS(\n\tSELECT *\n\tFROM employees e\n\tWHERE e.department_id = d.department_id\n)\n```\n\n### 联合查询\n\n> UNION\n>\n> - 将一条很长的SQL语句分割成多条较短的SQL\n> - 如果两个表的部分或全部内容含义相同，但是不在同一表中可以使用UNION将两个查询的结果拼接到一起\n>   - 字段类型必须相同\n>   - 字段个数必须相同\n>   - 位置必须一一对应\n\n```sql\n# 原查询语句\nSELECT * FROM employees WHERE email LIKE '%a%' or department_id > 90;\n\n# 使用UNION分割\nSELECT * FROM employees WHERE email LIKE '%a%'\nUNION\nSELECT * FROM employees WHERE department_id > 90;\n\n# 使用UNION拼接表\nSELECT * FROM a\nUNION\nSELECT * FROM b;\n```\n\n## 插入\n\n> 方式一\n>\n> - 支持多行插入\n> - 支持子查询\n\n```sql\nINSERT INTO b(b2) VALUES(\"bb\");\n```\n\n> 方式二\n>\n> - 仅支持单行插入\n\n```sql\nINSERT INTO b SET a2=\"aa\",b2=\"bb\"\n```\n\n## 更新\n\n> UPADTE\n>\n> - 支持级联更新\n>   - 92和99两种语法格式\n\n```sql\n# 单表更新\nUPDATE a SET a1=\"11\" WHERE b1=\"bb\";\n\n# 级联更新\nUPDATE a\nINNER JOIN b on a.bid = b.id\nset a.a1 = \"123\"\nWHERE b.a2 = \"123\"\n```\n\n## 删除\n\n> 删除记录\n>\n> - 支持级联删除\n>   - 92和99两种语法\n> - 清空表，自增不会重置而是会继续自增\n> - **事务中删除后可以回滚**\n\n```sql\n# 单表删除\nDELETE FROM a WHERE a1=\"11\";\n\n# 级联删除\nDELETE FROM a,b WHERE a.a1=\"11\" AND a.id=b.id;\n```\n\n> 清空表\n>\n> - 不能添加WHERE条件\n> - 清空后会重置自增计数器\n> - **事务中删除后无法回滚**\n\n```sql\nTRUNCATE a;\n```\n\n## 约束\n\n### 六大约束\n\n> `NOT NULL`\n>\n> 非空约束，保证字段不为空\n>\n> 示例：姓名\n\n> `DEFAULT`\n>\n> 默认约束，当没有传入值是设置一个默认值\n>\n> 示例：性别\n\n> `PRIMARY KEY`\n>\n> 主键约束，保证字段非空且具有唯一性\n>\n> 示例：学号\n\n> `UNIQUE`\n>\n> 唯一约束，保证字段唯一性，字段可以为空(==仅支持一个为空，多个不行==)\n>\n> 示例：座位号\n\n> `CHACK`\n>\n> 检查约束\n>\n> **MySQL 8.15 及其之前版本不支持**\n\n> `FOREIGN KEY`\n>\n> 外键约束，该字段值必须在另一张表中存在\n>\n> 设置在从表中\n>\n> 用于限制两张表的关系\n>\n> - 要求两个表的类型相同或者兼容\n> - 要求主表中被引用的列必须是KEY（主键、唯一键）\n\n\n\n---\n\n### 约束分类\n\n- 列级约束：直接在列后添加约束\n\n  - 六大约束都可以是列级约束\n  - ==**MySQL 8.15 及其之前版本不支持**==\n  - ==外键约束在列级约束位置不报错，但是不生效==\n\n  ```sql\n  CREATE TABLE stu(\n  \tid INT PRIMARY KEY, # 主键约束\n  \t`name` VARCHAR(20) NOT NULL, # 非空约束\n  \tgender CHAR(1) CHECK(gender=\"男\" OR gender=\"女\"), # 检查约束\n  \tseat INT UNIQUE, # 唯一约束\n  \tage INT DEFAULT 18, # 默认约束\n  \tmajor_id INT  REFERENCES majoy(id) # 外键约束\n  );\n  ```\n\n- 表级约束：在表最后添加\n\n  - 除了非空和默认，其他都支持\n  - `CONSTRAINT 约束名`，可选项，不加会自动生成约束名\n\n  ```sql\n  CREATE TABLE stu(\n  \tid INT, \n  \t`name` VARCHAR(20) NOT NULL, # 非空约束\n  \tgender CHAR(1) , \n  \tseat INT, \n  \tage INT DEFAULT 18, # 默认约束\n  \tmajor_id INT,\n  \tPRIMARY KEY(id),# 主键约束\n  \tCHECK(gender=\"男\" OR gender=\"女\"),# 检查约束\n  \tUNIQUE(seat),# 唯一约束\n  \tFOREIGN KEY(major_id) REFERENCES majoy(id) # 外键约束\n  );\n  ```\n\n- 通用写法：\n\n  - 外键放在表级约束位置，其他放在列级位置\n\n---\n\n> 主键约束和唯一约束对比\n\n|              | 保证唯一性 | 存在个数 | 是否允许为空 | 是否允许组合 |\n| ------------ | ---------- | -------- | ------------ | ------------ |\n| **主键约束** | 是         | 一个     | 否           | 是           |\n| **唯一约束** | 是         | 多个     | 是           | 是           |\n\n### 修改约束\n\n> 修改列级约束\n\n```sql\nALTER TABLE 表名 MODIFY COLUMN 表名 类型 列级约束;\nALTER TABLE stu MODIFY COLUMN `name` VARCHAR(20) NULL;\n```\n\n> 修改表级约束\n\n```sql\nALTER TABLE stu ADD 表级约束;\nALTER TABLE stu ADD UNIQUE(`name`);\n```\n\n> 删除列级约束\n\n```sql\n# 也就是修改时不加约束即可\nALTER TABLE 表名 MODIFY COLUMN 表名 类型;\nALTER TABLE stu MODIFY COLUMN `name` VARCHAR(20);\n```\n\n> 删除表级约束\n\n```sql\n# 删除主键约束\nALTER TABLE 表名 DROP PRIMARY KEY;\n\n# 删除其他约束\nSHOW INDEX FROM 表名; -- 查询所有索引\nALTER TABLE 表名 DROP INDEX 索引名; -- 删除指定索引\nALTER TABLE stu DROP INDEX `name`;\n```\n\n\n\n### 自增长列\n\n> `AUTO_INCREMEN`\n>\n> 插入数据时无需指定，会自动增长\n>\n> - 必须配合KEY使用(主键、唯一键)\n> - 每张表中只能有唯一自增列\n> - 类型必须为数值类型\n>\n> 默认初始值：1\n>\n> 默认递增值：1\n\n---\n\n> 修改`AUTO_INCREMEN`默认值\n>\n> 查看：`SHOW VARIABLES LIKE '%auto_increment%';`\n>\n> 修改递增值：`SET auto_increment_increment = 递增值;`\n>\n> MySQL修改初始值无效，但是可以在插入是手动指定\n\n## 运算符\n\n> `+`\n\n- 如果两边都是数值则直接进行加法运算\n\n```sql\nSELECT 1+1;\n\n+-----+\n| 1+1 |\n+-----+\n|   2 |\n+-----+\n1 row in set (0.00 sec)\n```\n\n- 如果两边有字符型，则将字符型转换成整数型进行加法运算\n\n```sql\nSELECT 1+'1';\n\n+-------+\n| 1+'1' |\n+-------+\n|     2 |\n+-------+\n1 row in set (0.00 sec)\n```\n\n- 如果两边有字符型，且字符型无法强转为整数时，设置为0\n\n```sql\nSELECT 1+'一';\n\n+--------+\n| 1+'一' |\n+--------+\n|      1 |\n+--------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n- 当其中有`NULL`类型时，结果永远为`NULL`\n\n```sql\nSELECT 1+null;\n\n+--------+\n| 1+null |\n+--------+\n|   NULL |\n+--------+\n1 row in set (0.00 sec)\n\n---------------------------\nSELECT null+null;\n\n+-----------+\n| null+null |\n+-----------+\n|      NULL |\n+-----------+\n1 row in set (0.00 sec)\n```\n\n---\n\n> <a name=\"关系运算符\"></a>关系运算符\n\n- `>` 大于\n- `<` 小于\n- `>=` 大于等于\n- `<=` 小于等于\n- `=` 等于\n- `!=` 、`<>` 不等于\n  - 建议使用`<>`\n- `like` 模糊查询\n- `between and`  区间\n- `in` 属于\n\n---\n\n> 逻辑运算符\n\n- `||`、`or` 逻辑或\n- `&&`、`and` 逻辑与\n\n- `!`、`not` 逻辑非\n\n- 推荐使用：`or`、`and`、`not`\n\n## 常用函数\n\n### 字符相关\n\n| 函数                     | 作用                                                         |\n| ------------------------ | ------------------------------------------------------------ |\n| CONCAT(str1,str2,...)    | 拼接字符串,如果参数中有`NULL`则结果为`NULL`                  |\n| LENGTH(str)              | 获取字节长度                                                 |\n| CHAR_LENGTH(str)         | 获取文字个数                                                 |\n| SUBSTR(str,start,len)    | 获取子串，起始下标从1开始，获取指定个数                      |\n| SUBSTR(str,start)        | 获取子串，从start位置到字符串结束                            |\n| SUBSTRING(str,start,len) | SUBSTR的全名函数                                             |\n| INSTR(str1,str2)         | 在str1中查找str2第一次出现的位置                             |\n| TRIM([x FROM ]str)       | 去除str中前后的x，中间x不去除，默认x为空格                   |\n| LPAD(str,len,padstr)     | 左填充，将str使用padstr填充到len指定的长度，如果len小于str的长度则截取str的长度到len |\n| RPAD(str,len,padstr)     | 右填充，将str使用padstr填充到len指定的长度，如果len小于str的长度则截取str的长度到len |\n| UPPER(str)               | 将str转换为大写                                              |\n| LOWER(str)               | 将str转化为小写                                              |\n| STRCMP(str1,str2)        | 比较str1和str2，1：str1大，-1：str2大，0：相等               |\n| LEFT(str,len)            | 将str左侧数len个字符截取出来                                 |\n| RIGHT(str,len)           | 将str右侧数len个字符截取出来                                 |\n\n### 数学函数\n\n| 函数          | 作用                                     |\n| ------------- | ---------------------------------------- |\n| ABS(X)        | 取X的绝对值                              |\n| CEIL(X)       | X向上取整                                |\n| FLOOR(X)      | X向下取整                                |\n| ROUND(X[,D])  | X四舍五入,保留小数点后D位(默认为0)       |\n| TRUNCATE(X,D) | 直接将X从小数点后D位截取，不考虑四舍五入 |\n| MOD(N,M)      | N取余M                                   |\n| RAND()        | 生成0-1直接的小数                        |\n\n\n\n### 日期函数\n\n| 函数                  | 作用                           |\n| --------------------- | ------------------------------ |\n| NOW()                 | 获取当前日期时间               |\n| CURRENT_DATE()        | 获取当前日期                   |\n| CURRENT_TIME()        | 获取当前时间                   |\n| DATEDIFF(date1,date2) | 获取date1-date2得到的天数      |\n| DATE_FORMAT(date,fmt) | 将date转换为fmt格式            |\n| STR_TO_DATE(str,fmt)  | 将str按照fmt格式解析为日期类型 |\n\n\n\n> format 格式字符串\n\n| 格式 | 描述                                           |\n| :--- | :--------------------------------------------- |\n| %a   | 缩写星期名                                     |\n| %b   | 缩写月名                                       |\n| %c   | 月，数值                                       |\n| %D   | 带有英文前缀的月中的天                         |\n| %d   | 月的天，数值(00-31)                            |\n| %e   | 月的天，数值(0-31)                             |\n| %f   | 微秒                                           |\n| %H   | 小时 (00-23)                                   |\n| %h   | 小时 (01-12)                                   |\n| %I   | 小时 (01-12)                                   |\n| %i   | 分钟，数值(00-59)                              |\n| %j   | 年的天 (001-366)                               |\n| %k   | 小时 (0-23)                                    |\n| %l   | 小时 (1-12)                                    |\n| %M   | 月名                                           |\n| %m   | 月，数值(00-12)                                |\n| %p   | AM 或 PM                                       |\n| %r   | 时间，12-小时（hh:mm:ss AM 或 PM）             |\n| %S   | 秒(00-59)                                      |\n| %s   | 秒(00-59)                                      |\n| %T   | 时间, 24-小时 (hh:mm:ss)                       |\n| %U   | 周 (00-53) 星期日是一周的第一天                |\n| %u   | 周 (00-53) 星期一是一周的第一天                |\n| %V   | 周 (01-53) 星期日是一周的第一天，与 %X 使用    |\n| %v   | 周 (01-53) 星期一是一周的第一天，与 %x 使用    |\n| %W   | 星期名                                         |\n| %w   | 周的天 （0=星期日, 6=星期六）                  |\n| %X   | 年，其中的星期日是周的第一天，4 位，与 %V 使用 |\n| %x   | 年，其中的星期一是周的第一天，4 位，与 %v 使用 |\n| %Y   | 年，4 位                                       |\n| %y   | 年，2 位                                       |\n\n\n\n### 流程控制\n\n> IFNULL(可能为null的参数,为null显示的值)\n>\n> 如果参数一为null，则替换为参数二\n\n\n\n> IF 分支\n\n```sql\nIF(E,S,F)   E成立输出S，不成立输出F\n```\n\n\n\n> CASE 分支\n>\n> 类似于 java中的 switch\n\n```sql\n# 实现switch功能\nCASE 表达式\n\tWHEN 值1 THEN \"结果1\"\n\tWHEN 值2 THEN \"结果2\"\n\t...\n\tELSE\n\t\t\"没有能满足的值返回结果\"\nEND\n\n\n# 实现多重IF功能\nCASE \n\tWHEN 条件 THEN\n\t\t\"满足条件返回结果\"\n\t...\n\tELSE\n\t\t\"没有能满足的条件返回结果\"\nEND\n```\n\n```sql\n# 根据工资划分等级\nSELECT last_name,\nCASE \n\tWHEN salary BETWEEN 5000 and 10000 THEN\n\t\t\"C\"\n\tWHEN salary BETWEEN 10000 and 20000 THEN\n\t\t\"B\"\n\tWHEN salary>20000 THEN\n\t\t\"A\"\n\tELSE\n\t\t\"D\"\nEND as \"等级\"\nFROM employees;\n```\n\n\n\n### 统计函数\n\n| 函数        | 作用         |\n| ----------- | ------------ |\n| SUM(字段)   | 求和         |\n| MAX(字段)   | 最大值       |\n| MIN(字段)   | 最小值       |\n| AVG(字段)   | 平均值       |\n| COUNT(字段) | 统计非空个数 |\n\n> count\n>\n> - 统计行数：`COUNT(*)` 或者 `COUNT(1)`\n\n```sql\n# 统计有人的部门个数\nSELECT COUNT(DISTINCT department_id) 部门个数 FROM employees;\n```\n\n## 数据类型\n\n### 数值类型\n\n> 整型\n>\n> 在整型数据类型后加`UNSIGNED`,表示无符号整型\n>\n> - 超出数据类型范围后会报`out of range`异常\n> - 超出范围后取范围内最接近的值\n> - 整型的长度\n>   - 整型数据类型都有自己的默认长度\n>   - ==表示的不是范围，数值范围已经由数据类型决定了==\n>   - 作用是当数值长度不足指定长度时补零（只有当加了`ZEROFILL`关键字才起效，而且`ZEROFILL`不支持负数）\n\n| 类型         | 大小  | 范围                                                   |\n| ------------ | ----- | ------------------------------------------------------ |\n| TINYINT      | 1字节 | 有符号：-128~127<br />无符号：0~255                    |\n| SMALLINT     | 2字节 | 无符号：-32768~32767<br />有符号：0~65535              |\n| MEDIUMINT    | 3字节 | 无符号：-8388608~8388607<br />有符号：0~1677215        |\n| INT、INTEGER | 4字节 | 无符号：-214783648~214783647<br />有符号：0~4294967295 |\n| BIGINT       | 8字节 |                                                        |\n\n---\n\n> 浮点型\n>\n> 更节省空间\n>\n> M：总位数\n>\n> D：小数点后位数\n>\n> 当M和D没有指定时，会根据插入的数值决定\n\n| 类型        | 大小  |\n| ----------- | ----- |\n| FLOAT(M,D)  | 4字节 |\n| DOUBLE(M,D) | 8字节 |\n\n> 定点型\n>\n> 精确度较高\n>\n> M：总位数，默认为10\n>\n> D：小数点后位数，默认为0\n\n| 类型         | 大小 |\n| ------------ | ---- |\n| DEC(M,D)     |      |\n| DECIMAL(M,D) |      |\n\n### 字符串\n\n> - CHAR：固定长度字符，不论存入的是几个字符都按照固定长度存储\n>   - 可以不指定长度，默认为1\n>   - 如果M设置为10，存入`中国`，实际占据的存储空间是10个字符的空间\n>   - 存储结构简单，查询效率更高、更占据空间\n> - VARCHAR：可变长度字符，根据实际插入的字符分配存储空间\n>   - 必须指定长度\n>   - 如果M设置为10，存入`中国`，实际占据的存储空间是2个字符的空间\n>   - 存储结构复杂，查询效率低、更节省空间\n\n| 类型       | M范围   |\n| ---------- | ------- |\n| CHAR(M)    | 0~255   |\n| VARCHAR(M) | 0-65535 |\n| TEXT       |         |\n\n\n\n\n\n### 日期时间\n\n| 类型      | 长度  | 作用     | 最小值               | 最大值                     |\n| --------- | ----- | -------- | -------------------- | -------------------------- |\n| DATE      | 4字节 | 日期     | 1000-01-01           | 9999-12-31                 |\n| TIME      | 4字节 | 时间     | -838:59:59           | 838:59:59                  |\n| DATETIME  | 8字节 | 日期时间 | 1000-01-01 00:00:00  | 9999-12-31 23:59:59        |\n| TIMESTAMP | 4字节 | 时间戳   | 1970010108001(UTC+8) | 2038-01-19 11:14:07(UTC+8) |\n| YEAR      | 1字节 | 年份     | 1901                 | 2155                       |\n\n\n\n### 二进制\n\n> 二进制\n\n| 类型      | 范围 | 作用                                   |\n| --------- | ---- | -------------------------------------- |\n| BINARY    |      | 保存短二进制数据，根据指定长度分配空间 |\n| VARBINARY |      | 保存短二进制数据，根据实际数据分配空间 |\n| BLOB      |      | 保存长二进制数据                       |\n\n\n\n### 特殊类型\n\n> ENUM\n>\n> 枚举类型\n>\n> `ENUM(枚举值1,枚举值2...)`\n>\n> - 最多65535个成员\n>   - 1-255：占1个字节\n>   - 256~65535：占2个字节\n>\n> - 只有符合枚举值要求的数值才能插入成功，否则插入空值\n> - 只能选择其中一个\n> - 不区分大小写\n\n> SET\n>\n> 集合类型\n>\n> `SET(集合值1,集合值2...)`\n>\n> - 最多64个成员\n>\n> - 只有符合集合值要求的数值才能插入成功，否则插入空值\n> - 可以选取多个\n> - 不区分大小写\n\n## 事务\n\n> 事务\n>\n> 一组SQL语句，我们希望他要么都执行，要么都不执行\n>\n> 事务特点(ACID)\n>\n> - 原子性(Atomicty)：这组SQL被视为不可分割的最小单元，要么都执行，要么都不执行\n> - 一致性(Consistency)：事务必须是从一个一致性状态转移到另一个一致性状态。例如：转账，总金额1000，转账前后总金额都应该是1000，不能增多减少\n> - 隔离性(Isolation)：单个事务的执行不受其他事务的影响，各个事务之间互不干扰\n> - 持久性(Durability)：事务一旦提交，对数据库的修改是永久性的\n\n### 创建事务\n\n> 隐式事务\n>\n> 在MySQL中，`INSERT`、`UPDATE`、`DELETE`都是隐式开启事务的\n\n---\n\n> 显示事务\n\n```sql\n-- 1.关闭自动提交，开启事务\nSET autocommit = 0;\n-- 1.2 开启事务，可以不写，上面关闭自动提交默认就开启了事务\nSTART TRANSACTION;\n\n-- 2.执行SQL,模拟转账\nUPDATE t SET money = money - 500 WHERE id = 1;\nUPDATE t SET money = money + 500 WHERE id = 2;\n\n-- 3-1 执行成功,提交事务\nCOMMIT;\n\n-- 3-2 执行失败,回滚事务\nROLLBACK;\n```\n\n### 事务隔离\n\n#### 事务存在的问题\n\n> 脏读\n>\n> A在事务中修改了数据但是还没提交，B读到了这个数据，但是A出现错误回滚了，那么B读到的数据就是错误的数据，这种现象就是脏读\n\n> 不可重复读\n>\n> A读取了数据，然后B更新了这个数据，然后A再次读取该数据时与上次读取的结果不同，这种现象叫做不可重复读\n\n> 幻读\n>\n> A读取某个表中的一个字段，然后B向这个表中添加了新的数据，A再次读取这个表时与上次读取的行数不同，这种现象叫做幻读\n\n```sql\n# 触发脏读和不可重复读\n\n# 查看当前事务隔离级别，tx_isolation在MySQL 5.7.20后被弃用\nSELECT @@transaction_isolation;\n-- ------------------命令行1中执行----------------------\n# 修改事务隔离级别为最低级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n# 开启事务\nSET autocommit=0;\n# 切换数据库\nUSE test;\n# 更新数据\nUPDATE t SET name='张三1' WHERE id=1;\n# 不提交数据\n\n-- ------------------命令行2中执行----------------------\n# 修改事务隔离级别为最低级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n# 开启事务\nSET autocommit=0;\n# 切换数据库\nUSE test;\n# 查看数据\nSELECT * from t;\n+------+-------+\n| id   | name  |\n+------+-------+\n|    1 | 张三1 |\n|    2 | 李四  |\n+------+-------+\n2 rows in set (0.00 sec)\n# 此时读取的数据已经被修改，触发脏读\n\n-- ------------------命令行1中执行----------------------\n# 回滚数据\nROLLBACK;\n-- ------------------命令行2中执行----------------------\n# 再次查看数据\nSELECT * FROM t;\n+------+------+\n| id   | name |\n+------+------+\n|    1 | 张三 |\n|    2 | 李四 |\n+------+------+\n2 rows in set (0.00 sec)\n# 触发不可重复读\n```\n\n```sql\n# 触发幻读\n-- ------------------命令行1中执行----------------------\n# 修改事务隔离级别为最低级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n# 开启事务\nSET autocommit=0;\n# 切换数据库\nUSE test;\n# 查询当前数据\nselect * from t;\n+------+------+\n| id   | name |\n+------+------+\n|    1 | 张三 |\n|    2 | 李四 |\n+------+------+\n2 rows in set (0.00 sec)\n\n-- ------------------命令行2中执行----------------------\n# 修改事务隔离级别为最低级别\nSET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n# 开启事务\nSET autocommit=0;\n# 切换数据库\nUSE test;\n# 添加数据\nINSERT INTO t VALUES(3,'王五');\n# 查看数据\nSELECT * FROM t;\n+------+------+\n| id   | name |\n+------+------+\n|    1 | 张三 |\n|    2 | 李四 |\n|    3 | 王五 |\n+------+------+\n3 rows in set (0.00 sec)\n# 提交\nCOMMIT;\n-- ------------------命令行1中执行----------------------\nUPDATE t SET name=CONCAT(name,\"1\");\nQuery OK, 3 rows affected (0.00 sec)\nRows matched: 3  Changed: 3  Warnings: 0\n# 触发幻读，之前命令行1读取的结果为2两行，但是更新却是更新了3行\n```\n\n#### 事务隔离级别\n\n> 事务级别\n>\n> **`tx_isolation`在MySQL 5.7.20后被弃用,改用`transaction_isolation`**\n>\n> - 查看：`SELECT @@transaction_isolation;`\n> - 修改：`SET SESSION TRANSACTION ISOLATION LEVEL 隔离级别;`\n\n| 隔离级别                         | 功能                           |                                              |\n| -------------------------------- | ------------------------------ | -------------------------------------------- |\n| READ UNCOMMITTED（读未提交数据） | 脏读、幻读、不可重复读都会触发 |                                              |\n| READ COMMITTED（读已提交数据）   | 可以避免脏读                   | 只允许读其他事务已经提交的数据               |\n| REPEATABLE READ（可重复读）      | 可以避免脏读和不可重复读       | 默认，禁止其他其他事务更新                   |\n| SERIALIZABLE READ（串行化）      | 可以避免所有问题               | 性能极低，禁止其他事务的所有插入、更新、删除 |\n\n## 视图\n\n> 视图使用场景\n>\n> - 实现某个功能需要多条复杂语句\n> - 该语句需要多次使用 \n\n### 创建\n\n> 创建视图\n>\n> `CREATE VIEW 视图名 AS 查询;`\n\n```sql\nCREATE VIEW tv\nAS\nSELECT e.last_name,d.department_name,j.job_title\nFROM employees e\nINNER JOIN departments d ON d.department_id = e.department_id\nINNER JOIN jobs j ON j.job_id = e.job_id;\n```\n\n### 查询\n\n> 查询视图\n>\n> 查询视图时将视图视为一张表即可,可以进行所有的查询操作\n\n```sql\nSELECT * FROM tv WHERE last_name = 'Gietz';\n```\n\n### 修改\n\n> 修改视图\n>\n> - 方式一：存在就修改，不存在就创建\n>\n> `CREATE OR REPLACE  VIEW 视图名 AS 查询;`\n>\n> - 方式二：直接修改\n>\n> `ALTER VIEW 视图名 AS 查询;`\n\n```sql\n-- 方式一\nCREATE OR REPLACE VIEW tv\nAS\nSELECT e.employee_id,e.last_name,d.department_name,j.job_title\nFROM employees e\nINNER JOIN departments d ON d.department_id = e.department_id\nINNER JOIN jobs j ON j.job_id = e.job_id;\n\n-- 方式二\nALTER VIEW tv\nAS\nSELECT e.employee_id,e.last_name,d.department_name,j.job_title\nFROM employees e\nINNER JOIN departments d ON d.department_id = e.department_id\nINNER JOIN jobs j ON j.job_id = e.job_id;\n```\n\n### 删除\n\n> 删除视图\n>\n> `DROP VIEW 视图名;`\n\n```sql\nDROP VIEW tv;\n```\n\n### 更新\n\n> 包含以下特点的视图是不允许更新的：\n>\n> - 有分组函数\n> - `DISTINCT`\n> - `GROUP BY`\n> - `HAVING`\n> - `UNION`\n> - `UNION ALL`\n> - `SELECT`中有子查询\n> - `JOIN`\n> - 依赖于不可更新的视图\n> - `WHERE`中引用了子查询中的表\n> - 常量视图\n\n## 变量\n\n### 系统变量\n\n> 系统变量\n>\n> 用于控制系统中的各种功能\n>\n> - 系统会话变量：仅针对当前会话生效\n> - 系统全局变量：针对所有会话生效的默认值\n\n> 查看系统变量\n\n```sql\n# 查看全部系统会话变量\nSHOW VARIABLES; \nSHOW SESSION VARIABLES; \n\n# 查看全部系统全局变量\nSHOW GLOBAL VARIABLES; \n\n# 查看某些系统变量\nSHOW VARIABLES LIKE \"%auto%\";\n\n# 查看指定系统会话变量\nSELECT @@autocommit; \n\n# 查看指定系统全局变量\nSELECT @@global.autocommit; \n```\n\n> 修改系统变量\n\n```sql\n# 设置系统会话变量\nSET autocommit = 0;\nSET @@autocommit = 1;\n\n# 设置系统全局变量\nSET GLOBAL autocommit = 0;\nSET @@global.autocommit = 1;\n```\n\n### 自定义变量\n\n#### 用户变量\n\n> 用户变量\n>\n> 当前会话连接有效，会话关闭后会被清除\n>\n> 用户变量前面必须加一个`@`符号\n\n> 创建\n>\n> 为了避免歧义，建议使用`:=`赋值\n\n```sql\n# 创建变量并赋值，以下三种方式都可以\nSET @test=1;\nSET @test:=2;\nSELECT @test:=3;\n```\n\n> 更新\n\n```sql\n# 方式一\nSET @test=1;\nSET @test:=2;\nSELECT @test:=3;\n# 方式二\nSELECT 字段 INTO 变量名 FROM 表;\nSELECT COUNT(*) INTO @test FROM employees;\n```\n\n> 查看\n\n```sql\nSELECT 变量名;\nSELECT @test;\n```\n\n#### 局部变量\n\n> 局部变量\n>\n> 仅仅在定义他的`BEGIN END`中有效\n>\n> 修改与查看方法和用户变量相同\n>\n> 除了使用`SELECT @test:=3;`方法赋值需要加`@`之外，其他都不需要加`@`\n\n```sql\nCREATE PROCEDURE myp4()\nBEGIN\n\tDECLARE c INT;\n\tSELECT COUNT(*) INTO c FROM employees;\n\tSELECT c;\nEND\n\nCALL myp4;\n```\n\n\n\n## 存储过程\n\n> 创建\n>\n> - 结束符：因为SQL语句中每句都要求以`;`为结尾，但是在命令行定义存储过程时使用`;`来结束存储过程时会报语法错误，此时就需要使用`DELIMITER`关键字来改变结束符，通常使用`DELIMITER $`更改结束符，更改之后所有结束位置都需要加上`$`才行，在使用图形化界面时一般没有这个限制\n> - 参数\n>   - `IN`：输入模式，也就是正常的输入参数\n>   - `OUT`：输出模式，该参数可以作为存储过程的返回值，可以向参数中写入内容\n>   - `INOUT`：输入输出模式，既可以输入也可以输出\n> - 特点\n>   - 可以有0到多个返回值\n>   - 适用于批量增删改\n>   - 使用`CALL`调用\n\n```sql\n# 无参\n-- 创建\nCREATE PROCEDURE myp2()\nBEGIN\n\tINSERT INTO a VALUES(\"2\",\"2\");\nEND\n-- 调用\nCALL myp2;\n\n\n\n# IN参数\n-- 创建\nCREATE PROCEDURE mypin(IN id INT)\nBEGIN\n\tSELECT * FROM employees e WHERE e.employee_id = id;\nEND\n-- 调用\nCALL mypin(200);\n\n# OUT模式\nCREATE PROCEDURE mypout(IN id INT,OUT c INT)\nBEGIN\n\tSELECT count(*) INTO c FROM employees e WHERE e.employee_id = id;\nEND\n\nCALL mypout(200,@c);\nSELECT @c;\n\n-- INOUT模式\nCREATE PROCEDURE mypinout(INOUT a INT)\nBEGIN\n\tSET a:=a*2;\nEND\n\nSET @a=10;\nCALL mypinout(@a);\nSELECT @a;\n\n-- --------------命令行写法----------------\nDELIMITER $\nCREATE PROCEDURE myp1()\nBEGIN\n\tINSERT INTO a VALUES(\"1\",\"1\");\nEND $\n```\n\n> 修改\n>\n> MySQL中不支持直接修改存储过程的内容，可以删除原存储过程后重新创建\n\n> 删除\n\n```sql\nDROP PROCEDURE 存储过程名;\nDROP PROCEDURE myp1;\n```\n\n>  查看结构\n\n```sql\nSHOW CREATE PROCEDURE 存储过程名;\nSHOW CREATE PROCEDURE myp2;\n```\n\n\n\n## 自定义函数\n\n> 与存储过程功能类似\n>\n> - 特点：\n>   - 有且仅有一个返回值\n>   - 适用于查询并返回结果\n>   - 使用`SELECT`调用\n\n```sql\n# 无参\n-- 创建\nCREATE FUNCTION myf1() RETURNS INT\nBEGIN\n\tDECLARE c1 INT DEFAULT 0;\n\tSELECT COUNT(*) INTO c1 FROM employees;\n\tRETURN c1;\nEND\n\n-- 调用\nSELECT myf1();\n\n# 有参\n-- 创建\nCREATE FUNCTION myf2(id INT) RETURNS VARCHAR(20)\nBEGIN\n\tDECLARE n VARCHAR(20) DEFAULT 0;\n\tSELECT last_name INTO n FROM employees e WHERE e.employee_id = id;\n\tRETURN n;\nEND\n-- 调用\nSELECT myf2(100);\n```\n\n> ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)\n>\n> - 解决方法：`set global log_bin_trust_function_creators=TRUE;`\n\n> 修改\n>\n> MySQL中不支持直接修改自定义函数的内容，可以删除原自定义函数后重新创建\n\n> 查看与删除\n\n```sql\n# 查看函数结构\nSHOW CREATE FUNCTION myf2;\n# 删除方法\nDROP FUNCTION myf2;\n```\n\n## 分支结构\n\n### IF\n\n> IF函数\n>\n> 可以放在任何位置\n\n```sql\nIF(E,S,F)   E成立输出S，不成立输出F\n```\n\n> IF结构\n>\n> 只能放在`BEGIN END`中\n\n```sql\nIF(条件表达式1) THEN 语句1;\nELSEIF(条件表达式2) THEN 语句2;\nEND IF;\n```\n\n\n\n### CASE\n\n> 使用方式一\n>\n> 可以放在任意位置\n\n```sql\n# 实现switch功能\nCASE 表达式\n\tWHEN 值1 THEN \"结果1\"\n\tWHEN 值2 THEN \"结果2\"\n\t...\n\tELSE\n\t\t\"没有能满足的值返回结果\"\nEND\n\n\n# 实现多重IF功能\nCASE \n\tWHEN 条件 THEN\n\t\t\"满足条件返回结果\"\n\t...\n\tELSE\n\t\t\"没有能满足的条件返回结果\"\nEND\n```\n\n> 使用方式二\n>\n> 只能放在`BEGIN END`中\n>\n> `ELSE`没写且`WHEN`中没有匹配值则返回`NULL`\n\n```sql\nCASE 表达式\n\tWHEN 值1 THEN 语句1;\n\tWHEN 值2 THEN 语句2;\n\tELSE 语句3;\nEND CASE;\n```\n\n### 循环结构\n\n> MySQL中有三种循环控制语句\n>\n> `WHILE`、`LOOP`、`REPEAT`\n>\n> 循环控制，需要配合标签使用，使用方式参考下方的`LOOP结构`\n>\n> - `ITERATE`：跳出本次循环\n>\n> - `LEAVE`：结束循环\n\n```sql\nWHILE 循环条件 DO\n\t循环体\nEND WHILE;\n\n标签: LOOP\n\t循环体\n\tIF 结束条件 THEN\n\t\tLEAVE 标签; \n\tEND IF; \nEND LOOP 标签;\n\nREPEAT\n\t循环体\nUNTIL 循环结束条件 END REPEAT;\n```\n\n\n\n\n\n# 图形用户界面\n\n## Navicat\n\n![image-20210930160337409](MySQL.assets/image-20210930160337409.png)\n\n## SQLyog\n\n![image-20210930160419560](MySQL.assets/image-20210930160419560.png)",
    type: "数据库",
    tag: [
        "MySQL"
    ],
    hit: NumberLong("2"),
    createDate: ISODate("2022-05-11T10:36:27.406Z"),
    modifyDate: ISODate("2022-05-11T10:36:27.406Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627b92301947aa32e2a4bec0"),
    title: "MongoDB",
    content: "<h1 class=\"markdown-h1\">安装</h1>\n<h2 class=\"markdown-h2\">Windows</h2>\n<ol class=\"markdown-list\">\n<li>下载地址：https://www.mongodb.com/try/download/community</li>\n<li>一路下一步即可</li>\n<li>最新版(5.0.6)会自动将MongoDB注册成服务，服务名称为<code class=\"markdown-linecode\">MongoDB Server (MongoDB)</code></li>\n<li>此时MongoDB已经安装完成</li>\n</ol>\n<h1 class=\"markdown-h1\">基础知识</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>集合</p>\n</blockquote>\n<p>MongoDB中的集合位置类似于关系型数据库中的表，是用来区分不同数据的</p>\n<p>关系型数据库中是一张表里面有很多条记录</p>\n<p>MongoDB中是一个集合中有很多个文档</p>\n<blockquote class=\"markdown-blockquote\">\n<p>文档</p>\n</blockquote>\n<p>MongoDB中的最小单位，位置类似于关系型数据库中的记录，用于存放数据</p>\n<blockquote class=\"markdown-blockquote\">\n<p>_id</p>\n</blockquote>\n<p>格式：<code class=\"markdown-linecode\">&quot;_id&quot;: ObjectId(&quot;621c6cfa1d3e00004c001045&quot;)</code></p>\n<p>每条记录都会生成唯一的ID信息，也就是关系型数据库中的主键，在关系型数据库中需要手动指定主键，但是在MongoDB中是自动生成的</p>\n<p>类型是<code class=\"markdown-linecode\">ObjectId</code>，这是一种利用时间戳生成的唯一编码</p>\n<p><code class=\"markdown-linecode\">_id</code>是可以自己指定的，手动指定后，系统将不再自动添加，但是要注意的是，手动指定必须要保证唯一性</p>\n<blockquote class=\"markdown-blockquote\">\n<p>BSON</p>\n</blockquote>\n<p>MongoDB使用类似于JSON的BSON格式来存储数据，在操作MongoDB时完全可以将数据看做JSON格式</p>\n<h1 class=\"markdown-h1\">CRUD操作</h1>\n<h2 class=\"markdown-h2\">增</h2>\n<pre><code class=\"language-shell\"># 单条插入\ndb.&lt;集合名&gt;.insert({name:&quot;孙悟空&quot;,age:18}); # 方式一\n\ndb.&lt;集合名&gt;.insertOne({name:&quot;白龙马&quot;,age:22}); # 方式二\n\n\n# 多条插入\ndb.&lt;集合名&gt;.insert([\n\t{name:&quot;猪八戒&quot;,age:19},\n\t{name:&quot;沙悟净&quot;,age:20},\n\t{name:&quot;唐三藏&quot;,age:21}\n]); # 方式一\n\ndb.&lt;集合名&gt;.insertMany([\n\t{name:&quot;二郎神&quot;,age:23},\n\t{name:&quot;哮天犬&quot;,age:25}\n]); # 方式二\n</code></pre>\n<h3 class=\"markdown-h3\">批量操作</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>MongoDB中支持使用JS语法进行批量操作</p>\n</blockquote>\n<pre><code class=\"language-js\">var arr=[];\nfor(var i=0;i&lt;20000;i++){\n\tarr.push({num:i});\n}\ndb.test.insert(arr);\n</code></pre>\n<h2 class=\"markdown-h2\">查</h2>\n<h3 class=\"markdown-h3\">文档查询</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>基本查询</p>\n</blockquote>\n<pre><code class=\"language-shell\"># 查询所有记录\ndb.&lt;集合名&gt;.find();\ndb.&lt;集合名&gt;.find({});\n\n# 条件查询\ndb.&lt;集合名&gt;.find({name:&quot;孙悟空&quot;}); # 单条件\ndb.&lt;集合名&gt;.find({name:&quot;孙悟空&quot;,age:18}); # 多条件查询\n\n# 查询单个\ndb.&lt;集合名&gt;.findOne({age:18}); # 只取第一个满足条件的文档\ndb.&lt;集合名&gt;.find({age:18})[0]; # 取满足条件的指定位置的文档\n\n# 查询单个属性(字段)\ndb.&lt;集合名&gt;.findOne({age:18}).name;\ndb.&lt;集合名&gt;.find({age:18})[0].name;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>统计</p>\n</blockquote>\n<pre><code class=\"language-shell\"># 统计个数\ndb.&lt;集合名&gt;.find().count();\n</code></pre>\n<h3 class=\"markdown-h3\">数组查询</h3>\n<pre><code class=\"language-shell\"># 测试数据\ndb.test.insert({name:&quot;张三&quot;,tag:[&quot;a&quot;,&quot;b&quot;]});\ndb.test.insert({name:&quot;李四&quot;,tag:[&quot;a&quot;,&quot;c&quot;]});\n</code></pre>\n<pre><code class=\"language-shell\"># 模糊查询,标签中有a的\ndb.test.find({tag:&quot;a&quot;});\n\n# 精确查询，标签值为a,b的\ndb.test.find({tag:[&quot;a&quot;,&quot;b&quot;]});\n</code></pre>\n<h3 class=\"markdown-h3\">内嵌文档查询</h3>\n<pre><code class=\"language-shell\"># 测试数据\ndb.test.insert({name:&quot;王五&quot;,address:{province:&quot;山东&quot;,city:&quot;济南&quot;}});\ndb.test.insert({name:&quot;王六&quot;,address:{province:&quot;山西&quot;,city:&quot;太原&quot;}});\n</code></pre>\n<pre><code class=\"language-shell\">db.test.find({&quot;address.city&quot;:&quot;太原&quot;});\n</code></pre>\n<h3 class=\"markdown-h3\">数学条件查询</h3>\n<p>| 符号 | 作用       | 示例                     | 对应SQL             |\n| ---- | ---------- | ------------------------ | ------------------- |\n|      | 等于       | <code class=\"markdown-linecode\">{&lt;key&gt;:&lt;value&gt;</code>}        | <code class=\"markdown-linecode\">where likes = 50</code>  |\n| $lt  | 小于       | <code class=\"markdown-linecode\">{&lt;key&gt;:{$lt:&lt;value&gt;}}</code>  | <code class=\"markdown-linecode\">where likes &lt; 50</code>  |\n| $lte | 小于或等于 | <code class=\"markdown-linecode\">{&lt;key&gt;:{$lte:&lt;value&gt;}}</code> | <code class=\"markdown-linecode\">where likes &lt;= 50</code> |\n| $gt  | 大于       | <code class=\"markdown-linecode\">{&lt;key&gt;:{$gt:&lt;value&gt;}}</code>  | <code class=\"markdown-linecode\">where likes &gt; 50</code>  |\n| $gte | 大于或等于 | <code class=\"markdown-linecode\">{&lt;key&gt;:{$gte:&lt;value&gt;}}</code> | <code class=\"markdown-linecode\">where likes &gt;= 50</code> |\n| $ne  | 不等于     | <code class=\"markdown-linecode\">{&lt;key&gt;:{$ne:&lt;value&gt;}}</code>  | <code class=\"markdown-linecode\">where likes != 50</code> |</p>\n<h3 class=\"markdown-h3\">逻辑条件查询</h3>\n<p>| 符号 | 作用 | 示例                     | 对应SQL |\n| ---- | ---- | ------------------------ | ------- |\n| or   | 或   | <code class=\"markdown-linecode\">{$or:[{条件1},{条件2]}</code> | or      |\n| and  | 与   | {{条件1},{条件2}}        | and     |</p>\n<pre><code class=\"language-shell\"># 查询num小于10或大于19950的文档\ndb.&lt;集合名&gt;.find({$or:[{num:{$lt:10}},{num:{$gt:19950}}]})\n# 查询name为孙悟空并且age为18的文档\ndb.&lt;集合名&gt;.find({name:&quot;孙悟空&quot;,age:18});\n</code></pre>\n<h3 class=\"markdown-h3\">分页查询</h3>\n<pre><code class=\"language-shell\"># 显示前10条数据\ndb.&lt;集合名&gt;.find().limit(10);\n\n# 显示11-20条数据\ndb.&lt;集合名&gt;.find().skip(10).limit(10);\n\n# 分页公式\ndb.&lt;集合名&gt;.find().skip((页数-1)*分页大小).limit(分页大小);\n</code></pre>\n<h3 class=\"markdown-h3\">排序查询</h3>\n<pre><code class=\"language-shell\"># 按照num正序排列\ndb.&lt;集合名&gt;.find().sort({num:1});\n# 按照num倒序排列\ndb.&lt;集合名&gt;.find().sort({num:-1});\n\n# 先按照num正序排列，再按照age正序排列\ndb.&lt;集合名&gt;.find().sort({num:1,age:1});\n</code></pre>\n<h3 class=\"markdown-h3\">投影查询</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>投影查询</p>\n<p>投影查询和SQL里的投影功能相同，都是用于查询结果中显示哪些字段的</p>\n</blockquote>\n<pre><code class=\"language-shell\"># 显示name和num,不显示_id(_id默认是显示的)\ndb.test.find({},{name:1,_id:0,num:1});\n</code></pre>\n<h3 class=\"markdown-h3\">字符串查询</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>$regex</p>\n<p>MongoDB中支持正则匹配，因此可以用正则实现任意的字符串匹配</p>\n</blockquote>\n<pre><code class=\"language-shell\"># 匹配name中带有三的人的信息\ndb.test.find({name:{$regex:&quot;三&quot;}});\n</code></pre>\n<h2 class=\"markdown-h2\">改</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>update</p>\n<p>update默认只修改第一个匹配的文档</p>\n</blockquote>\n<pre><code class=\"language-js\">db.collection.update(\n   &lt;query&gt;,\n   &lt;update&gt;,\n   {\n     upsert: &lt;boolean&gt;,\n     multi: &lt;boolean&gt;,\n     writeConcern: &lt;document&gt;\n   }\n)\n</code></pre>\n<ul class=\"markdown-list\">\n<li><strong>query</strong> : update的查询条件，类似sql update查询内where后面的。</li>\n<li><strong>update</strong> : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的</li>\n<li><strong>upsert</strong> : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li>\n<li><strong>multi</strong> : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li>\n<li><strong>writeConcern</strong> :可选，抛出异常的级别。</li>\n</ul>\n<h3 class=\"markdown-h3\">文档操作</h3>\n<p>| 操作符   | 作用                                         |\n| -------- | -------------------------------------------- |\n| <code class=\"markdown-linecode\">$set</code>   | 只修改<code class=\"markdown-linecode\">$set</code>指定的属性，其他属性不做修改     |\n| <code class=\"markdown-linecode\">$unset</code> | 删除<code class=\"markdown-linecode\">$unset</code>指定的属性                       |\n| <code class=\"markdown-linecode\">$inc</code>   | 自增，在原数据的基础上增加，常用作数值的增减 |</p>\n<pre><code class=\"language-shell\"># 完全修改，使用后面的对象替换前面的对象\n# 前面是查询条件，后面是修改的内容\ndb.&lt;集合名&gt;.update({name:&quot;猪八戒&quot;}, {age:18});\n\n# 部分修改,只修改$set指定的属性\ndb.&lt;集合名&gt;.update({name:&quot;猪八戒&quot;},{$set:{age:20}});\n\n# 部分删除，只删除$unset指定的属性，属性的值随便写\ndb.&lt;集合名&gt;.update({name:&quot;猪八戒&quot;},{$unset:{age:20}});\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>updateOne</p>\n</blockquote>\n<pre><code class=\"language-shell\">db.&lt;集合名&gt;.updateOne({name:&quot;猪八戒&quot;}, {$set:{age:18}})\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>updateMany</p>\n<p>修改所有匹配的文档</p>\n</blockquote>\n<pre><code class=\"language-shell\">db.&lt;集合名&gt;.updateMany({name:&quot;猪八戒&quot;},{$set:{age:22}});\n</code></pre>\n<h3 class=\"markdown-h3\">数组操作</h3>\n<p>| 操作符      | 作用                                 |\n| ----------- | ------------------------------------ |\n| <code class=\"markdown-linecode\">$push</code>     | 向数组中添加元素                     |\n| <code class=\"markdown-linecode\">$pull</code>     | 删除满足条件的元素                   |\n| <code class=\"markdown-linecode\">$addToSet</code> | 向数组中添加元素，如果存在则不再添加 |</p>\n<pre><code class=\"language-shell\"># 向数组中添加元素\ndb.test.update(\n\t{name:&quot;张三&quot;},\n\t{\n\t\t$push:{tag:&quot;d&quot;}\n\t}\n);\n\n# 向数组中添加元素，有重复元素则不添加\ndb.test.update(\n\t{name:&quot;张三&quot;},\n\t{\n\t\t$addToSet:{tag:&quot;d&quot;}\n\t}\n);\n#删除满足条件的数组元素\ndb.blog.updateOne(\n\t{_id:ObjectId(&quot;623ef0f9958dde16990bcb54&quot;)}, \n\t{$pull:\n\t\t{\n\t\t\t&quot;comment&quot;:{_id:ObjectId(&quot;62414b43b248dc6776b13cfe&quot;)}\n\t\t}\n    }\n)\n</code></pre>\n<h2 class=\"markdown-h2\">删</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>remove</p>\n</blockquote>\n<pre><code class=\"language-js\">db.collection.remove(\n   &lt;query&gt;,\n   {\n     justOne: &lt;boolean&gt;,\n     writeConcern: &lt;document&gt;\n   }\n)\n</code></pre>\n<ul class=\"markdown-list\">\n<li><strong>query</strong> :（可选）删除的文档的条件。</li>\n<li><strong>justOne</strong> : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</li>\n<li><strong>writeConcern</strong> :（可选）抛出异常的级别。</li>\n</ul>\n<pre><code class=\"language-shell\"># 删除满足指定条件的所有文档\ndb.&lt;集合名&gt;.remove({name:&quot;猪八戒&quot;});\ndb.&lt;集合名&gt;.deleteMany({name:&quot;猪八戒&quot;});\n\n# 删除满足条件的第一条文档\ndb.&lt;集合名&gt;.remove({name:&quot;猪八戒&quot;},true);\ndb.&lt;集合名&gt;.deleteOne({name:&quot;猪八戒&quot;});\n\n\n# 清空集合\ndb.&lt;集合名&gt;.remove({});\n\n# 删除集合\ndb.&lt;集合名&gt;.drop();\n</code></pre>\n<h1 class=\"markdown-h1\">SpringBoot 连接 MongoDB</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>添加依赖</p>\n</blockquote>\n<pre><code class=\"language-xml\">&lt;!-- MongoDB依赖 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>添加配置</p>\n</blockquote>\n<pre><code class=\"language-yaml\">spring:\n  data:\n    mongodb:\n      uri: mongodb://localhost:27017/blog # 根据自己的配置进行修改\n      # 设置了密码后uri为：mongodb://name:pass@localhost:27017/blog\n</code></pre>\n<pre><code class=\"language-yaml\"># 另一种写法\nspring:\n  data:\n    mongodb:\n      host: localhost\n      port: 27017\n      database: blog\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>创建实体对象</p>\n</blockquote>\n<pre><code class=\"language-java\">@ToString\n@Data\n@AllArgsConstructor\n@Document(&quot;test&quot;)// 指定实体所属集合，必须要加，否则查询会出现查不到的情况\npublic class MongoTest implements Serializable {\n    @Id\n    private ObjectId id;\n    private String name;\n    private Integer age;\n}\n\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>创建Service</p>\n<p>因为使用的是<code class=\"markdown-linecode\">MongoTemplate</code>，所有不需要Dao层</p>\n</blockquote>\n<pre><code class=\"language-java\">@Service\npublic class MongoService {\n    @Autowired\n    private MongoTemplate template;\n    // 新增\n    public void save(MongoTest mongoTest){\n        template.save(mongoTest);\n    }\n    // 根据Id查文档\n    public MongoTest findById(String Id){\n        return template.findById(Id,MongoTest.class);\n    }\n    // 查询所有文档\n    public List findAll(){\n        return template.findAll(MongoTest.class);\n    }\n    // 根据名称查文档\n    public MongoTest findByName(String name){\n        Query query = new Query(Criteria.where(&quot;name&quot;).is(name));\n        return template.findOne(query,MongoTest.class);\n    }\n    // 根据Id删除文档,返回删除个数\n    public Long deleteById(String Id){\n        Query query = new Query(Criteria.where(&quot;_id&quot;).is(Id));\n        return template.remove(query,MongoTest.class).getDeletedCount();\n    }\n}\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>测试</p>\n</blockquote>\n<pre><code class=\"language-java\">@SpringBootTest\npublic class MongoDBTest {\n    @Autowired\n    private MongoService mongoService;\n    @Test\n    public void save(){\n        MongoTest mongoTest = new MongoTest(new ObjectId(),&quot;测试&quot;,22);\n        mongoService.save(mongoTest);\n    }\n    @Test\n    public void findById(){\n        System.out.println(mongoService.findById(&quot;621dc6c9e50f9f132ff1f8ca&quot;));\n    }\n    @Test\n    public void findByName(){\n        System.out.println(mongoService.findByName(&quot;唐三藏&quot;));\n    }\n    @Test\n    public void findAll(){\n        System.out.println(mongoService.findAll());\n    }\n    @Test\n    public void deleteById(){\n        System.out.println(mongoService.deleteById(&quot;621dc6c9e50f9f132ff1f8ca&quot;));\n    }\n}\n</code></pre>\n",
    markdown: "# 安装\n\n## Windows\n\n1. 下载地址：https://www.mongodb.com/try/download/community\n2. 一路下一步即可\n3. 最新版(5.0.6)会自动将MongoDB注册成服务，服务名称为`MongoDB Server (MongoDB)`\n4. 此时MongoDB已经安装完成\n\n\n\n\n\n# 基础知识\n\n> 集合\n\nMongoDB中的集合位置类似于关系型数据库中的表，是用来区分不同数据的\n\n关系型数据库中是一张表里面有很多条记录\n\nMongoDB中是一个集合中有很多个文档\n\n> 文档\n\nMongoDB中的最小单位，位置类似于关系型数据库中的记录，用于存放数据\n\n> _id\n\n格式：`\"_id\": ObjectId(\"621c6cfa1d3e00004c001045\")`\n\n每条记录都会生成唯一的ID信息，也就是关系型数据库中的主键，在关系型数据库中需要手动指定主键，但是在MongoDB中是自动生成的\n\n类型是`ObjectId`，这是一种利用时间戳生成的唯一编码\n\n`_id`是可以自己指定的，手动指定后，系统将不再自动添加，但是要注意的是，手动指定必须要保证唯一性\n\n> BSON\n\nMongoDB使用类似于JSON的BSON格式来存储数据，在操作MongoDB时完全可以将数据看做JSON格式\n\n# CRUD操作\n\n## 增\n\n```shell\n# 单条插入\ndb.<集合名>.insert({name:\"孙悟空\",age:18}); # 方式一\n\ndb.<集合名>.insertOne({name:\"白龙马\",age:22}); # 方式二\n\n\n# 多条插入\ndb.<集合名>.insert([\n\t{name:\"猪八戒\",age:19},\n\t{name:\"沙悟净\",age:20},\n\t{name:\"唐三藏\",age:21}\n]); # 方式一\n\ndb.<集合名>.insertMany([\n\t{name:\"二郎神\",age:23},\n\t{name:\"哮天犬\",age:25}\n]); # 方式二\n```\n\n### 批量操作\n\n> MongoDB中支持使用JS语法进行批量操作\n\n```js\nvar arr=[];\nfor(var i=0;i<20000;i++){\n\tarr.push({num:i});\n}\ndb.test.insert(arr);\n```\n\n\n\n## 查\n\n### 文档查询\n\n> 基本查询\n\n```shell\n# 查询所有记录\ndb.<集合名>.find();\ndb.<集合名>.find({});\n\n# 条件查询\ndb.<集合名>.find({name:\"孙悟空\"}); # 单条件\ndb.<集合名>.find({name:\"孙悟空\",age:18}); # 多条件查询\n\n# 查询单个\ndb.<集合名>.findOne({age:18}); # 只取第一个满足条件的文档\ndb.<集合名>.find({age:18})[0]; # 取满足条件的指定位置的文档\n\n# 查询单个属性(字段)\ndb.<集合名>.findOne({age:18}).name;\ndb.<集合名>.find({age:18})[0].name;\n```\n\n> 统计\n\n```shell\n# 统计个数\ndb.<集合名>.find().count();\n```\n\n### 数组查询\n\n```shell\n# 测试数据\ndb.test.insert({name:\"张三\",tag:[\"a\",\"b\"]});\ndb.test.insert({name:\"李四\",tag:[\"a\",\"c\"]});\n```\n\n```shell\n# 模糊查询,标签中有a的\ndb.test.find({tag:\"a\"});\n\n# 精确查询，标签值为a,b的\ndb.test.find({tag:[\"a\",\"b\"]});\n```\n\n### 内嵌文档查询\n\n```shell\n# 测试数据\ndb.test.insert({name:\"王五\",address:{province:\"山东\",city:\"济南\"}});\ndb.test.insert({name:\"王六\",address:{province:\"山西\",city:\"太原\"}});\n```\n\n```shell\ndb.test.find({\"address.city\":\"太原\"});\n```\n\n### 数学条件查询\n\n| 符号 | 作用       | 示例                     | 对应SQL             |\n| ---- | ---------- | ------------------------ | ------------------- |\n|      | 等于       | `{<key>:<value>`}        | `where likes = 50`  |\n| $lt  | 小于       | `{<key>:{$lt:<value>}}`  | `where likes < 50`  |\n| $lte | 小于或等于 | `{<key>:{$lte:<value>}}` | `where likes <= 50` |\n| $gt  | 大于       | `{<key>:{$gt:<value>}}`  | `where likes > 50`  |\n| $gte | 大于或等于 | `{<key>:{$gte:<value>}}` | `where likes >= 50` |\n| $ne  | 不等于     | `{<key>:{$ne:<value>}}`  | `where likes != 50` |\n\n### 逻辑条件查询\n\n| 符号 | 作用 | 示例                     | 对应SQL |\n| ---- | ---- | ------------------------ | ------- |\n| or   | 或   | `{$or:[{条件1},{条件2]}` | or      |\n| and  | 与   | {{条件1},{条件2}}        | and     |\n\n\n\n```shell\n# 查询num小于10或大于19950的文档\ndb.<集合名>.find({$or:[{num:{$lt:10}},{num:{$gt:19950}}]})\n# 查询name为孙悟空并且age为18的文档\ndb.<集合名>.find({name:\"孙悟空\",age:18});\n```\n\n\n\n### 分页查询\n\n```shell\n# 显示前10条数据\ndb.<集合名>.find().limit(10);\n\n# 显示11-20条数据\ndb.<集合名>.find().skip(10).limit(10);\n\n# 分页公式\ndb.<集合名>.find().skip((页数-1)*分页大小).limit(分页大小);\n```\n\n### 排序查询\n\n```shell\n# 按照num正序排列\ndb.<集合名>.find().sort({num:1});\n# 按照num倒序排列\ndb.<集合名>.find().sort({num:-1});\n\n# 先按照num正序排列，再按照age正序排列\ndb.<集合名>.find().sort({num:1,age:1});\n```\n\n### 投影查询\n\n> 投影查询\n>\n> 投影查询和SQL里的投影功能相同，都是用于查询结果中显示哪些字段的\n\n```shell\n# 显示name和num,不显示_id(_id默认是显示的)\ndb.test.find({},{name:1,_id:0,num:1});\n```\n\n### 字符串查询\n\n> $regex\n>\n> MongoDB中支持正则匹配，因此可以用正则实现任意的字符串匹配\n\n```shell\n# 匹配name中带有三的人的信息\ndb.test.find({name:{$regex:\"三\"}});\n```\n\n\n\n## 改\n\n> update\n>\n> update默认只修改第一个匹配的文档\n\n```js\ndb.collection.update(\n   <query>,\n   <update>,\n   {\n     upsert: <boolean>,\n     multi: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\n- **query** : update的查询条件，类似sql update查询内where后面的。\n- **update** : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的\n- **upsert** : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\n- **multi** : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。\n- **writeConcern** :可选，抛出异常的级别。\n\n### 文档操作\n\n| 操作符   | 作用                                         |\n| -------- | -------------------------------------------- |\n| `$set`   | 只修改`$set`指定的属性，其他属性不做修改     |\n| `$unset` | 删除`$unset`指定的属性                       |\n| `$inc`   | 自增，在原数据的基础上增加，常用作数值的增减 |\n\n\n\n```shell\n# 完全修改，使用后面的对象替换前面的对象\n# 前面是查询条件，后面是修改的内容\ndb.<集合名>.update({name:\"猪八戒\"}, {age:18});\n\n# 部分修改,只修改$set指定的属性\ndb.<集合名>.update({name:\"猪八戒\"},{$set:{age:20}});\n\n# 部分删除，只删除$unset指定的属性，属性的值随便写\ndb.<集合名>.update({name:\"猪八戒\"},{$unset:{age:20}});\n```\n\n> updateOne\n\n```shell\ndb.<集合名>.updateOne({name:\"猪八戒\"}, {$set:{age:18}})\n```\n\n> updateMany\n>\n> 修改所有匹配的文档\n\n```shell\ndb.<集合名>.updateMany({name:\"猪八戒\"},{$set:{age:22}});\n```\n\n### 数组操作\n\n| 操作符      | 作用                                 |\n| ----------- | ------------------------------------ |\n| `$push`     | 向数组中添加元素                     |\n| `$pull`     | 删除满足条件的元素                   |\n| `$addToSet` | 向数组中添加元素，如果存在则不再添加 |\n\n```shell\n# 向数组中添加元素\ndb.test.update(\n\t{name:\"张三\"},\n\t{\n\t\t$push:{tag:\"d\"}\n\t}\n);\n\n# 向数组中添加元素，有重复元素则不添加\ndb.test.update(\n\t{name:\"张三\"},\n\t{\n\t\t$addToSet:{tag:\"d\"}\n\t}\n);\n#删除满足条件的数组元素\ndb.blog.updateOne(\n\t{_id:ObjectId(\"623ef0f9958dde16990bcb54\")}, \n\t{$pull:\n\t\t{\n\t\t\t\"comment\":{_id:ObjectId(\"62414b43b248dc6776b13cfe\")}\n\t\t}\n    }\n)\n```\n\n\n\n## 删\n\n> remove\n\n```js\ndb.collection.remove(\n   <query>,\n   {\n     justOne: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\n- **query** :（可选）删除的文档的条件。\n- **justOne** : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。\n- **writeConcern** :（可选）抛出异常的级别。\n\n```shell\n# 删除满足指定条件的所有文档\ndb.<集合名>.remove({name:\"猪八戒\"});\ndb.<集合名>.deleteMany({name:\"猪八戒\"});\n\n# 删除满足条件的第一条文档\ndb.<集合名>.remove({name:\"猪八戒\"},true);\ndb.<集合名>.deleteOne({name:\"猪八戒\"});\n\n\n# 清空集合\ndb.<集合名>.remove({});\n\n# 删除集合\ndb.<集合名>.drop();\n```\n\n\n\n\n\n# SpringBoot 连接 MongoDB\n\n> 添加依赖\n\n```xml\n<!-- MongoDB依赖 -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-mongodb</artifactId>\n</dependency>\n```\n\n> 添加配置\n\n```yaml\nspring:\n  data:\n    mongodb:\n      uri: mongodb://localhost:27017/blog # 根据自己的配置进行修改\n      # 设置了密码后uri为：mongodb://name:pass@localhost:27017/blog\n```\n\n```yaml\n# 另一种写法\nspring:\n  data:\n    mongodb:\n      host: localhost\n      port: 27017\n      database: blog\n```\n\n> 创建实体对象\n\n```java\n@ToString\n@Data\n@AllArgsConstructor\n@Document(\"test\")// 指定实体所属集合，必须要加，否则查询会出现查不到的情况\npublic class MongoTest implements Serializable {\n    @Id\n    private ObjectId id;\n    private String name;\n    private Integer age;\n}\n\n```\n\n> 创建Service\n>\n> 因为使用的是`MongoTemplate`，所有不需要Dao层\n\n```java\n@Service\npublic class MongoService {\n    @Autowired\n    private MongoTemplate template;\n    // 新增\n    public void save(MongoTest mongoTest){\n        template.save(mongoTest);\n    }\n    // 根据Id查文档\n    public MongoTest findById(String Id){\n        return template.findById(Id,MongoTest.class);\n    }\n    // 查询所有文档\n    public List findAll(){\n        return template.findAll(MongoTest.class);\n    }\n    // 根据名称查文档\n    public MongoTest findByName(String name){\n        Query query = new Query(Criteria.where(\"name\").is(name));\n        return template.findOne(query,MongoTest.class);\n    }\n    // 根据Id删除文档,返回删除个数\n    public Long deleteById(String Id){\n        Query query = new Query(Criteria.where(\"_id\").is(Id));\n        return template.remove(query,MongoTest.class).getDeletedCount();\n    }\n}\n```\n\n> 测试\n\n```java\n@SpringBootTest\npublic class MongoDBTest {\n    @Autowired\n    private MongoService mongoService;\n    @Test\n    public void save(){\n        MongoTest mongoTest = new MongoTest(new ObjectId(),\"测试\",22);\n        mongoService.save(mongoTest);\n    }\n    @Test\n    public void findById(){\n        System.out.println(mongoService.findById(\"621dc6c9e50f9f132ff1f8ca\"));\n    }\n    @Test\n    public void findByName(){\n        System.out.println(mongoService.findByName(\"唐三藏\"));\n    }\n    @Test\n    public void findAll(){\n        System.out.println(mongoService.findAll());\n    }\n    @Test\n    public void deleteById(){\n        System.out.println(mongoService.deleteById(\"621dc6c9e50f9f132ff1f8ca\"));\n    }\n}\n```\n\n",
    type: "数据库",
    tag: [
        "MongoDB"
    ],
    hit: NumberLong("2"),
    createDate: ISODate("2022-05-11T10:38:40.03Z"),
    modifyDate: ISODate("2022-05-11T10:38:40.03Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627b93971947aa32e2a4bec2"),
    title: "SQLServer 存储过程",
    content: "<h1 class=\"markdown-h1\">创建</h1>\n<h2 class=\"markdown-h2\">无参</h2>\n<h3 class=\"markdown-h3\">方式一</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>创建模板</p>\n</blockquote>\n<pre><code class=\"language-sql\">CREATE  PROCEDURE 存储过程名\nAS \n要执行的语句\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>示例</p>\n</blockquote>\n<pre><code class=\"language-sql\">CREATE  PROCEDURE Test_SC_CheckList\nAS \nSELECT ListItem,ListType FROM Test_ContractClose\n</code></pre>\n<h3 class=\"markdown-h3\">方式二(简写)</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>创建模板</p>\n</blockquote>\n<pre><code class=\"language-sql\">CREATE PROC 存储过程名\nAS \n要执行的语句\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>示例</p>\n</blockquote>\n<pre><code class=\"language-sql\">CREATE PROC Test_Test\nAS \nSELECT * FROM Test_SubcontractClose_CheckList\n</code></pre>\n<h3 class=\"markdown-h3\">方式三(执行多条语句)</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>模板</p>\n</blockquote>\n<pre><code class=\"language-sql\">ALTER PROCEDURE 存储过程名\nAS \nBEGIN\n\t语句1;\n\t语句2;\nEND\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>示例</p>\n</blockquote>\n<pre><code class=\"language-sql\">ALTER PROCEDURE Test_Test\nAS \nBEGIN\n\tDELETE FROM Test_SubcontractClose_CheckList WHERE MainId IS NULL;\n\tSELECT CCId FROM Test_SubcontractClose_CheckList WHERE MainId='';\nEND\n</code></pre>\n<h3 class=\"markdown-h3\">执行</h3>\n<pre><code class=\"language-sql\">EXEC Test_SC_CheckList\n</code></pre>\n<h2 class=\"markdown-h2\">有参</h2>\n<h3 class=\"markdown-h3\">方式一</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>创建模板</p>\n</blockquote>\n<pre><code class=\"language-sql\">CREATE PROCEDURE 存储过程名(@参数名 参数类型)\nAS \n要执行的语句\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>示例</p>\n</blockquote>\n<pre><code class=\"language-sql\">CREATE PROCEDURE Test_SC_CheckList(@CM_Id uniqueidentifier)\nAS \nINSERT INTO Test_SubcontractClose_CheckList\nSELECT NEWID(),@CM_Id,ListItem,0,Memo,GETDATE(),ListType,Id\nFROM Test_ContractClose C\nWHERE C.Id NOT IN (SELECT CCId FROM Test_SubcontractClose_CheckList)\n</code></pre>\n<h3 class=\"markdown-h3\">方式二</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>创建模板</p>\n</blockquote>\n<pre><code class=\"language-sql\">ALTER PROC 存储过程名\n@参数1 类型1,\n@参数2 类型2\nAS \n要执行的语句\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>示例</p>\n</blockquote>\n<pre><code class=\"language-sql\">ALTER PROC Test_Test\n@A Nvarchar(50),\n@B Nvarchar(50)\nAS \nSELECT * FROM Test_ContractClose WHERE Type=@A AND ListType=@B\n</code></pre>\n<h3 class=\"markdown-h3\">方式三(执行多条语句)</h3>\n<blockquote class=\"markdown-blockquote\">\n<p>模板</p>\n</blockquote>\n<pre><code class=\"language-sql\">ALTER PROCEDURE 存储过程名(@参数名 参数类型) \nAS \nBEGIN\n\t语句1;\n\t语句2;\nEND\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>示例</p>\n</blockquote>\n<pre><code class=\"language-sql\">ALTER PROCEDURE Test_Test(@CM_Id uniqueidentifier) \nAS \nBEGIN\n\tDELETE FROM Test_SubcontractClose_CheckList WHERE MainId = @CM_Id;\n\t\n\tINSERT INTO Test_SubcontractClose_CheckList\n\tSELECT NEWID(),@CM_Id,ListItem,0,NULL,GETDATE(),ListType,Id\n\tFROM Test_ContractClose C\n\tWHERE C.Id NOT IN (SELECT CCId FROM Test_SubcontractClose_CheckList WHERE MainId=@CM_Id ) AND Type='分包合同';\nEND\n</code></pre>\n<h3 class=\"markdown-h3\">执行</h3>\n<pre><code class=\"language-sql\">EXEC Test_SC_CheckList '55EAA76A-4ABB-4731-B981-03C04E55AEEE'\n</code></pre>\n<h1 class=\"markdown-h1\">修改</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>无参</p>\n</blockquote>\n<pre><code class=\"language-sql\">ALTER PROCEDURE 存储过程名\nAS\n修改后的语句\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>有参</p>\n</blockquote>\n<pre><code class=\"language-sql\">ALTER PROCEDURE 存储过程名(@参数名 参数类型) \nAS \n修改后的语句\n</code></pre>\n<h2 class=\"markdown-h2\">删除</h2>\n<pre><code class=\"language-sql\">DROP PROCEDURE 存储过程名\n</code></pre>\n",
    markdown: "# 创建\n\n## 无参\n\n### 方式一\n\n> 创建模板\n\n```sql\nCREATE  PROCEDURE 存储过程名\nAS \n要执行的语句\n```\n\n> 示例\n\n```sql\nCREATE  PROCEDURE Test_SC_CheckList\nAS \nSELECT ListItem,ListType FROM Test_ContractClose\n```\n\n### 方式二(简写)\n\n> 创建模板\n\n```sql\nCREATE PROC 存储过程名\nAS \n要执行的语句\n```\n\n> 示例\n\n```sql\nCREATE PROC Test_Test\nAS \nSELECT * FROM Test_SubcontractClose_CheckList\n```\n\n### 方式三(执行多条语句)\n\n> 模板\n\n```sql\nALTER PROCEDURE 存储过程名\nAS \nBEGIN\n\t语句1;\n\t语句2;\nEND\n```\n\n> 示例\n\n```sql\nALTER PROCEDURE Test_Test\nAS \nBEGIN\n\tDELETE FROM Test_SubcontractClose_CheckList WHERE MainId IS NULL;\n\tSELECT CCId FROM Test_SubcontractClose_CheckList WHERE MainId='';\nEND\n```\n\n### 执行\n\n```sql\nEXEC Test_SC_CheckList\n```\n\n## 有参\n\n### 方式一\n\n> 创建模板\n\n```sql\nCREATE PROCEDURE 存储过程名(@参数名 参数类型)\nAS \n要执行的语句\n```\n\n> 示例\n\n```sql\nCREATE PROCEDURE Test_SC_CheckList(@CM_Id uniqueidentifier)\nAS \nINSERT INTO Test_SubcontractClose_CheckList\nSELECT NEWID(),@CM_Id,ListItem,0,Memo,GETDATE(),ListType,Id\nFROM Test_ContractClose C\nWHERE C.Id NOT IN (SELECT CCId FROM Test_SubcontractClose_CheckList)\n```\n\n### 方式二\n\n> 创建模板\n\n```sql\nALTER PROC 存储过程名\n@参数1 类型1,\n@参数2 类型2\nAS \n要执行的语句\n```\n\n> 示例\n\n```sql\nALTER PROC Test_Test\n@A Nvarchar(50),\n@B Nvarchar(50)\nAS \nSELECT * FROM Test_ContractClose WHERE Type=@A AND ListType=@B\n```\n\n### 方式三(执行多条语句)\n\n> 模板\n\n```sql\nALTER PROCEDURE 存储过程名(@参数名 参数类型) \nAS \nBEGIN\n\t语句1;\n\t语句2;\nEND\n```\n\n> 示例\n\n```sql\nALTER PROCEDURE Test_Test(@CM_Id uniqueidentifier) \nAS \nBEGIN\n\tDELETE FROM Test_SubcontractClose_CheckList WHERE MainId = @CM_Id;\n\t\n\tINSERT INTO Test_SubcontractClose_CheckList\n\tSELECT NEWID(),@CM_Id,ListItem,0,NULL,GETDATE(),ListType,Id\n\tFROM Test_ContractClose C\n\tWHERE C.Id NOT IN (SELECT CCId FROM Test_SubcontractClose_CheckList WHERE MainId=@CM_Id ) AND Type='分包合同';\nEND\n```\n\n### 执行\n\n```sql\nEXEC Test_SC_CheckList '55EAA76A-4ABB-4731-B981-03C04E55AEEE'\n```\n\n# 修改\n\n> 无参\n\n```sql\nALTER PROCEDURE 存储过程名\nAS\n修改后的语句\n```\n\n> 有参\n\n```sql\nALTER PROCEDURE 存储过程名(@参数名 参数类型) \nAS \n修改后的语句\n```\n\n## 删除\n\n```sql\nDROP PROCEDURE 存储过程名\n```\n\n",
    type: "数据库",
    tag: [
        "SQL Server"
    ],
    hit: NumberLong("2"),
    createDate: ISODate("2022-05-11T10:44:39.967Z"),
    modifyDate: ISODate("2022-05-11T10:44:39.967Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627b95c11947aa32e2a4bec5"),
    title: "设计模式-代理模式",
    content: "<h1 class=\"markdown-h1\">代理模式</h1>\n<p>日常生活中存在的大量的代理模式，婚庆公司、租房中介、外卖平台、电商平台等等等等。只要是你的事情，由其他人执行，这就是代理。</p>\n<blockquote class=\"markdown-blockquote\">\n<p>租房中介</p>\n<p>这种代理模式是我们生活中非常常见的</p>\n<p>房东想要出租房子，但是自己去出租房子费时费力，还不容易找到要租房的人，房东的核心业务是出租房子，找租客，带租客看房的非核心操作并不是房东想要的</p>\n<p>因此出现了中介的角色</p>\n<p>中介负责找租客，带租客去看房，省去了房东执行这些操作的步骤</p>\n<p>中介作为代理，我们租房时是直接找到中介租的房子，房东的角色被隐藏了，但是房东的核心业务被很好的执行了，并且找租客、看房等等非必要操作对于房东来说是没有执行的。</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p>实际业务</p>\n<p>每个项目中都会有增删改查这种核心业务，还有像日志记录等等的非核心业务</p>\n<p>在增删改查等业务中加入日志记录就必须得修改原来的代码，这是不可取的，这时候需要一个代理角色来代替核心业务执行增删改查的非核心业务</p>\n</blockquote>\n<p>代理模式的优点：</p>\n<ul class=\"markdown-list\">\n<li>核心业务只需要专注于本身，无需考虑非核心业务</li>\n<li>使程序的业务分工更明确</li>\n<li>降低程序的耦合性</li>\n</ul>\n<h1 class=\"markdown-h1\">Java实现</h1>\n<h2 class=\"markdown-h2\">静态代理</h2>\n<pre><code class=\"language-java\">/**\n* 静态代理\n*/\npublic class ProxyDome{\n\tpublic static void main(String [] args){\n\t\tLandlord landlord = new Landlord();\n\t\tProxy proxy = new Proxy(landlord);\n\t\tproxy.rent();\n\t}\n}\n/**\n* 租房接口\n*/\ninterface Rent{\n\tpublic void rent();\n}\n/**\n* 房东\n*/\nclass Landlord implements Rent{\n\n\t/**\n\t* 房东出租房子，核心业务\n\t*/\n\t@Override\n\tpublic void rent(){\n\t\tSystem.out.println(&quot;房东出租房子&quot;);\n\t}\n}\n/**\n* 中介\n*/\nclass Proxy implements Rent{\n\tLandlord landlord; // 被代理的房东\n\t/**\n\t* 指定被代理的房东\n\t*/\n\tpublic Proxy(Landlord landlord){\n\t\tthis.landlord = landlord;\n\t}\n\t/**\n\t* 代理租房流程\n\t*/\n\t@Override\n\tpublic void rent(){\n\t\tseeHouse(); // 中介代替房东带你看房\n\t\tlandlord.rent(); // 房东实际租房，核心业务\n\t\tcontract(); // 中介代替房东跟你签合同\n\t}\n\t\n\t/**\n\t* 看房，非核心业务\n\t*/\n\tpublic void seeHouse(){\n\t\tSystem.out.println(&quot;中介带你看房&quot;);\n\t}\n\t/**\n\t* 签合同，非核心业务\n\t*/\n\tpublic void contract(){\n\t\tSystem.out.println(&quot;中介跟你签合同&quot;);\n\t}\n}\n</code></pre>\n<p>静态代理的缺点：</p>\n<ul class=\"markdown-list\">\n<li>每一个对象都需要写一个单独的代理对象，例如：租房代理没法帮我主持婚庆</li>\n<li>因为需要写单独的代理对象，代码量会大幅增加，开发效率变低</li>\n</ul>\n<h2 class=\"markdown-h2\">动态代理</h2>\n<p>动态代理分为两大类</p>\n<ul class=\"markdown-list\">\n<li>基于接口的代理</li>\n<li>基于类的代理</li>\n</ul>\n<p>动态代理的实现方式：</p>\n<ul class=\"markdown-list\">\n<li>JDK原生实现【只能基于接口实现】</li>\n<li>cglib实现</li>\n<li>javassist实现</li>\n</ul>\n<p>动态代理的实现依赖于反射机制</p>\n<h3 class=\"markdown-h3\">JDK 原生实现</h3>\n<p>需要用到<code class=\"markdown-linecode\">java.lang.reflect.Proxy</code>、<code class=\"markdown-linecode\">java.lang.reflect.InvocationHandler</code>、<code class=\"markdown-linecode\">java.lang.reflect.Method</code> 这三个包，这三个包都在JDK原生的反射包下</p>\n<pre><code class=\"language-java\">import java.lang.reflect.Method;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class ProxyDemo{\n\tpublic static void main(String [] args){\n\t\tTestImpl ti = new TestImpl(); // 创建被代理的对象\n\t\tProxyHandler ph = new ProxyHandler(ti); // 创建代理类，传入要被代理的对象\n\t\t// 注意得到的是接口，而不是实例\n\t\tTest t = (Test)ph.getProxy(); // 获取要被代理后的对象\n\t\t// 执行对象内的方法，也就是核心业务\n\t\tt.add();\n\t}\n}\n/**\n* 模拟核心业务接口\n*/\ninterface Test{\n\tpublic void add();\n\tpublic void del();\n\tpublic void query();\n\tpublic void update();\n}\n/**\n* 核心业务实现\n*/\nclass TestImpl implements Test{\n\t@Override\n\tpublic void add(){System.out.println(&quot;添加&quot;);}\n\t@Override\n\tpublic void del(){System.out.println(&quot;删除&quot;);}\n\t@Override\n\tpublic void update(){System.out.println(&quot;修改&quot;);}\n\t@Override\n\tpublic void query(){System.out.println(&quot;删除&quot;);}\n\t\n}\n/**\n* 代理类\n*/\nclass ProxyHandler implements InvocationHandler{\n\tprivate Object target; // 被代理的目标对象\n\tpublic ProxyHandler(){}\n\tpublic ProxyHandler(Object target){\n\t\tthis.target = target;\n\t}\n\tpublic void setTarget(Object target){\n\t\tthis.target = target;\n\t}\n\t/**\n\t* 获取被代理后的对象\n\t* Proxy.newProxyInstance\n\t* 参数1：代理类的类加载器，也就是本类的类加载器\n\t* 参数2：代理目标的所有接口\n\t* 参数3：实现InvocationHandler接口的代理类，也就是本类\n\t*/\n\tpublic Object getProxy(){\n\t\treturn Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);\n\t}\n\t\n\t/**\n\t* 实现InvocationHandler接口\n\t* 负责执行被代理对象的方法\n\t* 并在执行之前或之后处理非核心业务\n\t* @param proxy 被代理的对象\n\t* @param method 被执行的方法\n\t* @param args 被执行的方法传入的参数\n\t* @return 方法执行后的结果\n\t*/\n\t@Override\n\tpublic Object invoke(Object proxy,Method method,Object[] args) throws Throwable{\n\t\tcheck(method.getName()); // 在核心业务执行之前需要执行的,例如鉴权等\n\t\tObject result = method.invoke(target,args); // 执行核心业务,注意此处参数1不能传入proxy，否则会死循环报错\n\t\tlog(method.getName()); // 在核心业务执行之后需要执行的,例如记录日志等\n\t\treturn result;\n\t}\n\t\n\tpublic void check(String msg){\n\t\t// 模拟鉴权\n\t\tSystem.out.println(&quot;[权限鉴定]：&quot;+msg+&quot;方法鉴权成功&quot;);\n\t}\n\tpublic void log(String msg){\n\t\t// 模拟日志记录\n\t\tSystem.out.println(&quot;[日志]：执行了&quot;+msg+&quot;方法&quot;);\n\t}\n}\n</code></pre>\n<p>虽然JDK实现的动态代理已经能满足上面的需求了，但是如果类并没有实现接口JDK实现的代理就力不从心了，所以我们需要更完善的动态代理</p>\n<h3 class=\"markdown-h3\">cglib实现</h3>\n<p>cglib包在Spring core 包中已经包含</p>\n<p>maven仓库</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n    &lt;version&gt;5.3.7&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>或者手动导入Spring core的jar包</p>\n<p>优点：可以支持代理类或接口</p>\n<pre><code class=\"language-java\">import java.lang.reflect.Method;\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\npublic class CglibProxyDemo{\n\tpublic static void main(String [] args){\n\t\tTestClass t = new TestClass(); // 创建类实现对象\n\t\tTestImpl ti = new TestImpl(); // 创建接口实现对象\n\t\tTestClass testClass = (TestClass)new CglibProxyHandler().getProxy(t); //获取代理后的对象\n\t\tTestInterface testInerface = (TestInterface)new CglibProxyHandler().getProxy(ti); // 获取代理后的对象\n\t\ttestClass.add();\n\t\ttestInerface.add();\n\t}\n}\n/**\n* 模拟核心业务接口\n*/\ninterface TestInterface{\n\tpublic void add();\n\tpublic void del();\n\tpublic void query();\n\tpublic void update();\n}\n/**\n* 核心业务接口实现\n*/\nclass TestImpl implements TestInterface{\n\t@Override\n\tpublic void add(){System.out.println(&quot;接口实现：添加&quot;);}\n\t@Override\n\tpublic void del(){System.out.println(&quot;接口实现：删除&quot;);}\n\t@Override\n\tpublic void update(){System.out.println(&quot;接口实现：修改&quot;);}\n\t@Override\n\tpublic void query(){System.out.println(&quot;接口实现：删除&quot;);}\n\t\n}\n\n/**\n* 核心业务类实现\n*/\nclass TestClass{\n\tpublic void add(){System.out.println(&quot;类实现：添加&quot;);}\n\tpublic void del(){System.out.println(&quot;类实现：删除&quot;);}\n\tpublic void update(){System.out.println(&quot;类实现：修改&quot;);}\n\tpublic void query(){System.out.println(&quot;类实现：删除&quot;);}\n}\n\n/**\n* Cglib代理类实现\n*/\nclass CglibProxyHandler implements MethodInterceptor{\n\t/**\n\t* 创建代理对象\n\t* @param target 被代理的目标对象\n\t* @return 代理后的对象\n\t*/\n\tpublic Object getProxy(Object target){\n\t\tEnhancer enhancer = new Enhancer(); // 创建增强器\n\t\tenhancer.setSuperclass(target.getClass()); // 设置要被增强的类,也就是目标对象所在的类\n\t\t// 设置处理回调的方法拦截器类\n\t\t// 需要实现MethodInterceptor接口，也就是本类\n\t\tenhancer.setCallback(this); \n\t\treturn enhancer.create(); // 创建被增强后的类\n\t}\n\t\n\t/**\n\t*\n\t*/\n\t@Override\n\tpublic Object intercept(Object proxy,Method method,Object[] args,MethodProxy methodProxy) throws Throwable{\n\t\tcheck(method.getName()); // 在核心业务执行之前需要执行的,例如鉴权等\n\t\t// 注意：此处参数1是传入的参数proxy，这点与JDK实现不同\n\t\t//\t\t 同时不再使用method来执行方法，而是使用新参数methodProxy\n\t\tObject result = methodProxy.invokeSuper(proxy,args); // 执行核心业务\n\t\tlog(method.getName()); // 在核心业务执行之后需要执行的,例如记录日志等\n\t\treturn result;\n\t}\n\tpublic void check(String msg){\n\t\t// 模拟鉴权\n\t\tSystem.out.println(&quot;[权限鉴定]：&quot;+msg+&quot;方法鉴权成功&quot;);\n\t}\n\tpublic void log(String msg){\n\t\t// 模拟日志记录\n\t\tSystem.out.println(&quot;[日志]：执行了&quot;+msg+&quot;方法&quot;);\n\t}\n\t\n}\n</code></pre>\n",
    markdown: "# 代理模式\n\n日常生活中存在的大量的代理模式，婚庆公司、租房中介、外卖平台、电商平台等等等等。只要是你的事情，由其他人执行，这就是代理。\n\n> 租房中介\n>\n> 这种代理模式是我们生活中非常常见的\n>\n> 房东想要出租房子，但是自己去出租房子费时费力，还不容易找到要租房的人，房东的核心业务是出租房子，找租客，带租客看房的非核心操作并不是房东想要的\n>\n> 因此出现了中介的角色\n>\n> 中介负责找租客，带租客去看房，省去了房东执行这些操作的步骤\n>\n> 中介作为代理，我们租房时是直接找到中介租的房子，房东的角色被隐藏了，但是房东的核心业务被很好的执行了，并且找租客、看房等等非必要操作对于房东来说是没有执行的。\n\n> 实际业务\n>\n> 每个项目中都会有增删改查这种核心业务，还有像日志记录等等的非核心业务\n>\n> 在增删改查等业务中加入日志记录就必须得修改原来的代码，这是不可取的，这时候需要一个代理角色来代替核心业务执行增删改查的非核心业务\n\n\n\n代理模式的优点：\n\n- 核心业务只需要专注于本身，无需考虑非核心业务\n- 使程序的业务分工更明确\n- 降低程序的耦合性\n\n# Java实现\n\n## 静态代理\n\n```java\n/**\n* 静态代理\n*/\npublic class ProxyDome{\n\tpublic static void main(String [] args){\n\t\tLandlord landlord = new Landlord();\n\t\tProxy proxy = new Proxy(landlord);\n\t\tproxy.rent();\n\t}\n}\n/**\n* 租房接口\n*/\ninterface Rent{\n\tpublic void rent();\n}\n/**\n* 房东\n*/\nclass Landlord implements Rent{\n\n\t/**\n\t* 房东出租房子，核心业务\n\t*/\n\t@Override\n\tpublic void rent(){\n\t\tSystem.out.println(\"房东出租房子\");\n\t}\n}\n/**\n* 中介\n*/\nclass Proxy implements Rent{\n\tLandlord landlord; // 被代理的房东\n\t/**\n\t* 指定被代理的房东\n\t*/\n\tpublic Proxy(Landlord landlord){\n\t\tthis.landlord = landlord;\n\t}\n\t/**\n\t* 代理租房流程\n\t*/\n\t@Override\n\tpublic void rent(){\n\t\tseeHouse(); // 中介代替房东带你看房\n\t\tlandlord.rent(); // 房东实际租房，核心业务\n\t\tcontract(); // 中介代替房东跟你签合同\n\t}\n\t\n\t/**\n\t* 看房，非核心业务\n\t*/\n\tpublic void seeHouse(){\n\t\tSystem.out.println(\"中介带你看房\");\n\t}\n\t/**\n\t* 签合同，非核心业务\n\t*/\n\tpublic void contract(){\n\t\tSystem.out.println(\"中介跟你签合同\");\n\t}\n}\n```\n\n静态代理的缺点：\n\n- 每一个对象都需要写一个单独的代理对象，例如：租房代理没法帮我主持婚庆\n- 因为需要写单独的代理对象，代码量会大幅增加，开发效率变低\n\n\n\n## 动态代理\n\n动态代理分为两大类\n\n- 基于接口的代理\n- 基于类的代理\n\n动态代理的实现方式：\n\n- JDK原生实现【只能基于接口实现】\n- cglib实现\n- javassist实现\n\n\n\n动态代理的实现依赖于反射机制\n\n### JDK 原生实现\n\n需要用到`java.lang.reflect.Proxy`、`java.lang.reflect.InvocationHandler`、`java.lang.reflect.Method` 这三个包，这三个包都在JDK原生的反射包下\n\n```java\nimport java.lang.reflect.Method;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n\npublic class ProxyDemo{\n\tpublic static void main(String [] args){\n\t\tTestImpl ti = new TestImpl(); // 创建被代理的对象\n\t\tProxyHandler ph = new ProxyHandler(ti); // 创建代理类，传入要被代理的对象\n\t\t// 注意得到的是接口，而不是实例\n\t\tTest t = (Test)ph.getProxy(); // 获取要被代理后的对象\n\t\t// 执行对象内的方法，也就是核心业务\n\t\tt.add();\n\t}\n}\n/**\n* 模拟核心业务接口\n*/\ninterface Test{\n\tpublic void add();\n\tpublic void del();\n\tpublic void query();\n\tpublic void update();\n}\n/**\n* 核心业务实现\n*/\nclass TestImpl implements Test{\n\t@Override\n\tpublic void add(){System.out.println(\"添加\");}\n\t@Override\n\tpublic void del(){System.out.println(\"删除\");}\n\t@Override\n\tpublic void update(){System.out.println(\"修改\");}\n\t@Override\n\tpublic void query(){System.out.println(\"删除\");}\n\t\n}\n/**\n* 代理类\n*/\nclass ProxyHandler implements InvocationHandler{\n\tprivate Object target; // 被代理的目标对象\n\tpublic ProxyHandler(){}\n\tpublic ProxyHandler(Object target){\n\t\tthis.target = target;\n\t}\n\tpublic void setTarget(Object target){\n\t\tthis.target = target;\n\t}\n\t/**\n\t* 获取被代理后的对象\n\t* Proxy.newProxyInstance\n\t* 参数1：代理类的类加载器，也就是本类的类加载器\n\t* 参数2：代理目标的所有接口\n\t* 参数3：实现InvocationHandler接口的代理类，也就是本类\n\t*/\n\tpublic Object getProxy(){\n\t\treturn Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);\n\t}\n\t\n\t/**\n\t* 实现InvocationHandler接口\n\t* 负责执行被代理对象的方法\n\t* 并在执行之前或之后处理非核心业务\n\t* @param proxy 被代理的对象\n\t* @param method 被执行的方法\n\t* @param args 被执行的方法传入的参数\n\t* @return 方法执行后的结果\n\t*/\n\t@Override\n\tpublic Object invoke(Object proxy,Method method,Object[] args) throws Throwable{\n\t\tcheck(method.getName()); // 在核心业务执行之前需要执行的,例如鉴权等\n\t\tObject result = method.invoke(target,args); // 执行核心业务,注意此处参数1不能传入proxy，否则会死循环报错\n\t\tlog(method.getName()); // 在核心业务执行之后需要执行的,例如记录日志等\n\t\treturn result;\n\t}\n\t\n\tpublic void check(String msg){\n\t\t// 模拟鉴权\n\t\tSystem.out.println(\"[权限鉴定]：\"+msg+\"方法鉴权成功\");\n\t}\n\tpublic void log(String msg){\n\t\t// 模拟日志记录\n\t\tSystem.out.println(\"[日志]：执行了\"+msg+\"方法\");\n\t}\n}\n```\n\n\n\n虽然JDK实现的动态代理已经能满足上面的需求了，但是如果类并没有实现接口JDK实现的代理就力不从心了，所以我们需要更完善的动态代理\n\n### cglib实现\n\ncglib包在Spring core 包中已经包含\n\nmaven仓库\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-core</artifactId>\n    <version>5.3.7</version>\n</dependency>\n```\n\n或者手动导入Spring core的jar包\n\n\n\n优点：可以支持代理类或接口\n\n```java\nimport java.lang.reflect.Method;\nimport org.springframework.cglib.proxy.Enhancer;\nimport org.springframework.cglib.proxy.MethodInterceptor;\nimport org.springframework.cglib.proxy.MethodProxy;\npublic class CglibProxyDemo{\n\tpublic static void main(String [] args){\n\t\tTestClass t = new TestClass(); // 创建类实现对象\n\t\tTestImpl ti = new TestImpl(); // 创建接口实现对象\n\t\tTestClass testClass = (TestClass)new CglibProxyHandler().getProxy(t); //获取代理后的对象\n\t\tTestInterface testInerface = (TestInterface)new CglibProxyHandler().getProxy(ti); // 获取代理后的对象\n\t\ttestClass.add();\n\t\ttestInerface.add();\n\t}\n}\n/**\n* 模拟核心业务接口\n*/\ninterface TestInterface{\n\tpublic void add();\n\tpublic void del();\n\tpublic void query();\n\tpublic void update();\n}\n/**\n* 核心业务接口实现\n*/\nclass TestImpl implements TestInterface{\n\t@Override\n\tpublic void add(){System.out.println(\"接口实现：添加\");}\n\t@Override\n\tpublic void del(){System.out.println(\"接口实现：删除\");}\n\t@Override\n\tpublic void update(){System.out.println(\"接口实现：修改\");}\n\t@Override\n\tpublic void query(){System.out.println(\"接口实现：删除\");}\n\t\n}\n\n/**\n* 核心业务类实现\n*/\nclass TestClass{\n\tpublic void add(){System.out.println(\"类实现：添加\");}\n\tpublic void del(){System.out.println(\"类实现：删除\");}\n\tpublic void update(){System.out.println(\"类实现：修改\");}\n\tpublic void query(){System.out.println(\"类实现：删除\");}\n}\n\n/**\n* Cglib代理类实现\n*/\nclass CglibProxyHandler implements MethodInterceptor{\n\t/**\n\t* 创建代理对象\n\t* @param target 被代理的目标对象\n\t* @return 代理后的对象\n\t*/\n\tpublic Object getProxy(Object target){\n\t\tEnhancer enhancer = new Enhancer(); // 创建增强器\n\t\tenhancer.setSuperclass(target.getClass()); // 设置要被增强的类,也就是目标对象所在的类\n\t\t// 设置处理回调的方法拦截器类\n\t\t// 需要实现MethodInterceptor接口，也就是本类\n\t\tenhancer.setCallback(this); \n\t\treturn enhancer.create(); // 创建被增强后的类\n\t}\n\t\n\t/**\n\t*\n\t*/\n\t@Override\n\tpublic Object intercept(Object proxy,Method method,Object[] args,MethodProxy methodProxy) throws Throwable{\n\t\tcheck(method.getName()); // 在核心业务执行之前需要执行的,例如鉴权等\n\t\t// 注意：此处参数1是传入的参数proxy，这点与JDK实现不同\n\t\t//\t\t 同时不再使用method来执行方法，而是使用新参数methodProxy\n\t\tObject result = methodProxy.invokeSuper(proxy,args); // 执行核心业务\n\t\tlog(method.getName()); // 在核心业务执行之后需要执行的,例如记录日志等\n\t\treturn result;\n\t}\n\tpublic void check(String msg){\n\t\t// 模拟鉴权\n\t\tSystem.out.println(\"[权限鉴定]：\"+msg+\"方法鉴权成功\");\n\t}\n\tpublic void log(String msg){\n\t\t// 模拟日志记录\n\t\tSystem.out.println(\"[日志]：执行了\"+msg+\"方法\");\n\t}\n\t\n}\n```\n\n\n\n",
    type: "计算机通用知识",
    tag: [
        "设计模式"
    ],
    hit: NumberLong("1"),
    createDate: ISODate("2022-05-11T10:53:53.296Z"),
    modifyDate: ISODate("2022-05-11T10:53:53.296Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627cb92706ea2876bc375af0"),
    title: "Python requests",
    content: "<h1 class=\"markdown-h1\">get</h1>\n<h2 class=\"markdown-h2\">请求</h2>\n<pre><code class=\"language-python\">r = requests.get(url,params=params,headers=headers)\n</code></pre>\n<ul class=\"markdown-list\">\n<li>url：目标网站URL地址，字符串</li>\n<li>params:参数，字典</li>\n<li>headers：请求头，字典</li>\n</ul>\n<h2 class=\"markdown-h2\">结果对象</h2>\n<p>首先定义<code class=\"markdown-linecode\">r</code>为<code class=\"markdown-linecode\">requests.get</code>返回的结果对象</p>\n<ul class=\"markdown-list\">\n<li>\n<p>成员变量</p>\n<ul class=\"markdown-list\">\n<li>| 成员变量      | 含义                                   |\n| ------------- | -------------------------------------- |\n| r.text        | GET请求URL的源代码                     |\n| r.content     | GET请求URL的二进制数据，图片、视频等等 |\n| r.status_code | GET请求的HTTP状态码                    |\n| r.headers     | GET请求的请求头                        |\n| r.url         | GET请求的请求地址                      |\n| r.history     | 请求历史                               |\n|               |                                        |</li>\n</ul>\n</li>\n<li>\n<p>成员方法</p>\n<ul class=\"markdown-list\">\n<li>| 成员方法 | 参数 | 含义                                           |\n| -------- | ---- | ---------------------------------------------- |\n| r.json() | 无   | 将请求结果转换为json格式，若无法转换则抛出异常 |\n|          |      |                                                |\n|          |      |                                                |</li>\n</ul>\n</li>\n</ul>\n<h1 class=\"markdown-h1\">post</h1>\n<h2 class=\"markdown-h2\">文件上传</h2>\n<pre><code class=\"language-python\">import requests\nfiles = {&quot;file&quot;:open(&quot;icon.ico&quot;,&quot;rb&quot;)}\nr = requests.post(&quot;http://httpbin.org/post&quot;,files=files)\nprint(r.text)\n</code></pre>\n<h1 class=\"markdown-h1\">Session</h1>\n<h2 class=\"markdown-h2\">Session维持</h2>\n<pre><code class=\"language-python\">import requests\ns = requests.Session()\n# 请求这个网址会在服务端生成一个会话，并且设置cookies为number=12345678\ns.get(&quot;http://httpbin.org/cookies/set/number/12345678&quot;)\nr = s.get(&quot;http://httpbin.org/cookies&quot;)\nprint(r.text)\n</code></pre>\n<h1 class=\"markdown-h1\">SSL</h1>\n<h2 class=\"markdown-h2\">SSL证书错误</h2>\n<p>在访问网页会遇到一些网站的没有设置号HTTPS证书，或者HTTPS不被CA机构认可</p>\n<p>例如：</p>\n<pre><code class=\"language-python\">import requests\nr = requests.get(&quot;https://static2.scrape.cuiqingcai.com/&quot;)\nprint(r.status_code)\n</code></pre>\n<p>这时代码会直接抛出SSL异常</p>\n<pre><code class=\"language-python\"># 设置不验证证书\nrequests.get(&quot;https://static2.scrape.cuiqingcai.com/&quot;,verify=False)\n</code></pre>\n<h1 class=\"markdown-h1\">超时</h1>\n<pre><code class=\"language-python\">import requests\n# 永久等待，直接留空效果相同\nr = requests.get(&quot;https://httpbin.org/get&quot;,timeout=None)\nprint(r.status_code)\n# 连接和读取的时间总和超过一秒则抛出TimeOut异常\nr = requests.get(&quot;https://httpbin.org/get&quot;,timeout=1)\nprint(r.status_code)\n# 连接时间超过3秒或读取时间超过5秒抛出异常\nr = requests.get(&quot;https://httpbin.org/get&quot;,timeout=(3,5))\nprint(r.status_code)\n</code></pre>\n<h1 class=\"markdown-h1\">身份认证</h1>\n<h2 class=\"markdown-h2\">HTTPBasicAuth</h2>\n<p><a href=\"https://static3.scrape.cuiqingcai.com/\" target=\"_blank\">示例网站</a></p>\n<pre><code class=\"language-python\">import requests\nfrom requests.auth import HTTPBasicAuth\n\nr = requests.get(&quot;https://static3.scrape.cuiqingcai.com/&quot;,auth=HTTPBasicAuth(&quot;admin&quot;,&quot;admin&quot;))\nprint(r.status_code)\n\n# 简写\nr = requests.get(&quot;https://static3.scrape.cuiqingcai.com/&quot;,auth=(&quot;admin&quot;,&quot;admin&quot;))\nprint(r.status_code)\n</code></pre>\n<h2 class=\"markdown-h2\">OAuth</h2>\n<p>安装：<code class=\"markdown-linecode\">pip install requests_oauthlib</code></p>\n<pre><code class=\"language-python\">import requests\nfrom requests_oauthlib import OAuth1\nr = requests.get(&quot;xxx&quot;,auth=OAuth1(&quot;admin&quot;,&quot;admin&quot;))\nprint(r.status_code)\n</code></pre>\n<h1 class=\"markdown-h1\">Cookie</h1>\n<p>header里面直接加cookie项</p>\n<pre><code class=\"language-python\">headers = {\n    &quot;Cookie&quot;: &quot;stay_login=1; id=8ZZe8BthuemXE1780PDN123456; smid=RX6DFOr_qqIOgCRrsQyciQF7jp3qnMdXd1OIzhbxlntE2OxNcDRCKl_ykhnwdZDyXBvvFdUQtYhFWV9miq68jw;&quot;\n}\n</code></pre>\n",
    markdown: "# get\n\n## 请求\n\n```python\nr = requests.get(url,params=params,headers=headers)\n```\n\n- url：目标网站URL地址，字符串\n- params:参数，字典\n- headers：请求头，字典\n\n## 结果对象\n\n首先定义`r`为`requests.get`返回的结果对象\n\n\n\n- 成员变量\n\n  - | 成员变量      | 含义                                   |\n    | ------------- | -------------------------------------- |\n    | r.text        | GET请求URL的源代码                     |\n    | r.content     | GET请求URL的二进制数据，图片、视频等等 |\n    | r.status_code | GET请求的HTTP状态码                    |\n    | r.headers     | GET请求的请求头                        |\n    | r.url         | GET请求的请求地址                      |\n    | r.history     | 请求历史                               |\n    |               |                                        |\n\n- 成员方法\n\n  - | 成员方法 | 参数 | 含义                                           |\n    | -------- | ---- | ---------------------------------------------- |\n    | r.json() | 无   | 将请求结果转换为json格式，若无法转换则抛出异常 |\n    |          |      |                                                |\n    |          |      |                                                |\n\n\n\n# post\n\n## 文件上传\n\n```python\nimport requests\nfiles = {\"file\":open(\"icon.ico\",\"rb\")}\nr = requests.post(\"http://httpbin.org/post\",files=files)\nprint(r.text)\n```\n\n\n\n# Session\n\n## Session维持\n\n```python\nimport requests\ns = requests.Session()\n# 请求这个网址会在服务端生成一个会话，并且设置cookies为number=12345678\ns.get(\"http://httpbin.org/cookies/set/number/12345678\")\nr = s.get(\"http://httpbin.org/cookies\")\nprint(r.text)\n```\n\n\n\n# SSL\n\n## SSL证书错误\n\n在访问网页会遇到一些网站的没有设置号HTTPS证书，或者HTTPS不被CA机构认可\n\n例如：\n\n```python\nimport requests\nr = requests.get(\"https://static2.scrape.cuiqingcai.com/\")\nprint(r.status_code)\n```\n\n这时代码会直接抛出SSL异常\n\n```python\n# 设置不验证证书\nrequests.get(\"https://static2.scrape.cuiqingcai.com/\",verify=False)\n```\n\n\n\n# 超时\n\n```python\nimport requests\n# 永久等待，直接留空效果相同\nr = requests.get(\"https://httpbin.org/get\",timeout=None)\nprint(r.status_code)\n# 连接和读取的时间总和超过一秒则抛出TimeOut异常\nr = requests.get(\"https://httpbin.org/get\",timeout=1)\nprint(r.status_code)\n# 连接时间超过3秒或读取时间超过5秒抛出异常\nr = requests.get(\"https://httpbin.org/get\",timeout=(3,5))\nprint(r.status_code)\n```\n\n# 身份认证\n\n## HTTPBasicAuth\n\n[示例网站](https://static3.scrape.cuiqingcai.com/)\n\n```python\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nr = requests.get(\"https://static3.scrape.cuiqingcai.com/\",auth=HTTPBasicAuth(\"admin\",\"admin\"))\nprint(r.status_code)\n\n# 简写\nr = requests.get(\"https://static3.scrape.cuiqingcai.com/\",auth=(\"admin\",\"admin\"))\nprint(r.status_code)\n```\n\n## OAuth\n\n安装：`pip install requests_oauthlib`\n\n```python\nimport requests\nfrom requests_oauthlib import OAuth1\nr = requests.get(\"xxx\",auth=OAuth1(\"admin\",\"admin\"))\nprint(r.status_code)\n```\n\n# Cookie\n\nheader里面直接加cookie项\n\n```python\nheaders = {\n    \"Cookie\": \"stay_login=1; id=8ZZe8BthuemXE1780PDN123456; smid=RX6DFOr_qqIOgCRrsQyciQF7jp3qnMdXd1OIzhbxlntE2OxNcDRCKl_ykhnwdZDyXBvvFdUQtYhFWV9miq68jw;\"\n}\n```\n\n",
    type: "Python",
    tag: [
        "Python模块"
    ],
    hit: NumberInt("0"),
    createDate: ISODate("2022-05-12T07:37:11.195Z"),
    modifyDate: ISODate("2022-05-12T07:37:11.195Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627cb94706ea2876bc375af2"),
    title: "Python Selenium",
    content: "<h1 class=\"markdown-h1\">简介</h1>\n<p>Selenium是一个自动化测试工具，可以实现自动化测试Web项目</p>\n<p>当然你也可以把它当做爬取网页的工具，实现所有能够看见的数据都能爬取的效果，它爬取JS动态渲染且请求加密的网站是非常有效的</p>\n<h1 class=\"markdown-h1\">安装</h1>\n<p>示例为chrome浏览器，如果是其他浏览器安装步骤类似，就是其中的驱动需要换成你的浏览器的版本，在网上可以找到对应版本的下载地址</p>\n<ol class=\"markdown-list\">\n<li>\n<p>安装Chrome</p>\n</li>\n<li>\n<p>安装ChromeDriver</p>\n<ul class=\"markdown-list\">\n<li>前往<a href=\"https://chromedriver.storage.googleapis.com/index.html\" target=\"_blank\">https://chromedriver.storage.googleapis.com/index.html</a>下载与你Chrome版本匹配的程序</li>\n<li>解压后，将chromedriver.exe放入python/Script目录下</li>\n<li>或者直接将chromedriver.exe添加到环境变量</li>\n<li>cmd执行chromedriver出现下图则为成功</li>\n<li><img src=\"Selenium%E5%BA%93.assets/image-20201117104843025.png\" alt=\"image-20201117104843025\" /></li>\n</ul>\n</li>\n<li>\n<p>安装Selenium</p>\n<ul class=\"markdown-list\">\n<li>\n<pre><code>pip install selenium\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h1 class=\"markdown-h1\">初始化</h1>\n<pre><code class=\"language-python\">from selenium import webdriver # 导包\nbrowser = webdriver.Chrome() # 创建chrome浏览器对象,自动打开一个chrome浏览器\n</code></pre>\n<h1 class=\"markdown-h1\">浏览器方法</h1>\n<h2 class=\"markdown-h2\">请求指定网址</h2>\n<pre><code class=\"language-python\">browser.get(&quot;https://www.baidu.com&quot;) # 请求指定网址，URL必须包含协议\n</code></pre>\n<h2 class=\"markdown-h2\">关闭浏览器</h2>\n<pre><code class=\"language-python\">browser.close()# 关闭浏览器\n</code></pre>\n<h2 class=\"markdown-h2\">查找单个节点</h2>\n<pre><code class=\"language-python\">from selenium.webdriver.common.by import By # 使用find_element或find_elements需要使用\nbrowser.find_element(By.ID,&quot;kw&quot;)# 统一查找方法，下面查找单个节点的方法实际上都是使用该方法实现的\nbrowser.find_element_by_id(&quot;kw&quot;)# 根据元素ID查找单个节点\nbrowser.find_element_by_name(&quot;wd&quot;)# 根据元素name查找单个节点\nbrowser.find_element_by_css_selector(&quot;.s_ipt&quot;)# 根据CSS选择器查找单个节点\nbrowser.find_element_by_xpath('//*[@id=&quot;kw&quot;]')# 根据Xpath查找单个节点\n\n## 还有很多方法\n</code></pre>\n<h2 class=\"markdown-h2\">查找多个节点</h2>\n<pre><code class=\"language-python\">browser.find_elements(By.CLASS_NAME,&quot;c-color-gray2&quot;)# 查找多个节点的统一实现\nbrowser.find_elements_by_class_name(&quot;c-color-gray2&quot;)# 根据类名查找多个节点，返回列表\n\n## 还有很多方法\n</code></pre>\n<h2 class=\"markdown-h2\">执行JavaScript脚本</h2>\n<pre><code class=\"language-python\">browser.execute_script('alert(&quot;执行JavaScript脚本&quot;)')# 执行JS\n</code></pre>\n<h2 class=\"markdown-h2\">切换Frame</h2>\n<pre><code class=\"language-python\">browser.switch_to.frame(&quot;iframe&quot;)# 切换到指定iframe\nbrowser.switch_to.parent_frame # 切换回父frame\n</code></pre>\n<h2 class=\"markdown-h2\">切换选项卡窗口</h2>\n<h2 class=\"markdown-h2\">后退和前进</h2>\n<pre><code class=\"language-python\">browser.back()# 后退\nbrowser.forward()# 前进\n</code></pre>\n<h2 class=\"markdown-h2\">cookies操作</h2>\n<pre><code class=\"language-python\">browser.get_cookies()# 获取全部Cookies\n\n# 添加cookie\nbrowser.add_cookie({&quot;name&quot;:&quot;ABC&quot;,# cookie名\n                    &quot;value&quot;:&quot;123&quot;# cookie值\n                   })\n\nbrowser.get_cookie(&quot;ABC&quot;)# 获取指定cookie\n</code></pre>\n<h1 class=\"markdown-h1\">浏览器属性</h1>\n<h2 class=\"markdown-h2\">获取源代码</h2>\n<pre><code class=\"language-python\">browser.page_source # 打印网页源代码\n</code></pre>\n<h1 class=\"markdown-h1\">节点方法</h1>\n<pre><code class=\"language-python\">in_text = browser.find_element_by_id(&quot;kw&quot;)# 选中百度的输入框\n</code></pre>\n<h2 class=\"markdown-h2\">输入值</h2>\n<pre><code class=\"language-python\">in_text.send_keys(&quot;selenium&quot;)# 向元素中添加内容\n</code></pre>\n<h2 class=\"markdown-h2\">清空值</h2>\n<pre><code class=\"language-python\">in_text.clear()# 清空元素内容\n</code></pre>\n<h2 class=\"markdown-h2\">点击按钮</h2>\n<pre><code class=\"language-python\">button = browser.find_element_by_id(&quot;su&quot;)# 获取百度中的按钮\nbutton.click()# 点击按钮\n</code></pre>\n<h2 class=\"markdown-h2\">获取指定属性</h2>\n<pre><code class=\"language-python\">button.get_attribute(&quot;class&quot;)# 获取节点的指定属性\n</code></pre>\n<h1 class=\"markdown-h1\">节点属性</h1>\n<h2 class=\"markdown-h2\">获取节点内容</h2>\n<pre><code class=\"language-python\">next_text = browser.find_element_by_class_name(&quot;hot-refresh-text&quot;)\nnext_text.text# 获取内容\n</code></pre>\n<h2 class=\"markdown-h2\">获取ID</h2>\n<pre><code class=\"language-python\">next_text.id#获取ID\n</code></pre>\n<h2 class=\"markdown-h2\">获取坐标</h2>\n<pre><code class=\"language-python\">next_text.location# 获取坐标\n</code></pre>\n<h2 class=\"markdown-h2\">获取标签类型</h2>\n<pre><code class=\"language-python\">next_text.tag_name# 获取标签类型\n</code></pre>\n<h2 class=\"markdown-h2\">获取大小</h2>\n<pre><code class=\"language-python\">next_text.size# 获取大小\n</code></pre>\n<h1 class=\"markdown-h1\">等待元素加载</h1>\n<h2 class=\"markdown-h2\">隐式等待</h2>\n<ul class=\"markdown-list\">\n<li>隐式等待是直接先查找元素是否存在，如果存在则返回元素</li>\n<li>若元素不存在，则等待指定时间，再次查找元素，若还不存在则抛出异常</li>\n</ul>\n<pre><code class=\"language-python\">browser.implicitly_wait(5)# 隐式等待时间\nbrowser.find_element_by_id(&quot;123&quot;)# 查找，等待5秒再次查找，如果没找到则报错\n</code></pre>\n<h2 class=\"markdown-h2\">显式等待</h2>\n<ul class=\"markdown-list\">\n<li>设定一个等待时间</li>\n<li>若在指定时间内加载完成则直接返回对象</li>\n<li>若到达了指定时间还未加载完成则抛出异常</li>\n<li>相较于隐式等待，显式等待是更好的解决方法</li>\n</ul>\n<pre><code class=\"language-python\">from selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.common.by import By\n\nwait = WebDriverWait(browser,5)# 显式等待\nbrowser.find_element_by_id(&quot;123&quot;)\nwait.until(EC.presence_of_element_located((By.ID,&quot;123&quot;)))\n</code></pre>\n<h1 class=\"markdown-h1\">Selenium反爬与绕过</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>反爬原理</p>\n</blockquote>\n<p>Selenium的反爬原理是检测window.navigator.webdriver</p>\n<p>正常浏览器访问时，该对象为undefined</p>\n<p>当使用selenium访问时，该对象会被设置为true</p>\n<p>网站会使用js来判断该对象的内容来决定是否对你进行屏蔽</p>\n<p>示例网站：https://antispider1.scrape.cuiqingcai.com/</p>\n<blockquote class=\"markdown-blockquote\">\n<p>绕过</p>\n</blockquote>\n<p>Chrome79 之前</p>\n<pre><code class=\"language-python\">from selenium.webdriver import ChromeOptions\noption = ChromeOptions()\noption.add_experimental_option('excludeSwitches', ['enable-automation'])\nbrowser = webdriver.Chrome(options = option)\n</code></pre>\n<p>Chrome79之后</p>\n<pre><code class=\"language-python\">browser.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, {\n  &quot;source&quot;: &quot;&quot;&quot;\n    Object.defineProperty(navigator, 'webdriver', {\n      get: () =&gt; undefined\n    })\n  &quot;&quot;&quot;\n})\n</code></pre>\n<h1 class=\"markdown-h1\">启动参数</h1>\n<h2 class=\"markdown-h2\">无头模式</h2>\n<ul class=\"markdown-list\">\n<li>隐藏浏览器界面</li>\n</ul>\n<pre><code class=\"language-python\">from selenium.webdriver import ChromeOptions\noption = ChromeOptions()\noption.add_argument(&quot;--headless&quot;)\nbrowser = webdriver.Chrome(options=option)\n</code></pre>\n",
    markdown: "# 简介\n\nSelenium是一个自动化测试工具，可以实现自动化测试Web项目\n\n当然你也可以把它当做爬取网页的工具，实现所有能够看见的数据都能爬取的效果，它爬取JS动态渲染且请求加密的网站是非常有效的\n\n# 安装\n\n示例为chrome浏览器，如果是其他浏览器安装步骤类似，就是其中的驱动需要换成你的浏览器的版本，在网上可以找到对应版本的下载地址\n\n1. 安装Chrome\n\n2. 安装ChromeDriver\n\n   - 前往[https://chromedriver.storage.googleapis.com/index.html](https://chromedriver.storage.googleapis.com/index.html)下载与你Chrome版本匹配的程序\n   - 解压后，将chromedriver.exe放入python/Script目录下\n   - 或者直接将chromedriver.exe添加到环境变量\n   - cmd执行chromedriver出现下图则为成功\n   - ![image-20201117104843025](Selenium%E5%BA%93.assets/image-20201117104843025.png)\n\n3. 安装Selenium\n\n   - ```\n     pip install selenium\n     ```\n\n# 初始化\n\n```python\nfrom selenium import webdriver # 导包\nbrowser = webdriver.Chrome() # 创建chrome浏览器对象,自动打开一个chrome浏览器\n```\n\n# 浏览器方法\n\n## 请求指定网址\n\n```python\nbrowser.get(\"https://www.baidu.com\") # 请求指定网址，URL必须包含协议\n```\n\n## 关闭浏览器\n\n```python\nbrowser.close()# 关闭浏览器\n```\n\n## 查找单个节点\n\n```python\nfrom selenium.webdriver.common.by import By # 使用find_element或find_elements需要使用\nbrowser.find_element(By.ID,\"kw\")# 统一查找方法，下面查找单个节点的方法实际上都是使用该方法实现的\nbrowser.find_element_by_id(\"kw\")# 根据元素ID查找单个节点\nbrowser.find_element_by_name(\"wd\")# 根据元素name查找单个节点\nbrowser.find_element_by_css_selector(\".s_ipt\")# 根据CSS选择器查找单个节点\nbrowser.find_element_by_xpath('//*[@id=\"kw\"]')# 根据Xpath查找单个节点\n\n## 还有很多方法\n```\n\n## 查找多个节点\n\n```python\nbrowser.find_elements(By.CLASS_NAME,\"c-color-gray2\")# 查找多个节点的统一实现\nbrowser.find_elements_by_class_name(\"c-color-gray2\")# 根据类名查找多个节点，返回列表\n\n## 还有很多方法\n```\n\n## 执行JavaScript脚本\n\n```python\nbrowser.execute_script('alert(\"执行JavaScript脚本\")')# 执行JS\n```\n\n## 切换Frame\n\n```python\nbrowser.switch_to.frame(\"iframe\")# 切换到指定iframe\nbrowser.switch_to.parent_frame # 切换回父frame\n```\n\n## 切换选项卡窗口\n\n\n\n## 后退和前进\n\n```python\nbrowser.back()# 后退\nbrowser.forward()# 前进\n```\n\n\n\n## cookies操作\n\n```python\nbrowser.get_cookies()# 获取全部Cookies\n\n# 添加cookie\nbrowser.add_cookie({\"name\":\"ABC\",# cookie名\n                    \"value\":\"123\"# cookie值\n                   })\n\nbrowser.get_cookie(\"ABC\")# 获取指定cookie\n```\n\n\n\n\n\n# 浏览器属性\n\n## 获取源代码\n\n```python\nbrowser.page_source # 打印网页源代码\n```\n\n# 节点方法\n\n```python\nin_text = browser.find_element_by_id(\"kw\")# 选中百度的输入框\n```\n\n## 输入值\n\n```python\nin_text.send_keys(\"selenium\")# 向元素中添加内容\n```\n\n## 清空值\n\n```python\nin_text.clear()# 清空元素内容\n```\n\n## 点击按钮\n\n```python\nbutton = browser.find_element_by_id(\"su\")# 获取百度中的按钮\nbutton.click()# 点击按钮\n```\n\n## 获取指定属性\n\n```python\nbutton.get_attribute(\"class\")# 获取节点的指定属性\n```\n\n\n\n# 节点属性\n\n## 获取节点内容\n\n```python\nnext_text = browser.find_element_by_class_name(\"hot-refresh-text\")\nnext_text.text# 获取内容\n```\n\n## 获取ID\n\n```python\nnext_text.id#获取ID\n```\n\n## 获取坐标\n\n```python\nnext_text.location# 获取坐标\n```\n\n## 获取标签类型\n\n```python\nnext_text.tag_name# 获取标签类型\n```\n\n## 获取大小\n\n```python\nnext_text.size# 获取大小\n```\n\n# 等待元素加载\n\n## 隐式等待\n\n- 隐式等待是直接先查找元素是否存在，如果存在则返回元素\n- 若元素不存在，则等待指定时间，再次查找元素，若还不存在则抛出异常\n\n```python\nbrowser.implicitly_wait(5)# 隐式等待时间\nbrowser.find_element_by_id(\"123\")# 查找，等待5秒再次查找，如果没找到则报错\n```\n\n## 显式等待\n\n- 设定一个等待时间\n- 若在指定时间内加载完成则直接返回对象\n- 若到达了指定时间还未加载完成则抛出异常\n- 相较于隐式等待，显式等待是更好的解决方法\n\n```python\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.common.by import By\n\nwait = WebDriverWait(browser,5)# 显式等待\nbrowser.find_element_by_id(\"123\")\nwait.until(EC.presence_of_element_located((By.ID,\"123\")))\n```\n\n# Selenium反爬与绕过\n\n> 反爬原理\n\nSelenium的反爬原理是检测window.navigator.webdriver\n\n正常浏览器访问时，该对象为undefined\n\n当使用selenium访问时，该对象会被设置为true\n\n网站会使用js来判断该对象的内容来决定是否对你进行屏蔽\n\n示例网站：https://antispider1.scrape.cuiqingcai.com/\n\n> 绕过\n\nChrome79 之前\n\n```python\nfrom selenium.webdriver import ChromeOptions\noption = ChromeOptions()\noption.add_experimental_option('excludeSwitches', ['enable-automation'])\nbrowser = webdriver.Chrome(options = option)\n```\n\nChrome79之后\n\n```python\nbrowser.execute_cdp_cmd(\"Page.addScriptToEvaluateOnNewDocument\", {\n  \"source\": \"\"\"\n    Object.defineProperty(navigator, 'webdriver', {\n      get: () => undefined\n    })\n  \"\"\"\n})\n```\n\n# 启动参数\n\n## 无头模式\n\n- 隐藏浏览器界面\n\n```python\nfrom selenium.webdriver import ChromeOptions\noption = ChromeOptions()\noption.add_argument(\"--headless\")\nbrowser = webdriver.Chrome(options=option)\n```\n\n",
    type: "Python",
    tag: [
        "Python模块"
    ],
    hit: NumberLong("3"),
    createDate: ISODate("2022-05-12T07:37:43.367Z"),
    modifyDate: ISODate("2022-05-12T07:37:43.367Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627cb98d06ea2876bc375af3"),
    title: "Python re正则表达式库",
    content: "<h1 class=\"markdown-h1\">正则表达式规则</h1>\n<p>| 语法 | 作用                                         | 示例      | 解释                                                         |\n| ---- | -------------------------------------------- | --------- | ------------------------------------------------------------ |\n| <code class=\"markdown-linecode\">^</code>  | 以特定字符开头                               | <code class=\"markdown-linecode\">^123</code>    | 匹配以123开头的字符串                                        |\n| <code class=\"markdown-linecode\">$</code>  | 以特定字符结尾                               | <code class=\"markdown-linecode\">456$</code>    | 匹配以456结尾的字符串                                        |\n| <code class=\"markdown-linecode\">.</code>  | 匹配一个任意字符，换行符除外                 | <code class=\"markdown-linecode\">1.3</code>     | 匹配1和3之间的任意一个字符                                   |\n| <code class=\"markdown-linecode\">*</code>  | 匹配前面的字符0次或多次                      | <code class=\"markdown-linecode\">1.*5</code>    | 匹配1和5之间有任意多个字符                                   |\n| <code class=\"markdown-linecode\">+</code>  | 匹配前面的字符1次或多次                      | <code class=\"markdown-linecode\">\\d+</code>     | 匹配至少1个数字                                              |\n| <code class=\"markdown-linecode\">\\w</code> | 匹配一个字母或下划线                         |           |                                                              |\n| <code class=\"markdown-linecode\">\\d</code> | 匹配一个数字                                 |           |                                                              |\n| <code class=\"markdown-linecode\">\\s</code> | 匹配一个空格                                 |           |                                                              |\n| <code class=\"markdown-linecode\">()</code> | 括号中间的表达式被称为子表达式，括号也称为组 | <code class=\"markdown-linecode\">a(.*?)b</code> | 提取a和b之间所有的内容                                       |\n| <code class=\"markdown-linecode\">\\</code>  | 转义匹配，当需要匹配特殊字符时会使用         | <code class=\"markdown-linecode\">\\\\</code>      | 匹配\\                                                        |\n|      |                                              |           |                                                              |\n|      |                                              |           |                                                              |\n| .*   | 贪婪匹配                                     |           | 匹配尽可能多的字符                                           |\n| .*？ | 非贪婪匹配                                   |           | 匹配尽可能少的字符<br />在字符串结尾时可能为空，这时使用贪婪匹配 |</p>\n<h1 class=\"markdown-h1\">re库方法</h1>\n<h2 class=\"markdown-h2\">compile()</h2>\n<ul class=\"markdown-list\">\n<li>\n<p>作用</p>\n<ul class=\"markdown-list\">\n<li>创建一个正则表达式对象</li>\n<li>在正则表达式需要复用时，利用该函数可以减少代码</li>\n</ul>\n</li>\n<li>\n<p>参数</p>\n<ul class=\"markdown-list\">\n<li>| 参数            | 作用           |\n| --------------- | -------------- |\n| pattern         | 正则表达式     |\n| <a href=\"#flags\" target=\"_blank\">flags</a> | 匹配模式标志位 |</li>\n</ul>\n</li>\n<li>\n<p>返回值</p>\n<ul class=\"markdown-list\">\n<li>返回正则表达式对象</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">match()</h2>\n<ul class=\"markdown-list\">\n<li>\n<p>作用</p>\n<ul class=\"markdown-list\">\n<li>从开头检查字符串是否匹配正则表达式</li>\n<li>返回所有匹配字符</li>\n</ul>\n</li>\n<li>\n<p>参数</p>\n<ul class=\"markdown-list\">\n<li>| 参数            | 作用           |\n| --------------- | -------------- |\n| pattern         | 正则表达式     |\n| string          | 待匹配字符串   |\n| <a href=\"#flags\" target=\"_blank\">flags</a> | 匹配模式标志位 |</li>\n</ul>\n</li>\n<li>\n<p>返回值</p>\n<ul class=\"markdown-list\">\n<li>成功：返回匹配结果对象</li>\n<li>失败：返回None</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">search()</h2>\n<ul class=\"markdown-list\">\n<li>\n<p>作用</p>\n<ul class=\"markdown-list\">\n<li>扫描整个字符串，返回第一个匹配的结果</li>\n</ul>\n</li>\n<li>\n<p>参数</p>\n<ul class=\"markdown-list\">\n<li>| 参数            | 作用           |\n| --------------- | -------------- |\n| pattern         | 正则表达式     |\n| string          | 待匹配字符串   |\n| <a href=\"#flags\" target=\"_blank\">flags</a> | 匹配模式标志位 |</li>\n</ul>\n</li>\n<li>\n<p>返回值</p>\n<ul class=\"markdown-list\">\n<li>成功：返回匹配结果对象</li>\n<li>失败：返回None</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">findall()</h2>\n<ul class=\"markdown-list\">\n<li>\n<p>作用</p>\n<ul class=\"markdown-list\">\n<li>扫描整个字符串，返回所有匹配的子表达式的结果</li>\n</ul>\n</li>\n<li>\n<p>参数</p>\n<ul class=\"markdown-list\">\n<li>| 参数            | 作用           |\n| --------------- | -------------- |\n| pattern         | 正则表达式     |\n| string          | 待匹配字符串   |\n| <a href=\"#flags\" target=\"_blank\">flags</a> | 匹配模式标志位 |</li>\n</ul>\n</li>\n<li>\n<p>返回值</p>\n<ul class=\"markdown-list\">\n<li>匹配结果的列表</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">sub()</h2>\n<ul class=\"markdown-list\">\n<li>\n<p>作用</p>\n<ul class=\"markdown-list\">\n<li>文本替换</li>\n</ul>\n</li>\n<li>\n<p>参数</p>\n<ul class=\"markdown-list\">\n<li>| 参数            | 作用                          |\n| --------------- | ----------------------------- |\n| pattern         | 正则表达式                    |\n| repl            | 要替换的文本                  |\n| string          | 待匹配字符串                  |\n| count           | 要替换的参数，默认0，全部替换 |\n| <a href=\"#flags\" target=\"_blank\">flags</a> | 匹配模式标志位                |</li>\n</ul>\n</li>\n<li>\n<p>返回值</p>\n<ul class=\"markdown-list\">\n<li>替换完成后的字符串</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">匹配结果对象</h2>\n<p>| 方法     | 作用                                                      |\n| -------- | --------------------------------------------------------- |\n| span()   | 返回匹配文本的下表区间                                    |\n| gruop(x) | x留空时：返回整个匹配的字符串<br />x：返回第x组的匹配结果 |</p>\n<h2 class=\"markdown-h2\">flags<a name=flags></a></h2>\n<p>| 标志 | 作用                                         |\n| ---- | -------------------------------------------- |\n| re.S | 让<code class=\"markdown-linecode\">.</code>可以匹配换行符                          |\n| re.I | 使匹配大小写不敏感                           |\n| re.L | 本地化识别匹配                               |\n| re.M | 多行匹配                                     |\n| re.U | 根据Unicode字符集解析字符,影响\\w、\\W、\\b、\\B |</p>\n",
    markdown: "# 正则表达式规则\n\n| 语法 | 作用                                         | 示例      | 解释                                                         |\n| ---- | -------------------------------------------- | --------- | ------------------------------------------------------------ |\n| `^`  | 以特定字符开头                               | `^123`    | 匹配以123开头的字符串                                        |\n| `$`  | 以特定字符结尾                               | `456$`    | 匹配以456结尾的字符串                                        |\n| `.`  | 匹配一个任意字符，换行符除外                 | `1.3`     | 匹配1和3之间的任意一个字符                                   |\n| `*`  | 匹配前面的字符0次或多次                      | `1.*5`    | 匹配1和5之间有任意多个字符                                   |\n| `+`  | 匹配前面的字符1次或多次                      | `\\d+`     | 匹配至少1个数字                                              |\n| `\\w` | 匹配一个字母或下划线                         |           |                                                              |\n| `\\d` | 匹配一个数字                                 |           |                                                              |\n| `\\s` | 匹配一个空格                                 |           |                                                              |\n| `()` | 括号中间的表达式被称为子表达式，括号也称为组 | `a(.*?)b` | 提取a和b之间所有的内容                                       |\n| `\\`  | 转义匹配，当需要匹配特殊字符时会使用         | `\\\\`      | 匹配\\                                                        |\n|      |                                              |           |                                                              |\n|      |                                              |           |                                                              |\n| .*   | 贪婪匹配                                     |           | 匹配尽可能多的字符                                           |\n| .*？ | 非贪婪匹配                                   |           | 匹配尽可能少的字符<br />在字符串结尾时可能为空，这时使用贪婪匹配 |\n\n\n\n\n\n# re库方法\n\n## compile()\n\n- 作用\n\n  - 创建一个正则表达式对象\n  - 在正则表达式需要复用时，利用该函数可以减少代码\n\n- 参数\n\n  - | 参数            | 作用           |\n    | --------------- | -------------- |\n    | pattern         | 正则表达式     |\n    | [flags](#flags) | 匹配模式标志位 |\n\n- 返回值\n\n  - 返回正则表达式对象\n\n## match()\n\n- 作用\n\n  - 从开头检查字符串是否匹配正则表达式\n  - 返回所有匹配字符\n\n- 参数\n\n  - | 参数            | 作用           |\n    | --------------- | -------------- |\n    | pattern         | 正则表达式     |\n    | string          | 待匹配字符串   |\n    | [flags](#flags) | 匹配模式标志位 |\n\n- 返回值\n\n  - 成功：返回匹配结果对象\n  - 失败：返回None\n\n## search()\n\n- 作用\n\n  - 扫描整个字符串，返回第一个匹配的结果\n\n- 参数\n\n  - | 参数            | 作用           |\n    | --------------- | -------------- |\n    | pattern         | 正则表达式     |\n    | string          | 待匹配字符串   |\n    | [flags](#flags) | 匹配模式标志位 |\n\n- 返回值\n\n  - 成功：返回匹配结果对象\n  - 失败：返回None\n\n## findall()\n\n- 作用\n\n  - 扫描整个字符串，返回所有匹配的子表达式的结果\n\n- 参数\n\n  - | 参数            | 作用           |\n    | --------------- | -------------- |\n    | pattern         | 正则表达式     |\n    | string          | 待匹配字符串   |\n    | [flags](#flags) | 匹配模式标志位 |\n\n- 返回值\n\n  - 匹配结果的列表\n\n## sub()\n\n- 作用\n\n  - 文本替换\n\n- 参数\n\n  - | 参数            | 作用                          |\n    | --------------- | ----------------------------- |\n    | pattern         | 正则表达式                    |\n    | repl            | 要替换的文本                  |\n    | string          | 待匹配字符串                  |\n    | count           | 要替换的参数，默认0，全部替换 |\n    | [flags](#flags) | 匹配模式标志位                |\n\n- 返回值\n\n  - 替换完成后的字符串\n\n\n\n## 匹配结果对象\n\n| 方法     | 作用                                                      |\n| -------- | --------------------------------------------------------- |\n| span()   | 返回匹配文本的下表区间                                    |\n| gruop(x) | x留空时：返回整个匹配的字符串<br />x：返回第x组的匹配结果 |\n\n## flags<a name=flags></a>\n\n| 标志 | 作用                                         |\n| ---- | -------------------------------------------- |\n| re.S | 让`.`可以匹配换行符                          |\n| re.I | 使匹配大小写不敏感                           |\n| re.L | 本地化识别匹配                               |\n| re.M | 多行匹配                                     |\n| re.U | 根据Unicode字符集解析字符,影响\\w、\\W、\\b、\\B |\n\n  ",
    type: "Python",
    tag: [
        "Python模块"
    ],
    hit: NumberLong("1"),
    createDate: ISODate("2022-05-12T07:38:53.515Z"),
    modifyDate: ISODate("2022-05-12T07:38:53.515Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627dc78d556eb954b06fa660"),
    title: "NodeJs 简单使用",
    content: "<h1 class=\"markdown-h1\">Nodejs</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>Nodejs 是使用js作为开发语言的，配合Chrome V8引擎实现的后端框架</p>\n</blockquote>\n<h1 class=\"markdown-h1\">安装</h1>\n<ol class=\"markdown-list\">\n<li>\n<p>下载：https://nodejs.org/zh-cn/</p>\n<ul class=\"markdown-list\">\n<li>NPM是Node.js的内置包管理工具，所以安装Node.js才能使用NPM</li>\n</ul>\n</li>\n<li>\n<p>打开安装包-&gt;选择安装位置-&gt;一路下一步即可</p>\n</li>\n<li>\n<p>命令行中输入<code class=\"markdown-linecode\">node -v</code>，如果出现版本号说明安装成功</p>\n</li>\n</ol>\n<h1 class=\"markdown-h1\">运行</h1>\n<p>创建一个JS文件，内容如下</p>\n<pre><code class=\"language-js\">console.log(&quot;Hello World！&quot;);\n</code></pre>\n<p>在命令行中输入如下指令</p>\n<pre><code class=\"language-sh\">node index.js\n</code></pre>\n<p>在控制台中输出了<code class=\"markdown-linecode\">Hello World！</code>字样</p>\n<h1 class=\"markdown-h1\">创建一个Web服务器</h1>\n<pre><code class=\"language-js\">const http = require('http') // 导入http模块\n\nconst hostname = '127.0.0.1' // 指定主机地址\nconst port = 3000  // 指定端口号\n\n// 创建服务器\nconst server = http.createServer((req, res) =&gt; {\n  res.statusCode = 200 // 指定响应状态码\n  res.setHeader('Content-Type', 'text/plain') // 设置响应头\n  res.end('Hello World\\n') // 设置响应体\n})\n\n// 监听端口\nserver.listen(port, hostname, () =&gt; {\n  // 打印日志\n  console.log(`Server running at http://${hostname}:${port}/`)\n})\n</code></pre>\n<h1 class=\"markdown-h1\">连接数据库</h1>\n<p>使用之前需要先安装mysql连接包</p>\n<pre><code class=\"language-sh\">npm i mysql\n</code></pre>\n<pre><code class=\"language-js\">const mysql = require(&quot;mysql&quot;); // 导入包\n\n// 配置数据库连接信息\nvar conn = mysql.createConnection({\n    host: &quot;127.0.0.1&quot;,\n    port: 3306,\n    user: &quot;root&quot;,\n    password: &quot;password&quot;,\n    database: &quot;temp&quot;\n});\n// 连接数据库\nconn.connect();\n// 查询数据\nconn.query(&quot;select * from student&quot;, function(err, ret, fie) {\n    // 如果出错抛出异常\n    if (err) throw err;\n    else {\n        // 打印所有结果数据\n        console.log(ret);\n    }\n});\n// 关闭连接\nconn.end();\n</code></pre>\n",
    markdown: "# Nodejs\n\n> Nodejs 是使用js作为开发语言的，配合Chrome V8引擎实现的后端框架\n\n# 安装\n\n1. 下载：https://nodejs.org/zh-cn/\n   - NPM是Node.js的内置包管理工具，所以安装Node.js才能使用NPM\n2. 打开安装包->选择安装位置->一路下一步即可\n\n3. 命令行中输入`node -v`，如果出现版本号说明安装成功\n\n# 运行\n\n创建一个JS文件，内容如下\n\n```js\nconsole.log(\"Hello World！\");\n```\n\n在命令行中输入如下指令\n\n```sh\nnode index.js\n```\n\n在控制台中输出了`Hello World！`字样\n\n\n\n# 创建一个Web服务器\n\n```js\nconst http = require('http') // 导入http模块\n\nconst hostname = '127.0.0.1' // 指定主机地址\nconst port = 3000  // 指定端口号\n\n// 创建服务器\nconst server = http.createServer((req, res) => {\n  res.statusCode = 200 // 指定响应状态码\n  res.setHeader('Content-Type', 'text/plain') // 设置响应头\n  res.end('Hello World\\n') // 设置响应体\n})\n\n// 监听端口\nserver.listen(port, hostname, () => {\n  // 打印日志\n  console.log(`Server running at http://${hostname}:${port}/`)\n})\n```\n\n\n\n# 连接数据库\n\n使用之前需要先安装mysql连接包\n\n```sh\nnpm i mysql\n```\n\n```js\nconst mysql = require(\"mysql\"); // 导入包\n\n// 配置数据库连接信息\nvar conn = mysql.createConnection({\n    host: \"127.0.0.1\",\n    port: 3306,\n    user: \"root\",\n    password: \"password\",\n    database: \"temp\"\n});\n// 连接数据库\nconn.connect();\n// 查询数据\nconn.query(\"select * from student\", function(err, ret, fie) {\n    // 如果出错抛出异常\n    if (err) throw err;\n    else {\n        // 打印所有结果数据\n        console.log(ret);\n    }\n});\n// 关闭连接\nconn.end();\n```\n\n",
    type: "JavaScript",
    tag: [
        "NodeJs"
    ],
    hit: NumberLong("1"),
    createDate: ISODate("2022-05-13T02:50:53.272Z"),
    modifyDate: ISODate("2022-05-13T02:50:53.272Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627dca7b556eb954b06fa664"),
    title: "测试",
    content: "<h1 class=\"markdown-h1\">算术运算符</h1>\n<h2 class=\"markdown-h2\">+</h2>\n<ul class=\"markdown-list\">\n<li>数学加法\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">1+1</code> 结果为2</li>\n</ul>\n</li>\n<li>字符串拼接\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">&quot;1&quot;+1</code>结果为11</li>\n<li>当运算中有char类型时，<code class=\"markdown-linecode\">'1'+1</code> ，计算方式为'1’的ASCII码49和1相加，结果为50</li>\n<li>当前面为数值运算，中间出现字符串类型数据时，从第一个字符串数据开始变为字符串拼接，之前的数值运算还是按照加法计算,<code class=\"markdown-linecode\">3+5+&quot;1&quot;+5+3</code>,结果为8153</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">-</h2>\n<ul class=\"markdown-list\">\n<li>数学减法\n<ul class=\"markdown-list\">\n<li><code class=\"markdown-linecode\">2-1</code> 结果为1</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"markdown-h2\">*</h2>\n<p>乘法需要注意的是数据越界问题，在Java中数据越界不会出现编译错误，也不会出现运行时错误，需要格外警惕</p>\n<blockquote class=\"markdown-blockquote\">\n<p>计算一年中有多少秒？</p>\n<p><code class=\"markdown-linecode\">System.out.println(365*24*60*60*1000);</code> &gt;&gt; <code class=\"markdown-linecode\">1471228928</code></p>\n<p>我们使用计算器计算，得到的结果是<code class=\"markdown-linecode\">31,536,000,000</code></p>\n<p>显然我们程序的计算的结果是不正确的，print默认是使用int类型的</p>\n<p>我们的计算数据已经超过了int的最大值，所以需要转换为更大的long类型</p>\n<p><code class=\"markdown-linecode\">System.out.println(365L*24*60*60*1000);</code> &gt;&gt; <code class=\"markdown-linecode\">31536000000</code></p>\n</blockquote>\n",
    markdown: "# 算术运算符\n\n## +\n\n- 数学加法\n  - `1+1` 结果为2\n- 字符串拼接\n  - `\"1\"+1`结果为11\n  - 当运算中有char类型时，`'1'+1` ，计算方式为'1’的ASCII码49和1相加，结果为50\n  - 当前面为数值运算，中间出现字符串类型数据时，从第一个字符串数据开始变为字符串拼接，之前的数值运算还是按照加法计算,`3+5+\"1\"+5+3`,结果为8153\n\n## - \n\n- 数学减法\n  - `2-1` 结果为1\n\n## *\n\n乘法需要注意的是数据越界问题，在Java中数据越界不会出现编译错误，也不会出现运行时错误，需要格外警惕\n\n> 计算一年中有多少秒？\n>\n> `System.out.println(365*24*60*60*1000);` >> `1471228928`\n>\n> 我们使用计算器计算，得到的结果是`31,536,000,000`\n>\n> 显然我们程序的计算的结果是不正确的，print默认是使用int类型的\n>\n> 我们的计算数据已经超过了int的最大值，所以需要转换为更大的long类型\n>\n> `System.out.println(365L*24*60*60*1000);` >> `31536000000`\n\n",
    type: "测试",
    tag: [
        "测试"
    ],
    hit: NumberInt("0"),
    createDate: ISODate("2022-05-13T03:03:23.007Z"),
    modifyDate: ISODate("2022-05-13T03:03:23.007Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627dcb45556eb954b06fa666"),
    title: "Axios 二次封装",
    content: "<h1 class=\"markdown-h1\">二次封装</h1>\n<ul class=\"markdown-list\">\n<li><a href=\"http://www.axios-js.com/zh-cn/docs/#%E6%8B%A6%E6%88%AA%E5%99%A8\" target=\"_blank\">拦截器</a></li>\n<li></li>\n</ul>\n<pre><code class=\"language-js\">import axios from 'axios';\n\n\n// 创建实例对象\nconst request = axios.create({\n  baseURL: 'http://localhost/',     // 基本地址\n  timeout: 5000,                    // 超时时间\n});\n\n\n// 设置请求拦截\nrequest.interceptors.request.use(function (config) {\n  // 配置修改\n  return config;\n}, function (error) {\n  // 对请求错误做些什么\n  return Promise.reject(error);\n});\n\n\n// 设置响应拦截\nrequest.interceptors.response.use(function (response) {\n    // 对响应做点什么\n    return response;\n}, function (error) {\n  // 对响应错误做点什么\n  return Promise.reject(error);\n});\nexport default request;\n</code></pre>\n",
    markdown: "# 二次封装\n\n- [拦截器](http://www.axios-js.com/zh-cn/docs/#%E6%8B%A6%E6%88%AA%E5%99%A8)\n- \n\n```js\nimport axios from 'axios';\n\n\n// 创建实例对象\nconst request = axios.create({\n  baseURL: 'http://localhost/',     // 基本地址\n  timeout: 5000,                    // 超时时间\n});\n\n\n// 设置请求拦截\nrequest.interceptors.request.use(function (config) {\n  // 配置修改\n  return config;\n}, function (error) {\n  // 对请求错误做些什么\n  return Promise.reject(error);\n});\n\n\n// 设置响应拦截\nrequest.interceptors.response.use(function (response) {\n    // 对响应做点什么\n    return response;\n}, function (error) {\n  // 对响应错误做点什么\n  return Promise.reject(error);\n});\nexport default request;\n```\n\n",
    type: "JavaScript",
    tag: [
        "Ajax"
    ],
    hit: NumberInt("0"),
    createDate: ISODate("2022-05-13T03:06:45.15Z"),
    modifyDate: ISODate("2022-05-13T03:06:45.15Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627dcd5b556eb954b06fa66b"),
    title: "Vue 整合 ElementUI",
    content: "<h1 class=\"markdown-h1\">按需引入</h1>\n<pre><code class=\"language-sh\">npm install -D unplugin-vue-components unplugin-auto-import\n</code></pre>\n<h2 class=\"markdown-h2\">Vue CLI</h2>\n<pre><code class=\"language-js\">const AutoImport = require('unplugin-auto-import/webpack')\nconst Components = require('unplugin-vue-components/webpack')\nconst { ElementPlusResolver } = require('unplugin-vue-components/resolvers')\n\nmodule.exports = defineConfig({\n  configureWebpack: {\n    plugins: [\n      AutoImport({\n        resolvers: [ElementPlusResolver()],\n      }),\n      Components({\n        resolvers: [ElementPlusResolver()],\n      }),\n    ],\n  },\n})\n\n</code></pre>\n",
    markdown: "# 按需引入\n\n```sh\nnpm install -D unplugin-vue-components unplugin-auto-import\n```\n\n## Vue CLI\n\n```js\nconst AutoImport = require('unplugin-auto-import/webpack')\nconst Components = require('unplugin-vue-components/webpack')\nconst { ElementPlusResolver } = require('unplugin-vue-components/resolvers')\n\nmodule.exports = defineConfig({\n  configureWebpack: {\n    plugins: [\n      AutoImport({\n        resolvers: [ElementPlusResolver()],\n      }),\n      Components({\n        resolvers: [ElementPlusResolver()],\n      }),\n    ],\n  },\n})\n\n```\n\n\n\n",
    type: "JavaScript",
    tag: [
        "VUE"
    ],
    hit: NumberInt("0"),
    createDate: ISODate("2022-05-13T03:15:39.282Z"),
    modifyDate: ISODate("2022-05-13T03:15:39.282Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);
db.getCollection("blog").insert([ {
    _id: ObjectId("627dce33556eb954b06fa66c"),
    title: "Java String类",
    content: "<h1 class=\"markdown-h1\">String类</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>在Java中没有内置的字符串类型，但是在Java类库中提供了一个预定义的类叫做<code class=\"markdown-linecode\">String</code></p>\n<p><code class=\"markdown-linecode\">String</code>类位于<code class=\"markdown-linecode\">java.lang.String</code>,因此无需手动带入</p>\n</blockquote>\n<pre><code class=\"language-java\">String s1 = &quot;&quot;;\nString s2 = &quot;123&quot;;\n</code></pre>\n<h1 class=\"markdown-h1\">子串</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>参数一：开始的下标位置</p>\n<p>参数二：不想要的开始下标位置</p>\n<p>长度计算：参数二 - 参数一</p>\n</blockquote>\n<pre><code class=\"language-java\">String s1 = &quot;Hello World&quot;;\nString s2 = s1.substring(0, 5);\nSystem.out.println(s2);\n&gt;&gt;&gt;\n    Hello\n</code></pre>\n<h1 class=\"markdown-h1\">拼接</h1>\n<h2 class=\"markdown-h2\">+</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>绝大多数语言都支持<code class=\"markdown-linecode\">+</code>来拼接字符串，Java也不例外</p>\n</blockquote>\n<pre><code class=\"language-java\">String s1 = &quot;Hello &quot;;\nString s2 = &quot;World&quot;;\nString s3 = s1 + s2 + &quot;!&quot;;\nSystem.out.println(s3);\n&gt;&gt;&gt;\n    Hello World!\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>当被拼接的数据中包含非字符串类型时，他将被转换为字符串类型，在Java中任何数据类型都能转换为字符串</p>\n</blockquote>\n<pre><code class=\"language-java\">String s1 = &quot;Hello &quot;;\nString s2 = &quot;World&quot;;\nString s3 = s1 + s2 + &quot;!&quot; + 123;\nSystem.out.println(s3);\n&gt;&gt;&gt;\n    Hello World!123\n</code></pre>\n<h2 class=\"markdown-h2\">join</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>join会使用参数一给定的分隔符，将后面的所有元素都拼接在一起</p>\n<p>参数一：分隔符(可以为空字符串)</p>\n<p>参数二：可变长参数，需要拼接的字符串</p>\n</blockquote>\n<pre><code class=\"language-java\">String s1 = &quot;Hello&quot;;\nString s2 = &quot;World&quot;;\nString s3 = String.join(&quot;,&quot;, s1, s2, &quot;!&quot;, &quot;123&quot;);\nSystem.out.println(s3);\n&gt;&gt;&gt; \n    Hello,World,!,123\n</code></pre>\n<h1 class=\"markdown-h1\">不可变类型</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>String类没有提供用于修改字符串的方法，如果希望将greeting的内容从“Hello”修改为“Help!”，不能直接地将greeting的最后两个位置的字符修改为‘p’和‘！,而是需要使用下面的方式来修改</p>\n<p><code class=\"markdown-linecode\">greeting=greeting.substring(0,3)+&quot;p!&quot;</code></p>\n<p>由于不能修改Java字符串中的字符，所以在Java文档中将String类对象称为不可变字符串，如同数字3永远是数字3一样，字符串“Hello”永远包含字符H、e、l、l和o的代码单元序列，而不能修改其中的任何一个字符。当然，可以修改字符串变量greeting，让它引用另外一个字符串，这就如同可以将存放3的数值变量改成存放4一样。</p>\n<p>这样做是否会降低运行效率呢？看起来好像修改一个代码单元要比创建一个新字符串更加简洁。答案是：也对，也不对。的确，通过拼接“Hel”和“p!”来创建一个新字符串的效率确实不高。但是，不可变字符串却有一个优点：编译器可以让字符串共享。</p>\n<p>Java的设计者认为共享带来的高效率远远胜过于提取、拼接字符串所带来的低效率。查看一下程序会发现：很少需要修改字符串，而是往往需要对字符串进行比较</p>\n<p>--- 《Java 核心技术 卷Ⅰ 原书第十版》</p>\n</blockquote>\n<h1 class=\"markdown-h1\">判断是否相等</h1>\n<h2 class=\"markdown-h2\">==</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>在Java中字符串的<code class=\"markdown-linecode\">==</code>操作并未被重载，所以<code class=\"markdown-linecode\">==</code>操作只能用来判断两个对象的内存地址是否相同。</p>\n<p>因为字符串是不可变类型的，大多数情况下，两个字符串相等内存地址也相等，但是一定情况下还出现不相等的情况(例如substring)，这种情况出现BUG很难排查，所以<strong>一定不要使用<code class=\"markdown-linecode\">==</code>来判断两个字符串是否相等</strong>，而是选择使用String类的<code class=\"markdown-linecode\">equals</code>方法来判断</p>\n</blockquote>\n<pre><code class=\"language-java\">String s1 = &quot;abc&quot;;\nString s2 = &quot;abc&quot;;\nSystem.out.println(s1.equals(s2));\n</code></pre>\n<ul class=\"markdown-list\">\n<li>不要使用<code class=\"markdown-linecode\">==</code>来判断字符串是否相等</li>\n</ul>\n<pre><code class=\"language-java\">String s1 = &quot;abc&quot;;\nString s2 = &quot;abc&quot;;\nSystem.out.println(s1 == s2);\nSystem.out.println(s1.substring(1));\nSystem.out.println(s1.substring(1) == &quot;bc&quot;);\n&gt;&gt;&gt;\n    true\n    bc\n    false\n</code></pre>\n<h2 class=\"markdown-h2\">equals</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>equals是String类的方法，专门用于判断两个字符串是否相等</p>\n</blockquote>\n<pre><code class=\"language-java\">String s1 = &quot;abc&quot;;\nString s2 = &quot;abc&quot;;\nSystem.out.println(s1.equals(s2));\nSystem.out.println(&quot;abd&quot;.equals(s2));\n</code></pre>\n<h2 class=\"markdown-h2\">compareTo</h2>\n<blockquote class=\"markdown-blockquote\">\n<p>compareTo用于比较两个字符串的大小，相等返回0，s1大返回正数，s2大返回复数</p>\n</blockquote>\n<pre><code class=\"language-java\">String s1 = &quot;abc&quot;;\nString s2 = &quot;abc&quot;;\nSystem.out.println(s1.compareTo(s2) == 0);\n</code></pre>\n<h1 class=\"markdown-h1\">空串与null串</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>空串：<code class=\"markdown-linecode\">String s = &quot;&quot;;</code></p>\n<p>空串的长度为0，可以利用这点来判断是否为空串</p>\n<p>null串：<code class=\"markdown-linecode\">String s = null;</code></p>\n<p>null串需要特别注意，在判断字符串内容是否与指定内容相等时最好先确保字符串不是null串，否则会出现空指针异常(java.lang.NullPointException)</p>\n</blockquote>\n<pre><code class=\"language-java\">// 普通避免字符串空指针异常的方法\nif(s != null){\n    s.equals(&quot;123&quot;);\n}\n// 更简便的方法\n&quot;123&quot;.equals(s);\n\n\n// 既不是空串也不是null串\nif(str != null &amp;&amp; str.length() != 0)\n</code></pre>\n<h1 class=\"markdown-h1\">码点与代码单元</h1>\n<p>下面的代码的执行结果是很奇怪的</p>\n<pre><code class=\"language-java\">String s1 = &quot;𝕆abc&quot;;\nSystem.out.println(s1.charAt(1));\n&gt;&gt;&gt;\n    晢\n</code></pre>\n<p>根据猜想，返回结果应该是下标为1的字符<code class=\"markdown-linecode\">a</code>，可是实际返回的确实奇怪的<code class=\"markdown-linecode\">晢</code></p>\n<p>原因在于：使用UTF-16编码表示字符𝕆(U+1D546)需要两个代码单元。</p>\n<p>这个字符的第二个代码单元显示的字符就是<code class=\"markdown-linecode\">晢</code>,因此<code class=\"markdown-linecode\">charAt(1)</code>获取到的就是他</p>\n<p>正确的取出码点的方法如下：</p>\n<pre><code class=\"language-java\">String s1 = &quot;𝕆abc&quot;;\nint i = 0;\n// 简单方法\nSystem.out.println(Arrays.toString(s1.codePoints().toArray()));\n// 完整方法\nwhile (i &lt; s1.codePointCount(0, s1.length())) {\n    int cp = s1.codePointAt(i);\n    if (Character.isSupplementaryCodePoint(cp))\n        i += 2;\n    else\n        i++;\n    System.out.println(cp);\n}\n</code></pre>\n<blockquote class=\"markdown-blockquote\">\n<p>因为charAt()过于底层，不建议使用它</p>\n</blockquote>\n<h1 class=\"markdown-h1\">常用方法</h1>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">boolean equals(Object other)</code></p>\n<p>如果字符串与other相等，返回true。</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">boolean equalsIgnoreCase(String other)</code></p>\n<p>如果字符串与other相等（忽略大小写)，返回true。</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">int length()</code></p>\n<p>返回字符串的长度。</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">String substring(int beginlndex)</code></p>\n<p><code class=\"markdown-linecode\">String substring(int beginlndex,int endlndex)</code></p>\n<p>返回一个新字符串。这个字符串包含原始字符串中从beginlndex到串尾或endlndex-1的所有代码单元。</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">String trim()</code></p>\n<p>返回一个新字符串。这个字符串将删除了原始字符串头部和尾部的空格。</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">String join(CharSequence delimiter,CharSequence ...elements)</code></p>\n<p>返回一个新字符串，用给定的定界符连接所有元素。</p>\n<p>Java 8 新增</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">String toLowerCase()</code></p>\n<p><code class=\"markdown-linecode\">String toUpperCase()</code></p>\n<p>返回一个新字符串。这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">int indexOf(String str)</code></p>\n<p><code class=\"markdown-linecode\">int indexOf(String str,int fromlndex)</code></p>\n<p><code class=\"markdown-linecode\">int indexOf(int cp)</code></p>\n<p><code class=\"markdown-linecode\">int indexOf(int cp,int fromlndex)</code></p>\n<p>返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromlndex开始计算。如果在原始串中不存在str，返回-1。</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">int lastIndexOf(String str)</code></p>\n<p><code class=\"markdown-linecode\">int lastIndexOf(String str,int fromlndex)</code></p>\n<p><code class=\"markdown-linecode\">int lastindexOf(int cp)</code></p>\n<p><code class=\"markdown-linecode\">int lastindexOf(int cp,int fromlndex)</code></p>\n<p>返回与字符串str或代码点cp匹配的最后一个子串的开始位置。这个位置从原始串尾端或fromlndex开始计算。</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">int compareTo(String other)</code></p>\n<p>按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0。</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">boolean startsWith(String prefix)</code></p>\n<p><code class=\"markdown-linecode\">boolean endsWith(String suffix)</code></p>\n<p>如果字符串以suffix开头或结尾，则返回true。.</p>\n</blockquote>\n<hr />\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">String replace(CharSequence oldString,CharSequence newString)</code></p>\n<p>返回一个新字符串。这个字符串用newString代替原始字符串中所有的oldString。可以用String或StringBuilder对象作为CharSequence参数。</p>\n</blockquote>\n<blockquote class=\"markdown-blockquote\">\n<p><code class=\"markdown-linecode\">String replaceAll(String regex, String replacement)</code></p>\n<p>返回一个新字符串。用给定的正则表达式regex去寻找字符串中满足条件的子串，并且替换成replacement</p>\n</blockquote>\n<h1 class=\"markdown-h1\">CharSequence</h1>\n<blockquote class=\"markdown-blockquote\">\n<p>CharSequence是一个描述字符串结构的接口</p>\n<p>String、StringBuffer、StringBuilder都是他的实现类</p>\n</blockquote>\n",
    markdown: "# String类\n\n> 在Java中没有内置的字符串类型，但是在Java类库中提供了一个预定义的类叫做`String`\n>\n> `String`类位于`java.lang.String`,因此无需手动带入\n\n```java\nString s1 = \"\";\nString s2 = \"123\";\n```\n\n# 子串\n\n> 参数一：开始的下标位置\n>\n> 参数二：不想要的开始下标位置\n>\n> 长度计算：参数二 - 参数一\n\n```java\nString s1 = \"Hello World\";\nString s2 = s1.substring(0, 5);\nSystem.out.println(s2);\n>>>\n    Hello\n```\n\n# 拼接\n\n## +\n\n> 绝大多数语言都支持`+`来拼接字符串，Java也不例外\n\n```java\nString s1 = \"Hello \";\nString s2 = \"World\";\nString s3 = s1 + s2 + \"!\";\nSystem.out.println(s3);\n>>>\n    Hello World!\n```\n\n> 当被拼接的数据中包含非字符串类型时，他将被转换为字符串类型，在Java中任何数据类型都能转换为字符串\n\n```java\nString s1 = \"Hello \";\nString s2 = \"World\";\nString s3 = s1 + s2 + \"!\" + 123;\nSystem.out.println(s3);\n>>>\n    Hello World!123\n```\n\n## join\n\n> join会使用参数一给定的分隔符，将后面的所有元素都拼接在一起\n>\n> 参数一：分隔符(可以为空字符串)\n>\n> 参数二：可变长参数，需要拼接的字符串\n\n```java\nString s1 = \"Hello\";\nString s2 = \"World\";\nString s3 = String.join(\",\", s1, s2, \"!\", \"123\");\nSystem.out.println(s3);\n>>> \n    Hello,World,!,123\n```\n\n# 不可变类型\n\n> String类没有提供用于修改字符串的方法，如果希望将greeting的内容从“Hello”修改为“Help!”，不能直接地将greeting的最后两个位置的字符修改为‘p’和‘！,而是需要使用下面的方式来修改\n>\n> `greeting=greeting.substring(0,3)+\"p!\"`\n>\n> 由于不能修改Java字符串中的字符，所以在Java文档中将String类对象称为不可变字符串，如同数字3永远是数字3一样，字符串“Hello”永远包含字符H、e、l、l和o的代码单元序列，而不能修改其中的任何一个字符。当然，可以修改字符串变量greeting，让它引用另外一个字符串，这就如同可以将存放3的数值变量改成存放4一样。\n>\n> 这样做是否会降低运行效率呢？看起来好像修改一个代码单元要比创建一个新字符串更加简洁。答案是：也对，也不对。的确，通过拼接“Hel”和“p!”来创建一个新字符串的效率确实不高。但是，不可变字符串却有一个优点：编译器可以让字符串共享。\n>\n> Java的设计者认为共享带来的高效率远远胜过于提取、拼接字符串所带来的低效率。查看一下程序会发现：很少需要修改字符串，而是往往需要对字符串进行比较\n>\n> --- 《Java 核心技术 卷Ⅰ 原书第十版》\n\n# 判断是否相等\n\n## ==\n\n> 在Java中字符串的`==`操作并未被重载，所以`==`操作只能用来判断两个对象的内存地址是否相同。\n>\n> 因为字符串是不可变类型的，大多数情况下，两个字符串相等内存地址也相等，但是一定情况下还出现不相等的情况(例如substring)，这种情况出现BUG很难排查，所以**一定不要使用`==`来判断两个字符串是否相等**，而是选择使用String类的`equals`方法来判断\n\n```java\nString s1 = \"abc\";\nString s2 = \"abc\";\nSystem.out.println(s1.equals(s2));\n```\n\n- 不要使用`==`来判断字符串是否相等\n\n```java\nString s1 = \"abc\";\nString s2 = \"abc\";\nSystem.out.println(s1 == s2);\nSystem.out.println(s1.substring(1));\nSystem.out.println(s1.substring(1) == \"bc\");\n>>>\n    true\n    bc\n    false\n```\n\n\n\n## equals\n\n> equals是String类的方法，专门用于判断两个字符串是否相等\n\n```java\nString s1 = \"abc\";\nString s2 = \"abc\";\nSystem.out.println(s1.equals(s2));\nSystem.out.println(\"abd\".equals(s2));\n```\n\n\n\n## compareTo\n\n> compareTo用于比较两个字符串的大小，相等返回0，s1大返回正数，s2大返回复数\n\n```java\nString s1 = \"abc\";\nString s2 = \"abc\";\nSystem.out.println(s1.compareTo(s2) == 0);\n```\n\n# 空串与null串\n\n> 空串：`String s = \"\";`\n>\n> 空串的长度为0，可以利用这点来判断是否为空串\n>\n> null串：`String s = null;`\n>\n> null串需要特别注意，在判断字符串内容是否与指定内容相等时最好先确保字符串不是null串，否则会出现空指针异常(java.lang.NullPointException)\n\n```java\n// 普通避免字符串空指针异常的方法\nif(s != null){\n    s.equals(\"123\");\n}\n// 更简便的方法\n\"123\".equals(s);\n\n\n// 既不是空串也不是null串\nif(str != null && str.length() != 0)\n```\n\n\n\n# 码点与代码单元\n\n下面的代码的执行结果是很奇怪的\n\n```java\nString s1 = \"𝕆abc\";\nSystem.out.println(s1.charAt(1));\n>>>\n    晢\n```\n\n根据猜想，返回结果应该是下标为1的字符`a`，可是实际返回的确实奇怪的`晢`\n\n原因在于：使用UTF-16编码表示字符𝕆(U+1D546)需要两个代码单元。\n\n这个字符的第二个代码单元显示的字符就是`晢`,因此`charAt(1)`获取到的就是他\n\n正确的取出码点的方法如下：\n\n```java\nString s1 = \"𝕆abc\";\nint i = 0;\n// 简单方法\nSystem.out.println(Arrays.toString(s1.codePoints().toArray()));\n// 完整方法\nwhile (i < s1.codePointCount(0, s1.length())) {\n    int cp = s1.codePointAt(i);\n    if (Character.isSupplementaryCodePoint(cp))\n        i += 2;\n    else\n        i++;\n    System.out.println(cp);\n}\n```\n\n> 因为charAt()过于底层，不建议使用它\n\n# 常用方法\n\n> `boolean equals(Object other)`\n>\n> 如果字符串与other相等，返回true。\n\n---\n\n> `boolean equalsIgnoreCase(String other)`\n>\n> 如果字符串与other相等（忽略大小写)，返回true。\n\n---\n\n> `int length()`\n>\n> 返回字符串的长度。\n\n---\n\n> `String substring(int beginlndex)`\n>\n> `String substring(int beginlndex,int endlndex)`\n>\n> 返回一个新字符串。这个字符串包含原始字符串中从beginlndex到串尾或endlndex-1的所有代码单元。\n\n---\n\n> `String trim()`\n>\n> 返回一个新字符串。这个字符串将删除了原始字符串头部和尾部的空格。\n\n---\n\n> `String join(CharSequence delimiter,CharSequence ...elements)`\n>\n> 返回一个新字符串，用给定的定界符连接所有元素。\n>\n> Java 8 新增\n\n---\n\n> `String toLowerCase()`\n>\n> `String toUpperCase()`\n>\n> 返回一个新字符串。这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。\n\n---\n\n> `int indexOf(String str)`\n>\n> `int indexOf(String str,int fromlndex)`\n>\n> `int indexOf(int cp)`\n>\n> `int indexOf(int cp,int fromlndex)`\n>\n> 返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromlndex开始计算。如果在原始串中不存在str，返回-1。\n\n---\n\n> `int lastIndexOf(String str)`\n>\n> `int lastIndexOf(String str,int fromlndex)`\n>\n> `int lastindexOf(int cp)`\n>\n> `int lastindexOf(int cp,int fromlndex)`\n>\n> 返回与字符串str或代码点cp匹配的最后一个子串的开始位置。这个位置从原始串尾端或fromlndex开始计算。\n\n---\n\n> `int compareTo(String other)`\n>\n> 按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0。\n\n---\n\n> `boolean startsWith(String prefix)`\n>\n> `boolean endsWith(String suffix)`\n>\n> 如果字符串以suffix开头或结尾，则返回true。.\n\n---\n\n> `String replace(CharSequence oldString,CharSequence newString)`\n>\n> 返回一个新字符串。这个字符串用newString代替原始字符串中所有的oldString。可以用String或StringBuilder对象作为CharSequence参数。\n\n> `String replaceAll(String regex, String replacement)`\n>\n> 返回一个新字符串。用给定的正则表达式regex去寻找字符串中满足条件的子串，并且替换成replacement\n\n\n\n# CharSequence\n\n> CharSequence是一个描述字符串结构的接口\n>\n> String、StringBuffer、StringBuilder都是他的实现类",
    type: "Java",
    tag: [
        "Java基础"
    ],
    hit: NumberInt("0"),
    createDate: ISODate("2022-05-13T03:19:15.887Z"),
    modifyDate: ISODate("2022-05-13T03:19:15.887Z"),
    _class: "com.wyj.blog.pojo.Article"
} ]);

// ----------------------------
// Collection structure for commitCount
// ----------------------------
db.getCollection("commitCount").drop();
db.createCollection("commitCount");

// ----------------------------
// Documents of commitCount
// ----------------------------
db.getCollection("commitCount").insert([ {
    _id: ObjectId("627a60cfa9803a69c3d6c823"),
    date: ISODate("2022-05-09T16:00:00.000Z"),
    commit: NumberLong("6"),
    _class: "com.wyj.blog.pojo.CommitCount"
} ]);
db.getCollection("commitCount").insert([ {
    _id: ObjectId("627b8dc21947aa32e2a4beb5"),
    date: ISODate("2022-05-10T16:00:00.000Z"),
    commit: NumberLong("10"),
    _class: "com.wyj.blog.pojo.CommitCount"
} ]);
db.getCollection("commitCount").insert([ {
    _id: ObjectId("627cb92706ea2876bc375af1"),
    date: ISODate("2022-05-11T16:00:00.000Z"),
    commit: NumberLong("3"),
    _class: "com.wyj.blog.pojo.CommitCount"
} ]);
db.getCollection("commitCount").insert([ {
    _id: ObjectId("627dc78d556eb954b06fa661"),
    date: ISODate("2022-05-12T16:00:00.000Z"),
    commit: NumberLong("6"),
    _class: "com.wyj.blog.pojo.CommitCount"
} ]);

// ----------------------------
// Collection structure for tags
// ----------------------------
db.getCollection("tags").drop();
db.createCollection("tags");

// ----------------------------
// Documents of tags
// ----------------------------
db.getCollection("tags").insert([ {
    _id: ObjectId("627a60e2a9803a69c3d6c825"),
    tag: "Java基础",
    _class: "com.wyj.blog.pojo.Tag"
} ]);
db.getCollection("tags").insert([ {
    _id: ObjectId("627b8da81947aa32e2a4beb3"),
    tag: "Python模块",
    _class: "com.wyj.blog.pojo.Tag"
} ]);
db.getCollection("tags").insert([ {
    _id: ObjectId("627b90991947aa32e2a4beb8"),
    tag: "SpringBoot",
    _class: "com.wyj.blog.pojo.Tag"
} ]);
db.getCollection("tags").insert([ {
    _id: ObjectId("627b91a01947aa32e2a4bebc"),
    tag: "MySQL",
    _class: "com.wyj.blog.pojo.Tag"
} ]);
db.getCollection("tags").insert([ {
    _id: ObjectId("627b922b1947aa32e2a4bebf"),
    tag: "MongoDB",
    _class: "com.wyj.blog.pojo.Tag"
} ]);
db.getCollection("tags").insert([ {
    _id: ObjectId("627b93921947aa32e2a4bec1"),
    tag: "SQL Server",
    _class: "com.wyj.blog.pojo.Tag"
} ]);
db.getCollection("tags").insert([ {
    _id: ObjectId("627b95b91947aa32e2a4bec4"),
    tag: "设计模式",
    _class: "com.wyj.blog.pojo.Tag"
} ]);
db.getCollection("tags").insert([ {
    _id: ObjectId("627dc77f556eb954b06fa65f"),
    tag: "NodeJs",
    _class: "com.wyj.blog.pojo.Tag"
} ]);
db.getCollection("tags").insert([ {
    _id: ObjectId("627dca74556eb954b06fa663"),
    tag: "测试",
    _class: "com.wyj.blog.pojo.Tag"
} ]);
db.getCollection("tags").insert([ {
    _id: ObjectId("627dcb3e556eb954b06fa665"),
    tag: "Ajax",
    _class: "com.wyj.blog.pojo.Tag"
} ]);
db.getCollection("tags").insert([ {
    _id: ObjectId("627dcd54556eb954b06fa66a"),
    tag: "VUE",
    _class: "com.wyj.blog.pojo.Tag"
} ]);

// ----------------------------
// Collection structure for total
// ----------------------------
db.getCollection("total").drop();
db.createCollection("total");

// ----------------------------
// Documents of total
// ----------------------------
db.getCollection("total").insert([ {
    _id: ObjectId("627a6048a9803a69c3d6c821"),
    type: "article",
    hit: NumberLong("56"),
    visitor: NumberLong("20"),
    article: NumberLong("23"),
    tags: NumberLong("11"),
    types: NumberLong("6"),
    _class: "com.wyj.blog.pojo.ArticleTotal",
    commit: NumberLong("25"),
    comments: NumberLong("7")
} ]);

// ----------------------------
// Collection structure for types
// ----------------------------
db.getCollection("types").drop();
db.createCollection("types");

// ----------------------------
// Documents of types
// ----------------------------
db.getCollection("types").insert([ {
    _id: ObjectId("627a60d9a9803a69c3d6c824"),
    type: "Java",
    _class: "com.wyj.blog.pojo.Type"
} ]);
db.getCollection("types").insert([ {
    _id: ObjectId("627a6267a9803a69c3d6c82e"),
    type: "JavaScript",
    _class: "com.wyj.blog.pojo.Type"
} ]);
db.getCollection("types").insert([ {
    _id: ObjectId("627b876b1947aa32e2a4beb2"),
    type: "Python",
    _class: "com.wyj.blog.pojo.Type"
} ]);
db.getCollection("types").insert([ {
    _id: ObjectId("627b91a51947aa32e2a4bebd"),
    type: "数据库",
    _class: "com.wyj.blog.pojo.Type"
} ]);
db.getCollection("types").insert([ {
    _id: ObjectId("627b95a61947aa32e2a4bec3"),
    type: "计算机通用知识",
    _class: "com.wyj.blog.pojo.Type"
} ]);
db.getCollection("types").insert([ {
    _id: ObjectId("627dca70556eb954b06fa662"),
    type: "测试",
    _class: "com.wyj.blog.pojo.Type"
} ]);
